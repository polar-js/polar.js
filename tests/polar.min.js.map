{"version":3,"sources":["webpack://Polar/webpack/bootstrap","webpack://Polar/./node_modules/gl-matrix/esm/common.js","webpack://Polar/./node_modules/gl-matrix/esm/index.js","webpack://Polar/./node_modules/gl-matrix/esm/mat2.js","webpack://Polar/./node_modules/gl-matrix/esm/mat2d.js","webpack://Polar/./node_modules/gl-matrix/esm/mat3.js","webpack://Polar/./node_modules/gl-matrix/esm/mat4.js","webpack://Polar/./node_modules/gl-matrix/esm/quat.js","webpack://Polar/./node_modules/gl-matrix/esm/quat2.js","webpack://Polar/./node_modules/gl-matrix/esm/vec2.js","webpack://Polar/./node_modules/gl-matrix/esm/vec3.js","webpack://Polar/./node_modules/gl-matrix/esm/vec4.js","webpack://Polar/./node_modules/maxrects-packer/dist/maxrects-packer.mjs","webpack://Polar/./node_modules/p2/src/collision/AABB.js","webpack://Polar/./node_modules/p2/src/collision/Broadphase.js","webpack://Polar/./node_modules/p2/src/collision/NaiveBroadphase.js","webpack://Polar/./node_modules/p2/src/collision/Narrowphase.js","webpack://Polar/./node_modules/p2/src/collision/Ray.js","webpack://Polar/./node_modules/p2/src/collision/RaycastResult.js","webpack://Polar/./node_modules/p2/src/collision/SAPBroadphase.js","webpack://Polar/./node_modules/p2/src/constraints/Constraint.js","webpack://Polar/./node_modules/p2/src/constraints/DistanceConstraint.js","webpack://Polar/./node_modules/p2/src/constraints/GearConstraint.js","webpack://Polar/./node_modules/p2/src/constraints/LockConstraint.js","webpack://Polar/./node_modules/p2/src/constraints/PrismaticConstraint.js","webpack://Polar/./node_modules/p2/src/constraints/RevoluteConstraint.js","webpack://Polar/./node_modules/p2/src/equations/AngleLockEquation.js","webpack://Polar/./node_modules/p2/src/equations/ContactEquation.js","webpack://Polar/./node_modules/p2/src/equations/Equation.js","webpack://Polar/./node_modules/p2/src/equations/FrictionEquation.js","webpack://Polar/./node_modules/p2/src/equations/RotationalLockEquation.js","webpack://Polar/./node_modules/p2/src/equations/RotationalVelocityEquation.js","webpack://Polar/./node_modules/p2/src/events/EventEmitter.js","webpack://Polar/./node_modules/p2/src/material/ContactMaterial.js","webpack://Polar/./node_modules/p2/src/material/Material.js","webpack://Polar/./node_modules/p2/src/math/polyk.js","webpack://Polar/./node_modules/p2/src/math/vec2.js","webpack://Polar/./node_modules/p2/src/objects/Body.js","webpack://Polar/./node_modules/p2/src/objects/LinearSpring.js","webpack://Polar/./node_modules/p2/src/objects/RotationalSpring.js","webpack://Polar/./node_modules/p2/src/objects/Spring.js","webpack://Polar/./node_modules/p2/src/objects/TopDownVehicle.js","webpack://Polar/./node_modules/p2/src/p2.js","webpack://Polar/./node_modules/p2/src/shapes/Box.js","webpack://Polar/./node_modules/p2/src/shapes/Capsule.js","webpack://Polar/./node_modules/p2/src/shapes/Circle.js","webpack://Polar/./node_modules/p2/src/shapes/Convex.js","webpack://Polar/./node_modules/p2/src/shapes/Heightfield.js","webpack://Polar/./node_modules/p2/src/shapes/Line.js","webpack://Polar/./node_modules/p2/src/shapes/Particle.js","webpack://Polar/./node_modules/p2/src/shapes/Plane.js","webpack://Polar/./node_modules/p2/src/shapes/Shape.js","webpack://Polar/./node_modules/p2/src/solver/GSSolver.js","webpack://Polar/./node_modules/p2/src/solver/Solver.js","webpack://Polar/./node_modules/p2/src/utils/ContactEquationPool.js","webpack://Polar/./node_modules/p2/src/utils/FrictionEquationPool.js","webpack://Polar/./node_modules/p2/src/utils/IslandNodePool.js","webpack://Polar/./node_modules/p2/src/utils/IslandPool.js","webpack://Polar/./node_modules/p2/src/utils/OverlapKeeper.js","webpack://Polar/./node_modules/p2/src/utils/OverlapKeeperRecord.js","webpack://Polar/./node_modules/p2/src/utils/OverlapKeeperRecordPool.js","webpack://Polar/./node_modules/p2/src/utils/Pool.js","webpack://Polar/./node_modules/p2/src/utils/TupleDictionary.js","webpack://Polar/./node_modules/p2/src/utils/Utils.js","webpack://Polar/./node_modules/p2/src/world/Island.js","webpack://Polar/./node_modules/p2/src/world/IslandManager.js","webpack://Polar/./node_modules/p2/src/world/IslandNode.js","webpack://Polar/./node_modules/p2/src/world/World.js","webpack://Polar/./node_modules/poly-decomp/src/Line.js","webpack://Polar/./node_modules/poly-decomp/src/Point.js","webpack://Polar/./node_modules/poly-decomp/src/Polygon.js","webpack://Polar/./node_modules/poly-decomp/src/Scalar.js","webpack://Polar/./node_modules/poly-decomp/src/index.js","webpack://Polar/./src/Polar.ts","webpack://Polar/./src/Polar/Core/Application.ts","webpack://Polar/./src/Polar/Core/ApplicationSettings.ts","webpack://Polar/./src/Polar/Core/Input.ts","webpack://Polar/./src/Polar/Core/Layer.ts","webpack://Polar/./src/Polar/Core/LayerStack.ts","webpack://Polar/./src/Polar/ECS/Component.ts","webpack://Polar/./src/Polar/ECS/Components.ts","webpack://Polar/./src/Polar/ECS/ECSState.ts","webpack://Polar/./src/Polar/ECS/Entity.ts","webpack://Polar/./src/Polar/ECS/System.ts","webpack://Polar/./src/Polar/ECS/Systems/CameraControllerSystem.ts","webpack://Polar/./src/Polar/ECS/Systems/FPSDebugSystem.ts","webpack://Polar/./src/Polar/ECS/Systems/LightRenderSystem.ts","webpack://Polar/./src/Polar/ECS/Systems/ParticleSystem.ts","webpack://Polar/./src/Polar/ECS/Systems/Physics.ts","webpack://Polar/./src/Polar/ECS/Systems/RenderSystem.ts","webpack://Polar/./src/Polar/ECS/Systems/TextureLoad.ts","webpack://Polar/./src/Polar/ECS/Systems/TransformSystem.ts","webpack://Polar/./src/Polar/ECS/WorldManager.ts","webpack://Polar/./src/Polar/Events/ApplicationEvent.ts","webpack://Polar/./src/Polar/Events/Event.ts","webpack://Polar/./src/Polar/Events/KeyEvent.ts","webpack://Polar/./src/Polar/Events/MouseEvent.ts","webpack://Polar/./src/Polar/Renderer/Buffer.ts","webpack://Polar/./src/Polar/Renderer/FrameBuffer.ts","webpack://Polar/./src/Polar/Renderer/ImageLibrary.ts","webpack://Polar/./src/Polar/Renderer/InstancedRenderer.ts","webpack://Polar/./src/Polar/Renderer/LightRenderer.ts","webpack://Polar/./src/Polar/Renderer/OrthographicCamera.ts","webpack://Polar/./src/Polar/Renderer/ParticleEmitter.ts","webpack://Polar/./src/Polar/Renderer/ParticleRenderer.ts","webpack://Polar/./src/Polar/Renderer/PostprocessingStage.ts","webpack://Polar/./src/Polar/Renderer/RenderBuffer.ts","webpack://Polar/./src/Polar/Renderer/RenderCommand.ts","webpack://Polar/./src/Polar/Renderer/Renderer.ts","webpack://Polar/./src/Polar/Renderer/Shader.ts","webpack://Polar/./src/Polar/Renderer/ShaderLibrary.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/ColorShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/GaussianBlurShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/GrayscaleShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/InstancedTextureShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/InvertShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/LightShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/MultiplyTextureShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/ParticlePointShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/ParticleTextureShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/ParticleUpdateShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/TextureShaderSource.ts","webpack://Polar/./src/Polar/Renderer/ShaderSource/VignetteShaderSource.ts","webpack://Polar/./src/Polar/Renderer/Sprite.ts","webpack://Polar/./src/Polar/Renderer/Surface.ts","webpack://Polar/./src/Polar/Renderer/Texture.ts","webpack://Polar/./src/Polar/Renderer/TextureAtlas.ts","webpack://Polar/./src/Polar/Renderer/TextureLibrary.ts","webpack://Polar/./src/Polar/Renderer/VertexArray.ts","webpack://Polar/./src/Polar/Util/Math.ts","webpack://Polar/./src/Polar/Util/OrthographicCameraController.ts","webpack://Polar/./src/Polar/Util/Timer.ts"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA,WAAW,KAAK;AAChB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACN;AACE;AACF;AACA;AACA;AACE;AACF;AACA;AACA;;;;;;;;;;;;;ACTlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;;AAEnC,MAAM,qDAAmB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA,gBAAgB;;AAEhB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB;AAC7S;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO,mB;;;;;;;;;;;;AC/aP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;;AAEO;AACP,gBAAgB,qDAAmB;;AAEnC,MAAM,qDAAmB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB;AACvd;AACA;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO,mB;;;;;;;;;;;;ACreP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;;AAEnC,MAAM,qDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf,UAAU,KAAK;AACf;AACA,YAAY,KAAK;AACjB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf,UAAU,KAAK;AACf;AACA,YAAY,KAAK;AACjB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB;AACttB;AACA;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO,mB;;;;;;;;;;;;AC1wBP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;;AAEnC,MAAM,qDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,kDAAgB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA,YAAY,kDAAgB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,aAAa,KAAK;AAClB;;AAEO;AACP,wBAAwB,qDAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;;AAExD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,YAAY,KAAK;AACjB;;AAEO;AACP,oBAAoB,qDAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,kDAAgB,+BAA+B,kDAAgB,+BAA+B,kDAAgB;AAC/I;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,uEAAuE,kDAAgB,yEAAyE,kDAAgB,yEAAyE,kDAAgB,yEAAyE,kDAAgB,yEAAyE,kDAAgB,yEAAyE,kDAAgB;AAC/zC;AACA;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO,mB;;;;;;;;;;;;ACtxDP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACN;AACA;AACA;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;;AAEnC,MAAM,qDAAmB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB;;AAEO;AACP;AACA;;AAEA,UAAU,kDAAgB;AAC1B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C,gDAAgD;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH,oBAAoB,kDAAgB;AACpC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA,WAAW,iDAAe;AAC1B,WAAW,iDAAe;AAC1B,WAAW,iDAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;;AAEpC;AACA,wBAAwB;;AAExB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa,KAAK;AAClB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;;AAEO,YAAY,8CAAU;AAC7B;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACA;;AAEO,iBAAiB,mDAAe;AACvC;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;;AAEO,WAAW,6CAAS;AAC3B;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACA;;AAEO,UAAU,4CAAQ;AACzB;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;;AAEO,UAAU,4CAAQ;AACzB;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACA;;AAEO,YAAY,8CAAU;AAC7B;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACA;;AAEO,UAAU,4CAAQ;AACzB;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACA;;AAEO,WAAW,6CAAS;AAC3B;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO,aAAa,+CAAW;AAC/B;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACA;;AAEO,oBAAoB,sDAAkB;AAC7C;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;;AAEO,gBAAgB,kDAAc;AACrC;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO,kBAAkB,oDAAgB;AACzC;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO,aAAa,+CAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,+CAAW;AAC3B,kBAAkB,mDAAe;AACjC,kBAAkB,mDAAe;AACjC;AACA,cAAc,4CAAQ;;AAEtB;AACA,MAAM,8CAAU;AAChB,UAAU,4CAAQ,sBAAsB,8CAAU;AAClD,MAAM,kDAAc;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,8CAAU;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP,aAAa,+CAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,G;;;;;;;;;;;;ACrsBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACN;AACA;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;;AAEO;AACP,eAAe,qDAAmB;;AAElC,MAAM,qDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP,eAAe,qDAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP,eAAe,qDAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP,eAAe,qDAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA,cAAc,+CAAW;AACzB,EAAE,oDAAgB;AAClB,cAAc,qDAAmB;AACjC,EAAE,uDAAmB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB;;AAEO,cAAc,6CAAS;AAC9B;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;;AAEO,cAAc,6CAAS;AAC9B;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gDAAY;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gDAAY;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gDAAY;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA,sBAAsB,kDAAgB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;;AAEO,UAAU,4CAAQ;AACzB;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;;AAEO,aAAa,+CAAW;AAC/B;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;;AAEO,oBAAoB,sDAAkB;AAC7C;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB;AACjoB,C;;;;;;;;;;;;ACl0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;;AAEnC,MAAM,qDAAmB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA,UAAU,iDAAe;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA,8BAA8B,kDAAgB,qEAAqE,kDAAgB;AACnI;AACA;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,G;;;;;;;;;;;;AChoBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;;AAEnC,MAAM,qDAAmB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA,UAAU,iDAAe;AACzB,UAAU,iDAAe;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA,aAAa;;AAEb;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA,aAAa;;AAEb;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA,aAAa;;AAEb;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB;AACxN;AACA;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,G;;;;;;;;;;;;ACpxBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;;AAEnC,MAAM,qDAAmB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP,gBAAgB,qDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;;AAEO;AACP,uBAAuB;AACvB;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,iDAAe;AACxB,SAAS,iDAAe;AACxB;AACA,GAAG;;AAEH;AACA,SAAS,iDAAe;AACxB,SAAS,iDAAe;AACxB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB,qEAAqE,kDAAgB;AAC7S;AACA;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA,cAAc;AACd;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,G;;;;;;;;;;;;ACvpBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC,4BAA4B,2CAA2C;AACvE;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,+DAA+D;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+FAA+F,mHAAmH;AAClN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ,YAAY;AACnC;AACA;AACA,yFAAyF,oHAAoH;AAC7M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qBAAqB;AACpE;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY,eAAe;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,iBAAiB,yCAAyC;AAC1D;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2F;AAC3F;;;;;;;;;;;;;;;;;;;;;;;AC9rBA,WAAW,mBAAO,CAAC,wDAAc;AACjC,YAAY,mBAAO,CAAC,4DAAgB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;ACxMA,WAAW,mBAAO,CAAC,wDAAc;AACjC,WAAW,mBAAO,CAAC,8DAAiB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;AC/JA,aAAa,mBAAO,CAAC,gEAAkB;AACvC,YAAY,mBAAO,CAAC,8DAAiB;AACrC,YAAY,mBAAO,CAAC,8DAAiB;AACrC,eAAe,mBAAO,CAAC,oEAAoB;AAC3C,iBAAiB,mBAAO,CAAC,8EAAyB;AAClD,WAAW,mBAAO,CAAC,wDAAc;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,gBAAgB;AAC1D;;AAEA,oBAAoB,KAAK;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;AC1EA,WAAW,mBAAO,CAAC,wDAAc;AACjC;AACA;AACA;AACA,YAAY,mBAAO,CAAC,4DAAgB;AACpC,0BAA0B,mBAAO,CAAC,wFAA8B;AAChE,2BAA2B,mBAAO,CAAC,0FAA+B;AAClE,sBAAsB,mBAAO,CAAC,gFAA0B;AACxD,eAAe,mBAAO,CAAC,0EAAuB;AAC9C,sBAAsB,mBAAO,CAAC,wFAA8B;AAC5D,uBAAuB,mBAAO,CAAC,0FAA+B;AAC9D,aAAa,mBAAO,CAAC,gEAAkB;AACvC,aAAa,mBAAO,CAAC,gEAAkB;AACvC,YAAY,mBAAO,CAAC,8DAAiB;AACrC,WAAW,mBAAO,CAAC,8DAAiB;AACpC,UAAU,mBAAO,CAAC,0DAAe;;AAEjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW;;AAEnE;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA,0DAA0D,WAAW;;AAErE;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,cAAc;AAC5D;;AAEA;;AAEA;AACA,kDAAkD,cAAc;AAChE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,sBAAsB;AAC5D;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,sBAAsB;;AAE9D;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA,gBAAgB,KAAK;;AAErB;AACA;AACA;;AAEA,oBAAoB,KAAK;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,gBAAgB;AAChC;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,oBAAoB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,SAAS;AACrB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,iCAAiC;AACjD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,SAAS;AACrB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,SAAS;AACrB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,YAAY;AACrD;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,SAAS;AACrB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD;AACrD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,KAAK;;AAErB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,kBAAkB;;AAEjD;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qCAAqC,kBAAkB;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wDAAwD;AACxD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sDAAsD;AACtD;;AAEA,mDAAmD;AACnD,4CAA4C;AAC5C,yDAAyD;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,OAAO;;AAE/B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;;AAEvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB,YAAY,YAAY;AACxB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,QAAQ;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,SAAS;;AAEhC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,oDAAoD,sEAAsE;AAC1H;AACA;AACA,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB,YAAY,YAAY;AACxB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,QAAQ;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;ACh4EA;;AAEA,WAAW,mBAAO,CAAC,wDAAc;AACjC,oBAAoB,mBAAO,CAAC,oFAA4B;AACxD,YAAY,mBAAO,CAAC,8DAAiB;AACrC,WAAW,mBAAO,CAAC,kEAAmB;;AAEtC;AACA,6FAA6F,mCAAmC,eAAe;AAC/I;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,0CAA0C,+BAA+B,SAAS,YAAY,IAAI,+BAA+B,SAAS,YAAY,MAAM,mCAAmC,aAAa,YAAY;AACxN,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,sCAAsC,mCAAmC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2CAA2C,OAAO;AAClD;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACjTA,WAAW,mBAAO,CAAC,wDAAc;AACjC,UAAU,mBAAO,CAAC,gEAAkB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,IAAI;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;AClIA,YAAY,mBAAO,CAAC,4DAAgB;AACpC,iBAAiB,mBAAO,CAAC,8EAAyB;;AAElD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;;AAEA,sBAAsB,KAAK;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wBAAwB,YAAY;AACpC,wBAAwB,YAAY;;AAEpC;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;ACnLA;;AAEA,YAAY,mBAAO,CAAC,4DAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtIA,iBAAiB,mBAAO,CAAC,qEAAc;AACvC,eAAe,mBAAO,CAAC,0EAAuB;AAC9C,WAAW,mBAAO,CAAC,wDAAc;AACjC,YAAY,mBAAO,CAAC,4DAAgB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D,6BAA6B,4BAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,8DAA8D;AAC9D;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3QA,iBAAiB,mBAAO,CAAC,qEAAc;AACvC,eAAe,mBAAO,CAAC,0EAAuB;AAC9C,wBAAwB,mBAAO,CAAC,4FAAgC;AAChE,WAAW,mBAAO,CAAC,wDAAc;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,E;;;;;;;;;;;AC1FA,iBAAiB,mBAAO,CAAC,qEAAc;AACvC,WAAW,mBAAO,CAAC,wDAAc;AACjC,eAAe,mBAAO,CAAC,0EAAuB;;AAE9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9KA,iBAAiB,mBAAO,CAAC,qEAAc;AACvC,sBAAsB,mBAAO,CAAC,wFAA8B;AAC5D,eAAe,mBAAO,CAAC,0EAAuB;AAC9C,WAAW,mBAAO,CAAC,wDAAc;AACjC,6BAA6B,mBAAO,CAAC,sGAAqC;;AAE1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,+CAA+C;AAC5E,2BAA2B,6CAA6C;AACxE,6BAA6B,+CAA+C;;AAE5E;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;AC9VA,iBAAiB,mBAAO,CAAC,qEAAc;AACvC,eAAe,mBAAO,CAAC,0EAAuB;AAC9C,iCAAiC,mBAAO,CAAC,8GAAyC;AAClF,6BAA6B,mBAAO,CAAC,sGAAqC;AAC1E,WAAW,mBAAO,CAAC,wDAAc;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D,6BAA6B,4BAA4B;AACzD;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpUA,eAAe,mBAAO,CAAC,+DAAY;AACnC,WAAW,mBAAO,CAAC,wDAAc;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3DA,eAAe,mBAAO,CAAC,+DAAY;AACnC,WAAW,mBAAO,CAAC,wDAAc;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,E;;;;;;;;;;;ACnIA;;AAEA,WAAW,mBAAO,CAAC,wDAAc;AACjC,YAAY,mBAAO,CAAC,4DAAgB;AACpC,WAAW,mBAAO,CAAC,8DAAiB;;AAEpC;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;;;;;;;;;;;AChUA,WAAW,mBAAO,CAAC,wDAAc;AACjC,eAAe,mBAAO,CAAC,+DAAY;AACnC,YAAY,mBAAO,CAAC,4DAAgB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;ACpHA,eAAe,mBAAO,CAAC,+DAAY;AACnC,WAAW,mBAAO,CAAC,wDAAc;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCA,eAAe,mBAAO,CAAC,+DAAY;AACnC,WAAW,mBAAO,CAAC,wDAAc;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,SAAS;AACzB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,SAAS;AACzB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,SAAS;AACzB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpGA,eAAe,mBAAO,CAAC,8DAAY;AACnC,eAAe,mBAAO,CAAC,0EAAuB;;AAE9C;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,+KAA+K,kDAAkD,4BAA4B,YAAY;AACzQ;AACA,cAAc;AACd;AACA;;AAEA;AACA,0GAA0G,mDAAmD,6BAA6B,YAAY;AACtM;AACA,cAAc;AACd;AACA;;AAEA;AACA,kNAAkN,kDAAkD,4BAA4B,YAAY;AAC5S;AACA,cAAc;AACd;AACA;;AAEA;AACA,6HAA6H,mDAAmD,6BAA6B,YAAY;AACzN;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;;;;;;;;;;;AC5GA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA,yBAAyB,iBAAiB,kBAAkB;AAC5D,yBAAyB,iBAAiB,kBAAkB;;AAE5D,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,iBAAiB,kBAAkB;AAChE,6BAA6B,iBAAiB,kBAAkB;;AAEhE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA,4FAA4F,iBAAiB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA,oBAAoB;AACpB;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,oBAAoB;AACpB,oBAAoB,YAAY;;AAEhC,oBAAoB,aAAa;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAA+C;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,gBAAgB;AACzC;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oBAAoB;;AAEpB,6BAA6B,sBAAsB,SAAS,QAAQ;AACpE;;AAEA,oBAAoB,KAAK;AACzB;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,6BAA6B,uBAAuB,SAAS,QAAQ;AACrE;;AAEA,oBAAoB,KAAK;AACzB;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,MAAM;AACtB;;AAEA;;;;;;;;;;;;AC5dA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY,mBAAO,CAAC,4DAAgB;;AAEpC;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA,oCAAoC;AACpC,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA,mCAAmC;AACnC,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,cAAc;AACd;;;;;;;;;;;;AChjBA,WAAW,mBAAO,CAAC,wDAAc;AACjC,aAAa,mBAAO,CAAC,4DAAa;AAClC,aAAa,mBAAO,CAAC,gEAAkB;AACvC,oBAAoB,mBAAO,CAAC,oFAA4B;AACxD,UAAU,mBAAO,CAAC,gEAAkB;AACpC,WAAW,mBAAO,CAAC,kEAAmB;AACtC,mBAAmB,mBAAO,CAAC,4EAAwB;;AAEnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,iEAAiE,2CAA2C,YAAY;AACxH;AACA,cAAc;AACd;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,oCAAoC,YAAY;AACnG;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,6DAA6D,mCAAmC,aAAa,YAAY,IAAI,oCAAoC,cAAc,YAAY,OAAO,sCAAsC,gBAAgB,YAAY;AACpQ;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,4DAA4D,qCAAqC,eAAe,YAAY;AAC5H;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA,0GAA0G,sBAAsB,YAAY;AAC5I;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,kCAAkC,YAAY,YAAY,IAAI,mCAAmC,aAAa,YAAY,OAAO,qCAAqC,eAAe,YAAY;AACjN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA,iCAAiC,MAAM;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,gBAAgB,qBAAqB;AACrC;AACA,4BAA4B,iCAAiC;;AAE7D;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,+CAA+C;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,kCAAkC,YAAY,YAAY;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;;;;;;;;;;;;AC9rCA,WAAW,mBAAO,CAAC,wDAAc;AACjC,aAAa,mBAAO,CAAC,yDAAU;AAC/B,YAAY,mBAAO,CAAC,4DAAgB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,6BAA6B,oDAAoD;AACjF,6BAA6B,oDAAoD;AACjF,6BAA6B,4CAA4C;AACzE,6BAA6B,4CAA4C;;AAEzE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvKA,WAAW,mBAAO,CAAC,wDAAc;AACjC,aAAa,mBAAO,CAAC,yDAAU;;AAE/B;;AAEA;AACA;AACA;AACA,uCAAuC,mCAAmC,YAAY;AACtF;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;;ACpDA,WAAW,mBAAO,CAAC,wDAAc;AACjC,YAAY,mBAAO,CAAC,4DAAgB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA,WAAW,mBAAO,CAAC,wDAAc;AACjC,YAAY,mBAAO,CAAC,4DAAgB;AACpC,iBAAiB,mBAAO,CAAC,kFAA2B;AACpD,uBAAuB,mBAAO,CAAC,0FAA+B;AAC9D,WAAW,mBAAO,CAAC,8DAAiB;;AAEpC;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA,gCAAgC,UAAU;;AAE1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;;AAEA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;A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ACA;AACA,mHAAmH,uBAAuB;AAC1I;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,KAAK;;AAErB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACjNA,YAAY,mBAAO,CAAC,sDAAS;AAC7B,YAAY,mBAAO,CAAC,wDAAc;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ,qEAAqE,sBAAsB,YAAY;AAC1H,WAAW,OAAO;AAClB;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,YAAY;AAC7H;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;;;;;ACjJA,YAAY,mBAAO,CAAC,sDAAS;AAC7B,WAAW,mBAAO,CAAC,wDAAc;AACjC,YAAY,mBAAO,CAAC,0DAAe;AACnC,aAAa,mBAAO,CAAC,4DAAa;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO,qEAAqE,sBAAsB,YAAY;AACzH,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,uBAAuB;AACxI;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,kCAAkC;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzXA,YAAY,mBAAO,CAAC,sDAAS;AAC7B,YAAY,mBAAO,CAAC,wDAAc;AAClC,aAAa,mBAAO,CAAC,4DAAgB;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO,qEAAqE,sBAAsB,YAAY;AACzH,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2HAA2H,sBAAsB;AACjJ;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;AC1PA,YAAY,mBAAO,CAAC,sDAAS;AAC7B,WAAW,mBAAO,CAAC,wDAAc;;AAEjC;;AAEA;AACA;AACA;AACA,WAAW,OAAO,qEAAqE,sBAAsB,YAAY;AACzH,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,iBAAiB;AAC9H;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA,E;;;;;;;;;;;AC3FA,YAAY,mBAAO,CAAC,sDAAS;AAC7B,WAAW,mBAAO,CAAC,wDAAc;;AAEjC;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO,qEAAqE,sBAAsB,YAAY;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrCA,aAAa,mBAAO,CAAC,sDAAS;AAC9B,aAAa,mBAAO,CAAC,wDAAc;AACnC,aAAa,mBAAO,CAAC,4DAAgB;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO,qEAAqE,sBAAsB,YAAY;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,E;;;;;;;;;;;ACvIA;;AAEA,WAAW,mBAAO,CAAC,wDAAc;;AAEjC;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA,WAAW,oCAAoC,cAAc;AAC7D,WAAW,sCAAsC,gBAAgB;AACjE,WAAW,mCAAmC,aAAa;AAC3D,WAAW,oCAAoC,cAAc;AAC7D,WAAW,kCAAkC,YAAY;AACzD,WAAW,iCAAiC,WAAW;AACvD,WAAW,qCAAqC,eAAe;AAC/D,WAAW,yCAAyC,mBAAmB;AACvE;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA,E;;;;;;;;;;;ACnPA,WAAW,mBAAO,CAAC,wDAAc;AACjC,aAAa,mBAAO,CAAC,wDAAU;AAC/B,YAAY,mBAAO,CAAC,4DAAgB;AACpC,uBAAuB,mBAAO,CAAC,0FAA+B;;AAE9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,aAAa;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,aAAa;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,wBAAwB;;AAE/C;AACA;;AAEA,wBAAwB,SAAS;AACjC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,gBAAgB;;AAEnC;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACvPA,YAAY,mBAAO,CAAC,4DAAgB;AACpC,mBAAmB,mBAAO,CAAC,4EAAwB;;AAEnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACpIA,sBAAsB,mBAAO,CAAC,wFAA8B;AAC5D,WAAW,mBAAO,CAAC,mDAAQ;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY;AACZ;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA,uBAAuB,mBAAO,CAAC,0FAA+B;AAC9D,WAAW,mBAAO,CAAC,mDAAQ;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,iBAAiB;AAC5B,YAAY;AACZ;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA,iBAAiB,mBAAO,CAAC,sEAAqB;AAC9C,WAAW,mBAAO,CAAC,mDAAQ;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA,aAAa,mBAAO,CAAC,8DAAiB;AACtC,WAAW,mBAAO,CAAC,mDAAQ;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA,sBAAsB,mBAAO,CAAC,yEAAmB;AACjD,0BAA0B,mBAAO,CAAC,iFAAuB;AACzD,8BAA8B,mBAAO,CAAC,yFAA2B;AACjE,YAAY,mBAAO,CAAC,qDAAS;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;ACxKA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB;AACA;AACA;AACA;;;;;;;;;;;;ACxCA,0BAA0B,mBAAO,CAAC,iFAAuB;AACzD,WAAW,mBAAO,CAAC,mDAAQ;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,MAAM;AACrB,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,KAAK;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1DA,YAAY,mBAAO,CAAC,qDAAS;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvHA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,KAAK;AACL,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5FA,WAAW,mBAAO,CAAC,8DAAiB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpFA,WAAW,mBAAO,CAAC,wDAAc;AACjC,aAAa,mBAAO,CAAC,uDAAU;AAC/B,iBAAiB,mBAAO,CAAC,+DAAc;AACvC,qBAAqB,mBAAO,CAAC,gFAA2B;AACxD,iBAAiB,mBAAO,CAAC,wEAAuB;AAChD,WAAW,mBAAO,CAAC,8DAAiB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,wCAAwC,WAAW;;AAEnD;AACA;AACA,cAAc;AACd;AACA,sCAAsC,UAAU;;AAEhD;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA,uBAAuB,uBAAuB,YAAY;AAC1D,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AAC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AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;;AAEA;AACA,0HAA0H,8BAA8B,YAAY;AACpK,kBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,yEAAyE,yCAAyC,mBAAmB,YAAY,IAAI,2CAA2C,qBAAqB,YAAY,OAAO,6CAA6C,uBAAuB,YAAY;AACxT,mDAAmD,iCAAiC,SAAS,YAAY,sJAAsJ,uCAAuC,iBAAiB,YAAY;AACnU;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC,0CAA0C;;AAE1C;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA,kGAAkG,yCAAyC,cAAc,YAAY;AACrK;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;;AAElC;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC,MAAM;AAC1C,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;;AAEA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;;AAEA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA,KAAK;;AAEL;AACA,gBAAgB,aAAa;AAC7B;AACA;;AAEA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qEAAqE,8BAA8B;AACnG;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2EAA2E;AAC3E,2EAA2E,+BAA+B;AAC1G;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,KAAK;AACjB;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,MAAM;AAChC;AACA;;AAEA;AACA;AACA,8BAA8B,MAAM;AACpC;AACA;;AAEA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;;AAEA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;;AAEA,wCAAwC,QAAQ;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA,gBAAgB,+BAA+B;AAC/C;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,oCAAoC;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,IAAI;AAChB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AChwCA,aAAa,mBAAO,CAAC,0DAAU;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;AACA;AACA;AACA,kBAAkB;AAClB,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC5DA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzEA,WAAW,mBAAO,CAAC,sDAAQ;AAC3B,YAAY,mBAAO,CAAC,wDAAS;AAC7B,aAAa,mBAAO,CAAC,0DAAU;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,MAAM;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B,OAAO;AACtD;AACA;AACA,wHAAwH;AACxH;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;;AAEA,KAAK;;AAEL;AACA,oBAAoB,MAAM;AAC1B;;AAEA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;;AAEA,gCAAgC,eAAe;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD,qDAAqD;AACrD,mDAAmD;AACnD,yDAAyD;AACzD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;;AAGA,2BAA2B,0BAA0B;AACrD;AACA,uFAAuF;AACvF,qGAAqG;AACrG,qEAAqE;AACrE;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA,qCAAqC,gCAAgC;AACrE;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7eA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpBA;AACA,cAAc,mBAAO,CAAC,4DAAW;AACjC,YAAY,mBAAO,CAAC,wDAAS;AAC7B;;;;;;;;;;;;;;;;;;ACHA,6GAAuD;AAiC9C,sBAjC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","file":"polar.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/Polar.ts\");\n","/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\r\n * Sets the type of array used when creating new vectors and matrices\r\n *\r\n * @param {Type} type Array type, such as Float32Array or Array\r\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\r\n * Convert Degree To Radian\r\n *\r\n * @param {Number} a Angle in Degrees\r\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\r\n * Tests whether or not the arguments have approximately the same value, within an absolute\r\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\r\n * than or equal to 1.0, and a relative tolerance is used for larger values)\r\n *\r\n * @param {Number} a The first number to test.\r\n * @param {Number} b The second number to test.\r\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\nimport * as mat2 from \"./mat2.js\";\nimport * as mat2d from \"./mat2d.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as mat4 from \"./mat4.js\";\nimport * as quat from \"./quat.js\";\nimport * as quat2 from \"./quat2.js\";\nimport * as vec2 from \"./vec2.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\nexport { glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 };","import * as glMatrix from \"./common.js\";\n/**\r\n * 2x2 Matrix\r\n * @module mat2\r\n */\n\n/**\r\n * Creates a new identity mat2\r\n *\r\n * @returns {mat2} a new 2x2 matrix\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat2 initialized with values from an existing matrix\r\n *\r\n * @param {mat2} a matrix to clone\r\n * @returns {mat2} a new 2x2 matrix\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Copy the values from one mat2 to another\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set a mat2 to the identity matrix\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @returns {mat2} out\r\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Create a new mat2 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out A new 2x2 matrix\r\n */\n\nexport function fromValues(m00, m01, m10, m11) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\r\n * Set the components of a mat2 to the given values\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out\r\n */\n\nexport function set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\r\n * Transpose the values of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    var a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3]; // Calculate the determinant\n\n  var det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] = a0 * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nexport function adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  var a0 = a[0];\n  out[0] = a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a0;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat2\r\n *\r\n * @param {mat2} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nexport function determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n/**\r\n * Multiplies two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\nexport function multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n/**\r\n * Rotates a mat2 by the given angle\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\n\nexport function rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n/**\r\n * Scales the mat2 by the dimensions in the given vec2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to rotate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat2} out\r\n **/\n\nexport function scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.scale(dest, dest, vec);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat2} out\r\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n/**\r\n * Returns a string representation of a mat2\r\n *\r\n * @param {mat2} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nexport function str(a) {\n  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n/**\r\n * Returns Frobenius norm of a mat2\r\n *\r\n * @param {mat2} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3]);\n}\n/**\r\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\r\n * @param {mat2} L the lower triangular matrix\r\n * @param {mat2} D the diagonal matrix\r\n * @param {mat2} U the upper triangular matrix\r\n * @param {mat2} a the input matrix to factorize\r\n */\n\nexport function LDU(L, D, U, a) {\n  L[2] = a[2] / a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n/**\r\n * Adds two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat2} a The first matrix.\r\n * @param {mat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat2} a The first matrix.\r\n * @param {mat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2} out\r\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2} out the receiving vector\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2} out\r\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Alias for {@link mat2.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link mat2.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\r\n * 2x3 Matrix\r\n * @module mat2d\r\n *\r\n * @description\r\n * A mat2d contains six elements defined as:\r\n * <pre>\r\n * [a, b, c,\r\n *  d, tx, ty]\r\n * </pre>\r\n * This is a short form for the 3x3 matrix:\r\n * <pre>\r\n * [a, b, 0,\r\n *  c, d, 0,\r\n *  tx, ty, 1]\r\n * </pre>\r\n * The last column is ignored so the array is shorter and operations are faster.\r\n */\n\n/**\r\n * Creates a new identity mat2d\r\n *\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(6);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[4] = 0;\n    out[5] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat2d initialized with values from an existing matrix\r\n *\r\n * @param {mat2d} a matrix to clone\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\r\n * Copy the values from one mat2d to another\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\r\n * Set a mat2d to the identity matrix\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @returns {mat2d} out\r\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Create a new mat2d with the given values\r\n *\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} A new mat2d\r\n */\n\nexport function fromValues(a, b, c, d, tx, ty) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\r\n * Set the components of a mat2d to the given values\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} out\r\n */\n\nexport function set(out, a, b, c, d, tx, ty) {\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\r\n * Inverts a mat2d\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\n\nexport function invert(out, a) {\n  var aa = a[0],\n      ab = a[1],\n      ac = a[2],\n      ad = a[3];\n  var atx = a[4],\n      aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat2d\r\n *\r\n * @param {mat2d} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nexport function determinant(a) {\n  return a[0] * a[3] - a[1] * a[2];\n}\n/**\r\n * Multiplies two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\nexport function multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  out[4] = a0 * b4 + a2 * b5 + a4;\n  out[5] = a1 * b4 + a3 * b5 + a5;\n  return out;\n}\n/**\r\n * Rotates a mat2d by the given angle\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\n\nexport function rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\r\n * Scales the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to translate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat2d} out\r\n **/\n\nexport function scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\r\n * Translates the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to translate\r\n * @param {vec2} v the vec2 to translate the matrix by\r\n * @returns {mat2d} out\r\n **/\n\nexport function translate(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0;\n  out[1] = a1;\n  out[2] = a2;\n  out[3] = a3;\n  out[4] = a0 * v0 + a2 * v1 + a4;\n  out[5] = a1 * v0 + a3 * v1 + a5;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.scale(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat2d} out\r\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.translate(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {vec2} v Translation vector\r\n * @returns {mat2d} out\r\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = v[0];\n  out[5] = v[1];\n  return out;\n}\n/**\r\n * Returns a string representation of a mat2d\r\n *\r\n * @param {mat2d} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nexport function str(a) {\n  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';\n}\n/**\r\n * Returns Frobenius norm of a mat2d\r\n *\r\n * @param {mat2d} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);\n}\n/**\r\n * Adds two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2d} out\r\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  return out;\n}\n/**\r\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2d} out the receiving vector\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2d} out\r\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat2d} a The first matrix.\r\n * @param {mat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat2d} a The first matrix.\r\n * @param {mat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));\n}\n/**\r\n * Alias for {@link mat2d.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link mat2d.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\r\n * 3x3 Matrix\r\n * @module mat3\r\n */\n\n/**\r\n * Creates a new identity mat3\r\n *\r\n * @returns {mat3} a new 3x3 matrix\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Copies the upper-left 3x3 values into the given mat3.\r\n *\r\n * @param {mat3} out the receiving 3x3 matrix\r\n * @param {mat4} a   the source 4x4 matrix\r\n * @returns {mat3} out\r\n */\n\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\r\n * Creates a new mat3 initialized with values from an existing matrix\r\n *\r\n * @param {mat3} a matrix to clone\r\n * @returns {mat3} a new 3x3 matrix\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Copy the values from one mat3 to another\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Create a new mat3 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} A new mat3\r\n */\n\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\r\n * Set the components of a mat3 to the given values\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} out\r\n */\n\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\r\n * Set a mat3 to the identity matrix\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @returns {mat3} out\r\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat3\r\n *\r\n * @param {mat3} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\r\n * Multiplies two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\r\n * Translate a mat3 by the given vector\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to translate\r\n * @param {vec2} v vector to translate by\r\n * @returns {mat3} out\r\n */\n\nexport function translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\r\n * Rotates a mat3 by the given angle\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\n\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n;\n/**\r\n * Scales the mat3 by the dimensions in the given vec2\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to rotate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat3} out\r\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.translate(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {vec2} v Translation vector\r\n * @returns {mat3} out\r\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.rotate(dest, dest, rad);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.scale(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat3} out\r\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Copies the values from a mat2d into a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat2d} a the matrix to copy\r\n * @returns {mat3} out\r\n **/\n\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\r\n* Calculates a 3x3 matrix from the given quaternion\r\n*\r\n* @param {mat3} out mat3 receiving operation result\r\n* @param {quat} q Quaternion to create matrix from\r\n*\r\n* @returns {mat3} out\r\n*/\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\r\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\r\n*\r\n* @param {mat3} out mat3 receiving operation result\r\n* @param {mat4} a Mat4 to derive the normal matrix from\r\n*\r\n* @returns {mat3} out\r\n*/\n\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\r\n * Generates a 2D projection matrix with the given bounds\r\n *\r\n * @param {mat3} out mat3 frustum matrix will be written into\r\n * @param {number} width Width of your gl context\r\n * @param {number} height Height of gl context\r\n * @returns {mat3} out\r\n */\n\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Returns a string representation of a mat3\r\n *\r\n * @param {mat3} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nexport function str(a) {\n  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';\n}\n/**\r\n * Returns Frobenius norm of a mat3\r\n *\r\n * @param {mat3} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\r\n * Adds two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat3} out\r\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\r\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat3} out the receiving vector\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat3} out\r\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat3} a The first matrix.\r\n * @param {mat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat3} a The first matrix.\r\n * @param {mat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\r\n * Alias for {@link mat3.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link mat3.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\r\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\r\n * @module mat4\r\n */\n\n/**\r\n * Creates a new identity mat4\r\n *\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 initialized with values from an existing matrix\r\n *\r\n * @param {mat4} a matrix to clone\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Copy the values from one mat4 to another\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Create a new mat4 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} A new mat4\r\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set the components of a mat4 to the given values\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} out\r\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set a mat4 to the identity matrix\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @returns {mat4} out\r\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat4\r\n *\r\n * @param {mat4} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\r\n * Multiplies two mat4s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\r\n * Translate a mat4 by the given vector\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to translate\r\n * @param {vec3} v vector to translate by\r\n * @returns {mat4} out\r\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\r\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to scale\r\n * @param {vec3} v the vec3 to scale the matrix by\r\n * @returns {mat4} out\r\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Rotates a mat4 by the given angle around the given axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {vec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the X axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Y axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Z axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {vec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.scale(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {vec3} v Scaling vector\r\n * @returns {mat4} out\r\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle around a given axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotate(dest, dest, rad, axis);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {vec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the X axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateX(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Y axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateY(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Z axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateZ(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation and vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 from a dual quat.\r\n *\r\n * @param {mat4} out Matrix\r\n * @param {quat2} a Dual Quaternion\r\n * @returns {mat4} mat4 receiving operation result\r\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\r\n * Returns the translation vector component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslation,\r\n *  the returned vector will be the same as the translation vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive translation component\r\n * @param  {mat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\r\n * Returns the scaling factor component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslationScale\r\n *  with a normalized Quaternion paramter, the returned vector will be\r\n *  the same as the scaling vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive scaling factor component\r\n * @param  {mat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\r\n * Returns a quaternion representing the rotational component\r\n *  of a transformation matrix. If a matrix is built with\r\n *  fromRotationTranslation, the returned quaternion will be the\r\n *  same as the quaternion originally supplied.\r\n * @param {quat} out Quaternion to receive the rotation component\r\n * @param {mat4} mat Matrix to be decomposed (input)\r\n * @return {quat} out\r\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @param {vec3} s Scaling vector\r\n * @returns {mat4} out\r\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     mat4.translate(dest, origin);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *     mat4.translate(dest, negativeOrigin);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @param {vec3} s Scaling vector\r\n * @param {vec3} o The origin vector around which to scale and rotate\r\n * @returns {mat4} out\r\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Calculates a 4x4 matrix from the given quaternion\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat4} out\r\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a frustum matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Number} left Left bound of the frustum\r\n * @param {Number} right Right bound of the frustum\r\n * @param {Number} bottom Bottom bound of the frustum\r\n * @param {Number} top Top bound of the frustum\r\n * @param {Number} near Near bound of the frustum\r\n * @param {Number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given bounds.\r\n * Passing null/undefined/no value for far will generate infinite projection matrix.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} fovy Vertical field of view in radians\r\n * @param {number} aspect Aspect ratio. typically viewport width/height\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum, can be null or Infinity\r\n * @returns {mat4} out\r\n */\n\nexport function perspective(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given field of view.\r\n * This is primarily useful for generating projection matrices to be used\r\n * with the still experiemental WebVR API.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nexport function ortho(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {vec3} eye Position of the viewer\r\n * @param {vec3} center Point the viewer is looking at\r\n * @param {vec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a matrix that makes something look at something else.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {vec3} eye Position of the viewer\r\n * @param {vec3} center Point the viewer is looking at\r\n * @param {vec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n;\n/**\r\n * Returns a string representation of a mat4\r\n *\r\n * @param {mat4} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nexport function str(a) {\n  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\n}\n/**\r\n * Returns Frobenius norm of a mat4\r\n *\r\n * @param {mat4} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\r\n * Adds two mat4's\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat4} out\r\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\r\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat4} out the receiving vector\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat4} out\r\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat4} a The first matrix.\r\n * @param {mat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat4} a The first matrix.\r\n * @param {mat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\r\n * Alias for {@link mat4.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link mat4.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n/**\r\n * Quaternion\r\n * @module quat\r\n */\n\n/**\r\n * Creates a new identity quat\r\n *\r\n * @returns {quat} a new quaternion\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Set a quat to the identity quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Sets a quat from the given angle and rotation axis,\r\n * then returns it.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {vec3} axis the axis around which to rotate\r\n * @param {Number} rad the angle in radians\r\n * @returns {quat} out\r\n **/\n\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\r\n * Gets the rotation axis and angle for a given\r\n *  quaternion. If a quaternion is created with\r\n *  setAxisAngle, this method will return the same\r\n *  values as providied in the original parameter list\r\n *  OR functionally equivalent values.\r\n * Example: The quaternion formed by axis [0, 0, 1] and\r\n *  angle -90 is the same as the quaternion formed by\r\n *  [0, 0, 1] and 270. This method favors the latter.\r\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\r\n * @param  {quat} q     Quaternion to be decomposed\r\n * @return {Number}     Angle, in radians, of the rotation\r\n */\n\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\r\n * Gets the angular distance between two unit quaternions\r\n *\r\n * @param  {quat} a     Origin unit quaternion \r\n * @param  {quat} b     Destination unit quaternion\r\n * @return {Number}     Angle, in radians, between the two quaternions\r\n */\n\nexport function getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n/**\r\n * Multiplies two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n */\n\nexport function multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the X axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Y axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Z axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\r\n * Calculates the W component of a quat from the X, Y, and Z components.\r\n * Assumes that quaternion is 1 unit in length.\r\n * Any existing W component will be ignored.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate W component of\r\n * @returns {quat} out\r\n */\n\nexport function calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\r\n * Calculate the exponential of a unit quaternion.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate the exponential of\r\n * @returns {quat} out\r\n */\n\nexport function exp(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n/**\r\n * Calculate the natural logarithm of a unit quaternion.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate the exponential of\r\n * @returns {quat} out\r\n */\n\nexport function ln(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n/**\r\n * Calculate the scalar power of a unit quaternion.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate the exponential of\r\n * @param {Number} b amount to scale the quaternion by\r\n * @returns {quat} out\r\n */\n\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n/**\r\n * Performs a spherical linear interpolation between two quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\r\n * Generates a random unit quaternion\r\n * \r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\r\n * Calculates the inverse of a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate inverse of\r\n * @returns {quat} out\r\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\r\n * Calculates the conjugate of a quat\r\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate conjugate of\r\n * @returns {quat} out\r\n */\n\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a quaternion from the given 3x3 rotation matrix.\r\n *\r\n * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n * to renormalize the quaternion yourself where necessary.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {mat3} m rotation matrix\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\r\n * Creates a quaternion from the given euler angle x, y, z.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {x} Angle to rotate around X axis in degrees.\r\n * @param {y} Angle to rotate around Y axis in degrees.\r\n * @param {z} Angle to rotate around Z axis in degrees.\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport function fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\r\n * Returns a string representation of a quatenion\r\n *\r\n * @param {quat} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {quat} a quaternion to clone\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\n\nexport var clone = vec4.clone;\n/**\r\n * Creates a new quat initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\n\nexport var fromValues = vec4.fromValues;\n/**\r\n * Copy the values from one quat to another\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the source quaternion\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var copy = vec4.copy;\n/**\r\n * Set the components of a quat to the given values\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var set = vec4.set;\n/**\r\n * Adds two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var add = vec4.add;\n/**\r\n * Alias for {@link quat.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Scales a quat by a scalar number\r\n *\r\n * @param {quat} out the receiving vector\r\n * @param {quat} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var scale = vec4.scale;\n/**\r\n * Calculates the dot product of two quat's\r\n *\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\n\nexport var dot = vec4.dot;\n/**\r\n * Performs a linear interpolation between two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var lerp = vec4.lerp;\n/**\r\n * Calculates the length of a quat\r\n *\r\n * @param {quat} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport var length = vec4.length;\n/**\r\n * Alias for {@link quat.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Calculates the squared length of a quat\r\n *\r\n * @param {quat} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\n\nexport var squaredLength = vec4.squaredLength;\n/**\r\n * Alias for {@link quat.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Normalize a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quaternion to normalize\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var normalize = vec4.normalize;\n/**\r\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {quat} a The first quaternion.\r\n * @param {quat} b The second quaternion.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport var exactEquals = vec4.exactEquals;\n/**\r\n * Returns whether or not the quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {quat} a The first vector.\r\n * @param {quat} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport var equals = vec4.equals;\n/**\r\n * Sets a quaternion to represent the shortest rotation from one\r\n * vector to another.\r\n *\r\n * Both vectors are assumed to be unit length.\r\n *\r\n * @param {quat} out the receiving quaternion.\r\n * @param {vec3} a the initial vector\r\n * @param {vec3} b the destination vector\r\n * @returns {quat} out\r\n */\n\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\r\n * Performs a spherical linear interpolation with two control points\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {quat} c the third operand\r\n * @param {quat} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\r\n * Sets the specified quaternion with values corresponding to the given\r\n * axes. Each axis is a vec3 and is expected to be unit length and\r\n * perpendicular to all other specified axes.\r\n *\r\n * @param {vec3} view  the vector representing the viewing direction\r\n * @param {vec3} right the vector representing the local \"right\" direction\r\n * @param {vec3} up    the vector representing the local \"up\" direction\r\n * @returns {quat} out\r\n */\n\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();","import * as glMatrix from \"./common.js\";\nimport * as quat from \"./quat.js\";\nimport * as mat4 from \"./mat4.js\";\n/**\r\n * Dual Quaternion<br>\r\n * Format: [real, dual]<br>\r\n * Quaternion format: XYZW<br>\r\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\r\n * @module quat2\r\n */\n\n/**\r\n * Creates a new identity dual quat\r\n *\r\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\r\n */\n\nexport function create() {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    dq[0] = 0;\n    dq[1] = 0;\n    dq[2] = 0;\n    dq[4] = 0;\n    dq[5] = 0;\n    dq[6] = 0;\n    dq[7] = 0;\n  }\n\n  dq[3] = 1;\n  return dq;\n}\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {quat2} a dual quaternion to clone\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\nexport function clone(a) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = a[0];\n  dq[1] = a[1];\n  dq[2] = a[2];\n  dq[3] = a[3];\n  dq[4] = a[4];\n  dq[5] = a[5];\n  dq[6] = a[6];\n  dq[7] = a[7];\n  return dq;\n}\n/**\r\n * Creates a new dual quat initialized with the given values\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\nexport function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  dq[4] = x2;\n  dq[5] = y2;\n  dq[6] = z2;\n  dq[7] = w2;\n  return dq;\n}\n/**\r\n * Creates a new dual quat from the given values (quat and translation)\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component (translation)\r\n * @param {Number} y2 Y component (translation)\r\n * @param {Number} z2 Z component (translation)\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\nexport function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  var ax = x2 * 0.5,\n      ay = y2 * 0.5,\n      az = z2 * 0.5;\n  dq[4] = ax * w1 + ay * z1 - az * y1;\n  dq[5] = ay * w1 + az * x1 - ax * z1;\n  dq[6] = az * w1 + ax * y1 - ay * x1;\n  dq[7] = -ax * x1 - ay * y1 - az * z1;\n  return dq;\n}\n/**\r\n * Creates a dual quat from a quaternion and a translation\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {quat} q a normalized quaternion\r\n * @param {vec3} t tranlation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\nexport function fromRotationTranslation(out, q, t) {\n  var ax = t[0] * 0.5,\n      ay = t[1] * 0.5,\n      az = t[2] * 0.5,\n      bx = q[0],\n      by = q[1],\n      bz = q[2],\n      bw = q[3];\n  out[0] = bx;\n  out[1] = by;\n  out[2] = bz;\n  out[3] = bw;\n  out[4] = ax * bw + ay * bz - az * by;\n  out[5] = ay * bw + az * bx - ax * bz;\n  out[6] = az * bw + ax * by - ay * bx;\n  out[7] = -ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Creates a dual quat from a translation\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {vec3} t translation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\nexport function fromTranslation(out, t) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = t[0] * 0.5;\n  out[5] = t[1] * 0.5;\n  out[6] = t[2] * 0.5;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Creates a dual quat from a quaternion\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {quat} q the quaternion\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\nexport function fromRotation(out, q) {\n  out[0] = q[0];\n  out[1] = q[1];\n  out[2] = q[2];\n  out[3] = q[3];\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Creates a new dual quat from a matrix (4x4)\r\n *\r\n * @param {quat2} out the dual quaternion\r\n * @param {mat4} a the matrix\r\n * @returns {quat2} dual quat receiving operation result\r\n * @function\r\n */\n\nexport function fromMat4(out, a) {\n  //TODO Optimize this\n  var outer = quat.create();\n  mat4.getRotation(outer, a);\n  var t = new glMatrix.ARRAY_TYPE(3);\n  mat4.getTranslation(t, a);\n  fromRotationTranslation(out, outer, t);\n  return out;\n}\n/**\r\n * Copy the values from one dual quat to another\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the source dual quaternion\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  return out;\n}\n/**\r\n * Set a dual quat to the identity dual quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @returns {quat2} out\r\n */\n\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Set the components of a dual quat to the given values\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {\n  out[0] = x1;\n  out[1] = y1;\n  out[2] = z1;\n  out[3] = w1;\n  out[4] = x2;\n  out[5] = y2;\n  out[6] = z2;\n  out[7] = w2;\n  return out;\n}\n/**\r\n * Gets the real part of a dual quat\r\n * @param  {quat} out real part\r\n * @param  {quat2} a Dual Quaternion\r\n * @return {quat} real part\r\n */\n\nexport var getReal = quat.copy;\n/**\r\n * Gets the dual part of a dual quat\r\n * @param  {quat} out dual part\r\n * @param  {quat2} a Dual Quaternion\r\n * @return {quat} dual part\r\n */\n\nexport function getDual(out, a) {\n  out[0] = a[4];\n  out[1] = a[5];\n  out[2] = a[6];\n  out[3] = a[7];\n  return out;\n}\n/**\r\n * Set the real component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat} q a quaternion representing the real part\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport var setReal = quat.copy;\n/**\r\n * Set the dual component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat} q a quaternion representing the dual part\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function setDual(out, q) {\n  out[4] = q[0];\n  out[5] = q[1];\n  out[6] = q[2];\n  out[7] = q[3];\n  return out;\n}\n/**\r\n * Gets the translation of a normalized dual quat\r\n * @param  {vec3} out translation\r\n * @param  {quat2} a Dual Quaternion to be decomposed\r\n * @return {vec3} translation\r\n */\n\nexport function getTranslation(out, a) {\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3];\n  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  return out;\n}\n/**\r\n * Translates a dual quat by the given vector\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to translate\r\n * @param {vec3} v vector to translate by\r\n * @returns {quat2} out\r\n */\n\nexport function translate(out, a, v) {\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3],\n      bx1 = v[0] * 0.5,\n      by1 = v[1] * 0.5,\n      bz1 = v[2] * 0.5,\n      ax2 = a[4],\n      ay2 = a[5],\n      az2 = a[6],\n      aw2 = a[7];\n  out[0] = ax1;\n  out[1] = ay1;\n  out[2] = az1;\n  out[3] = aw1;\n  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\n  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\n  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\n  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the X axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\nexport function rotateX(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateX(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the Y axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\nexport function rotateY(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateY(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the Z axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\nexport function rotateZ(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateZ(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat by a given quaternion (a * q)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {quat} q quaternion to rotate by\r\n * @returns {quat2} out\r\n */\n\nexport function rotateByQuatAppend(out, a, q) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  out[0] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[1] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[2] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[3] = aw * qw - ax * qx - ay * qy - az * qz;\n  ax = a[4];\n  ay = a[5];\n  az = a[6];\n  aw = a[7];\n  out[4] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[5] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[6] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[7] = aw * qw - ax * qx - ay * qy - az * qz;\n  return out;\n}\n/**\r\n * Rotates a dual quat by a given quaternion (q * a)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat} q quaternion to rotate by\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @returns {quat2} out\r\n */\n\nexport function rotateByQuatPrepend(out, q, a) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      bx = a[0],\n      by = a[1],\n      bz = a[2],\n      bw = a[3];\n  out[0] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[1] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[2] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[3] = qw * bw - qx * bx - qy * by - qz * bz;\n  bx = a[4];\n  by = a[5];\n  bz = a[6];\n  bw = a[7];\n  out[4] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[5] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[6] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[7] = qw * bw - qx * bx - qy * by - qz * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around a given axis. Does the normalisation automatically\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {vec3} axis the axis to rotate around\r\n * @param {Number} rad how far the rotation should be\r\n * @returns {quat2} out\r\n */\n\nexport function rotateAroundAxis(out, a, axis, rad) {\n  //Special case for rad = 0\n  if (Math.abs(rad) < glMatrix.EPSILON) {\n    return copy(out, a);\n  }\n\n  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  var bx = s * axis[0] / axisLength;\n  var by = s * axis[1] / axisLength;\n  var bz = s * axis[2] / axisLength;\n  var bw = Math.cos(rad);\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3];\n  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  out[4] = ax * bw + aw * bx + ay * bz - az * by;\n  out[5] = ay * bw + aw * by + az * bx - ax * bz;\n  out[6] = az * bw + aw * bz + ax * by - ay * bx;\n  out[7] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Adds two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  return out;\n}\n/**\r\n * Multiplies two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {quat2} out\r\n */\n\nexport function multiply(out, a, b) {\n  var ax0 = a[0],\n      ay0 = a[1],\n      az0 = a[2],\n      aw0 = a[3],\n      bx1 = b[4],\n      by1 = b[5],\n      bz1 = b[6],\n      bw1 = b[7],\n      ax1 = a[4],\n      ay1 = a[5],\n      az1 = a[6],\n      aw1 = a[7],\n      bx0 = b[0],\n      by0 = b[1],\n      bz0 = b[2],\n      bw0 = b[3];\n  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\n  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\n  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\n  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\n  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\n  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\n  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\n  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\n  return out;\n}\n/**\r\n * Alias for {@link quat2.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Scales a dual quat by a scalar number\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {quat2} a the dual quat to scale\r\n * @param {Number} b amount to scale the dual quat by\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  return out;\n}\n/**\r\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\r\n *\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\n\nexport var dot = quat.dot;\n/**\r\n * Performs a linear interpolation between two dual quats's\r\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat2} out\r\n */\n\nexport function lerp(out, a, b, t) {\n  var mt = 1 - t;\n  if (dot(a, b) < 0) t = -t;\n  out[0] = a[0] * mt + b[0] * t;\n  out[1] = a[1] * mt + b[1] * t;\n  out[2] = a[2] * mt + b[2] * t;\n  out[3] = a[3] * mt + b[3] * t;\n  out[4] = a[4] * mt + b[4] * t;\n  out[5] = a[5] * mt + b[5] * t;\n  out[6] = a[6] * mt + b[6] * t;\n  out[7] = a[7] * mt + b[7] * t;\n  return out;\n}\n/**\r\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a dual quat to calculate inverse of\r\n * @returns {quat2} out\r\n */\n\nexport function invert(out, a) {\n  var sqlen = squaredLength(a);\n  out[0] = -a[0] / sqlen;\n  out[1] = -a[1] / sqlen;\n  out[2] = -a[2] / sqlen;\n  out[3] = a[3] / sqlen;\n  out[4] = -a[4] / sqlen;\n  out[5] = -a[5] / sqlen;\n  out[6] = -a[6] / sqlen;\n  out[7] = a[7] / sqlen;\n  return out;\n}\n/**\r\n * Calculates the conjugate of a dual quat\r\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat2} a quat to calculate conjugate of\r\n * @returns {quat2} out\r\n */\n\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  out[4] = -a[4];\n  out[5] = -a[5];\n  out[6] = -a[6];\n  out[7] = a[7];\n  return out;\n}\n/**\r\n * Calculates the length of a dual quat\r\n *\r\n * @param {quat2} a dual quat to calculate length of\r\n * @returns {Number} length of a\r\n * @function\r\n */\n\nexport var length = quat.length;\n/**\r\n * Alias for {@link quat2.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Calculates the squared length of a dual quat\r\n *\r\n * @param {quat2} a dual quat to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\n\nexport var squaredLength = quat.squaredLength;\n/**\r\n * Alias for {@link quat2.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Normalize a dual quat\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a dual quaternion to normalize\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function normalize(out, a) {\n  var magnitude = squaredLength(a);\n\n  if (magnitude > 0) {\n    magnitude = Math.sqrt(magnitude);\n    var a0 = a[0] / magnitude;\n    var a1 = a[1] / magnitude;\n    var a2 = a[2] / magnitude;\n    var a3 = a[3] / magnitude;\n    var b0 = a[4];\n    var b1 = a[5];\n    var b2 = a[6];\n    var b3 = a[7];\n    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n    out[4] = (b0 - a0 * a_dot_b) / magnitude;\n    out[5] = (b1 - a1 * a_dot_b) / magnitude;\n    out[6] = (b2 - a2 * a_dot_b) / magnitude;\n    out[7] = (b3 - a3 * a_dot_b) / magnitude;\n  }\n\n  return out;\n}\n/**\r\n * Returns a string representation of a dual quatenion\r\n *\r\n * @param {quat2} a dual quaternion to represent as a string\r\n * @returns {String} string representation of the dual quat\r\n */\n\nexport function str(a) {\n  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';\n}\n/**\r\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {quat2} a the first dual quaternion.\r\n * @param {quat2} b the second dual quaternion.\r\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];\n}\n/**\r\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {quat2} a the first dual quat.\r\n * @param {quat2} b the second dual quat.\r\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));\n}","import * as glMatrix from \"./common.js\";\n/**\r\n * 2 Dimensional Vector\r\n * @module vec2\r\n */\n\n/**\r\n * Creates a new, empty vec2\r\n *\r\n * @returns {vec2} a new 2D vector\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with values from an existing vector\r\n *\r\n * @param {vec2} a vector to clone\r\n * @returns {vec2} a new 2D vector\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} a new 2D vector\r\n */\n\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the source vector\r\n * @returns {vec2} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\n\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Adds two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\r\n * Multiplies two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\r\n * Divides two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to ceil\r\n * @returns {vec2} out\r\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to floor\r\n * @returns {vec2} out\r\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to round\r\n * @returns {vec2} out\r\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\r\n * Adds two vec2's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec2} out\r\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport function length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nexport function squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to negate\r\n * @returns {vec2} out\r\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to invert\r\n * @returns {vec2} out\r\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\n\nexport function normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\r\n * Computes the cross product of two vec2's\r\n * Note that the cross product must by definition produce a 3D vector\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec2} out\r\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec2} out\r\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly '0'\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\r\n * Rotate a 2D vector\r\n * @param {vec2} out The receiving vec2\r\n * @param {vec2} a The vec2 point to rotate\r\n * @param {vec2} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec2} out\r\n */\n\nexport function rotate(out, a, b, c) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(c),\n      cosC = Math.cos(c); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\r\n * Get the angle between two 2D vectors\r\n * @param {vec2} a The first operand\r\n * @param {vec2} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nexport function angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1];\n  var len1 = x1 * x1 + y1 * y1;\n\n  if (len1 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len1 = 1 / Math.sqrt(len1);\n  }\n\n  var len2 = x2 * x2 + y2 * y2;\n\n  if (len2 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len2 = 1 / Math.sqrt(len2);\n  }\n\n  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;\n\n  if (cosine > 1.0) {\n    return 0;\n  } else if (cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n/**\r\n * Set the components of a vec2 to zero\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @returns {vec2} out\r\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec2} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return 'vec2(' + a[0] + ', ' + a[1] + ')';\n}\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\r\n * Alias for {@link vec2.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Alias for {@link vec2.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;\n/**\r\n * Alias for {@link vec2.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link vec2.divide}\r\n * @function\r\n */\n\nexport var div = divide;\n/**\r\n * Alias for {@link vec2.distance}\r\n * @function\r\n */\n\nexport var dist = distance;\n/**\r\n * Alias for {@link vec2.squaredDistance}\r\n * @function\r\n */\n\nexport var sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec2.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec2s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\n\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {vec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {vec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the source vector\r\n * @returns {vec3} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Adds two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\r\n * Multiplies two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\r\n * Divides two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to floor\r\n * @returns {vec3} out\r\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to round\r\n * @returns {vec3} out\r\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\r\n * Adds two vec3's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {vec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to negate\r\n * @returns {vec3} out\r\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to invert\r\n * @returns {vec3} out\r\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\r\n * Computes the cross product of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\r\n * Performs a hermite interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {vec3} c the third operand\r\n * @param {vec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Performs a bezier interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {vec3} c the third operand\r\n * @param {vec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {mat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {quat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\n\nexport function rotateX(out, a, b, c) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\n\nexport function rotateY(out, a, b, c) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\n\nexport function rotateZ(out, a, b, c) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {vec3} a The first operand\r\n * @param {vec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nexport function angle(a, b) {\n  var tempA = fromValues(a[0], a[1], a[2]);\n  var tempB = fromValues(b[0], b[1], b[2]);\n  normalize(tempA, tempA);\n  normalize(tempB, tempB);\n  var cosine = dot(tempA, tempB);\n\n  if (cosine > 1.0) {\n    return 0;\n  } else if (cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n/**\r\n * Set the components of a vec3 to zero\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @returns {vec3} out\r\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec3} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec3} a The first vector.\r\n * @param {vec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec3} a The first vector.\r\n * @param {vec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\r\n * Alias for {@link vec3.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;\n/**\r\n * Alias for {@link vec3.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link vec3.divide}\r\n * @function\r\n */\n\nexport var div = divide;\n/**\r\n * Alias for {@link vec3.distance}\r\n * @function\r\n */\n\nexport var dist = distance;\n/**\r\n * Alias for {@link vec3.squaredDistance}\r\n * @function\r\n */\n\nexport var sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Alias for {@link vec3.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\r\n * 4 Dimensional Vector\r\n * @module vec4\r\n */\n\n/**\r\n * Creates a new, empty vec4\r\n *\r\n * @returns {vec4} a new 4D vector\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with values from an existing vector\r\n *\r\n * @param {vec4} a vector to clone\r\n * @returns {vec4} a new 4D vector\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} a new 4D vector\r\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Copy the values from one vec4 to another\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the source vector\r\n * @returns {vec4} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to the given values\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} out\r\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Adds two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Multiplies two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\r\n * Divides two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to ceil\r\n * @returns {vec4} out\r\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to floor\r\n * @returns {vec4} out\r\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to round\r\n * @returns {vec4} out\r\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\r\n * Scales a vec4 by a scalar number\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec4} out\r\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two vec4's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec4} out\r\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Calculates the length of a vec4\r\n *\r\n * @param {vec4} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared length of a vec4\r\n *\r\n * @param {vec4} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Negates the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to negate\r\n * @returns {vec4} out\r\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to invert\r\n * @returns {vec4} out\r\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\r\n * Normalize a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to normalize\r\n * @returns {vec4} out\r\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\r\n * Returns the cross-product of three vectors in a 4-dimensional space\r\n *\r\n * @param {vec4} result the receiving vector\r\n * @param {vec4} U the first vector\r\n * @param {vec4} V the second vector\r\n * @param {vec4} W the third vector\r\n * @returns {vec4} result\r\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n;\n/**\r\n * Performs a linear interpolation between two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec4} out\r\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec4} out\r\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a mat4.\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec4} out\r\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a quat\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to transform\r\n * @param {quat} q quaternion to transform with\r\n * @returns {vec4} out\r\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to zero\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @returns {vec4} out\r\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec4} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec4} a The first vector.\r\n * @param {vec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec4} a The first vector.\r\n * @param {vec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Alias for {@link vec4.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;\n/**\r\n * Alias for {@link vec4.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link vec4.divide}\r\n * @function\r\n */\n\nexport var div = divide;\n/**\r\n * Alias for {@link vec4.distance}\r\n * @function\r\n */\n\nexport var dist = distance;\n/**\r\n * Alias for {@link vec4.squaredDistance}\r\n * @function\r\n */\n\nexport var sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec4.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Alias for {@link vec4.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec4s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();","class Rectangle {\n    /**\n     * Creates an instance of Rectangle.\n     *\n     * @param {number} [width=0]\n     * @param {number} [height=0]\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {boolean} [rot=false]\n     * @memberof Rectangle\n     */\n    constructor(width = 0, height = 0, x = 0, y = 0, rot = false) {\n        /**\n         * Oversized tag on rectangle which is bigger than packer itself.\n         *\n         * @type {boolean}\n         * @memberof Rectangle\n         */\n        this.oversized = false;\n        this._rot = false;\n        this._dirty = 0;\n        this._width = width;\n        this._height = height;\n        this._x = x;\n        this._y = y;\n        this._data = {};\n        this._rot = rot;\n    }\n    /**\n     * Test if two given rectangle collide each other\n     *\n     * @static\n     * @param {Rectangle} first\n     * @param {Rectangle} second\n     * @returns\n     * @memberof Rectangle\n     */\n    static Collide(first, second) { return first.collide(second); }\n    /**\n     * Test if the first rectangle contains the second one\n     *\n     * @static\n     * @param {Rectangle} first\n     * @param {Rectangle} second\n     * @returns\n     * @memberof Rectangle\n     */\n    static Contain(first, second) { return first.contain(second); }\n    /**\n     * Get the area (w * h) of the rectangle\n     *\n     * @returns {number}\n     * @memberof Rectangle\n     */\n    area() { return this.width * this.height; }\n    /**\n     * Test if the given rectangle collide with this rectangle.\n     *\n     * @param {Rectangle} rect\n     * @returns {boolean}\n     * @memberof Rectangle\n     */\n    collide(rect) {\n        return (rect.x < this.x + this.width &&\n            rect.x + rect.width > this.x &&\n            rect.y < this.y + this.height &&\n            rect.y + rect.height > this.y);\n    }\n    /**\n     * Test if this rectangle contains the given rectangle.\n     *\n     * @param {Rectangle} rect\n     * @returns {boolean}\n     * @memberof Rectangle\n     */\n    contain(rect) {\n        return (rect.x >= this.x && rect.y >= this.y &&\n            rect.x + rect.width <= this.x + this.width && rect.y + rect.height <= this.y + this.height);\n    }\n    get width() { return this._width; }\n    set width(value) {\n        if (value === this._width)\n            return;\n        this._width = value;\n        this._dirty++;\n    }\n    get height() { return this._height; }\n    set height(value) {\n        if (value === this._height)\n            return;\n        this._height = value;\n        this._dirty++;\n    }\n    get x() { return this._x; }\n    set x(value) {\n        if (value === this._x)\n            return;\n        this._x = value;\n        this._dirty++;\n    }\n    get y() { return this._y; }\n    set y(value) {\n        if (value === this._y)\n            return;\n        this._y = value;\n        this._dirty++;\n    }\n    /**\n     * If the rectangle is rotated\n     *\n     * @type {boolean}\n     * @memberof Rectangle\n     */\n    get rot() { return this._rot; }\n    /**\n     * Set the rotate tag of the rectangle.\n     *\n     * note: after `rot` is set, `width/height` of this rectangle is swaped.\n     *\n     * @memberof Rectangle\n     */\n    set rot(value) {\n        if (this._rot !== value) {\n            const tmp = this.width;\n            this.width = this.height;\n            this.height = tmp;\n            this._rot = value;\n            this._dirty++;\n        }\n    }\n    get data() { return this._data; }\n    set data(value) {\n        if (value === this._data)\n            return;\n        this._data = value;\n        this._dirty++;\n    }\n    get dirty() { return this._dirty > 0; }\n    setDirty(value = true) { this._dirty = value ? this._dirty + 1 : 0; }\n}\n\nclass Bin {\n    constructor() {\n        this._dirty = 0;\n    }\n    get dirty() { return this._dirty > 0 || this.rects.some(rect => rect.dirty); }\n    /**\n     * Set bin dirty status\n     *\n     * @memberof Bin\n     */\n    setDirty(value = true) {\n        this._dirty = value ? this._dirty + 1 : 0;\n        if (!value) {\n            for (let rect of this.rects) {\n                if (rect.setDirty)\n                    rect.setDirty(false);\n            }\n        }\n    }\n}\n\nclass MaxRectsBin extends Bin {\n    constructor(maxWidth = EDGE_MAX_VALUE, maxHeight = EDGE_MAX_VALUE, padding = 0, options = { smart: true, pot: true, square: true, allowRotation: false, tag: false, border: 0, logic: PACKING_LOGIC.MAX_AREA }) {\n        super();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this.padding = padding;\n        this.options = options;\n        this.freeRects = [];\n        this.rects = [];\n        this.verticalExpand = false;\n        this.width = this.options.smart ? 0 : maxWidth;\n        this.height = this.options.smart ? 0 : maxHeight;\n        this.border = this.options.border ? this.options.border : 0;\n        this.freeRects.push(new Rectangle(this.maxWidth + this.padding - this.border * 2, this.maxHeight + this.padding - this.border * 2, this.border, this.border));\n        this.stage = new Rectangle(this.width, this.height);\n    }\n    add(...args) {\n        let data;\n        let rect;\n        if (args.length === 1) {\n            if (typeof args[0] !== 'object')\n                throw new Error(\"MacrectsBin.add(): Wrong parameters\");\n            rect = args[0];\n            // Check if rect.tag match bin.tag, if bin.tag not defined, it will accept any rect\n            let tag = (rect.data && rect.data.tag) ? rect.data.tag : rect.tag ? rect.tag : undefined;\n            if (this.options.tag && this.tag !== tag)\n                return undefined;\n        }\n        else {\n            data = args.length > 2 ? args[2] : null;\n            // Check if data.tag match bin.tag, if bin.tag not defined, it will accept any rect\n            if (this.options.tag) {\n                if (data && this.tag !== data.tag)\n                    return undefined;\n                if (!data && this.tag)\n                    return undefined;\n            }\n            rect = new Rectangle(args[0], args[1]);\n            rect.data = data;\n            rect.setDirty(false);\n        }\n        const result = this.place(rect);\n        if (result)\n            this.rects.push(result);\n        return result;\n    }\n    repack() {\n        let unpacked = [];\n        this.reset();\n        // re-sort rects from big to small\n        this.rects.sort((a, b) => {\n            const result = Math.max(b.width, b.height) - Math.max(a.width, a.height);\n            if (result === 0 && a.hash && b.hash) {\n                return a.hash > b.hash ? -1 : 1;\n            }\n            else\n                return result;\n        });\n        for (let rect of this.rects) {\n            if (!this.place(rect)) {\n                unpacked.push(rect);\n            }\n        }\n        for (let rect of unpacked)\n            this.rects.splice(this.rects.indexOf(rect), 1);\n        return unpacked.length > 0 ? unpacked : undefined;\n    }\n    reset(deepReset = false, resetOption = false) {\n        if (deepReset) {\n            if (this.data)\n                delete this.data;\n            if (this.tag)\n                delete this.tag;\n            this.rects = [];\n            if (resetOption) {\n                this.options = {\n                    smart: true,\n                    pot: true,\n                    square: true,\n                    allowRotation: false,\n                    tag: false,\n                    border: 0\n                };\n            }\n        }\n        this.width = this.options.smart ? 0 : this.maxWidth;\n        this.height = this.options.smart ? 0 : this.maxHeight;\n        this.border = this.options.border ? this.options.border : 0;\n        this.freeRects = [new Rectangle(this.maxWidth + this.padding - this.border * 2, this.maxHeight + this.padding - this.border * 2, this.border, this.border)];\n        this.stage = new Rectangle(this.width, this.height);\n        this._dirty = 0;\n    }\n    place(rect) {\n        // recheck if tag matched\n        let tag = (rect.data && rect.data.tag) ? rect.data.tag : rect.tag ? rect.tag : undefined;\n        if (this.options.tag && this.tag !== tag)\n            return undefined;\n        let node = this.findNode(rect.width + this.padding, rect.height + this.padding);\n        if (node) {\n            this.updateBinSize(node);\n            let numRectToProcess = this.freeRects.length;\n            let i = 0;\n            while (i < numRectToProcess) {\n                if (this.splitNode(this.freeRects[i], node)) {\n                    this.freeRects.splice(i, 1);\n                    numRectToProcess--;\n                    i--;\n                }\n                i++;\n            }\n            this.pruneFreeList();\n            this.verticalExpand = this.width > this.height ? true : false;\n            rect.x = node.x;\n            rect.y = node.y;\n            rect.rot = node.rot ? !rect.rot : rect.rot;\n            this._dirty++;\n            return rect;\n        }\n        else if (!this.verticalExpand) {\n            if (this.updateBinSize(new Rectangle(rect.width + this.padding, rect.height + this.padding, this.width + this.padding - this.border, this.border)) || this.updateBinSize(new Rectangle(rect.width + this.padding, rect.height + this.padding, this.border, this.height + this.padding - this.border))) {\n                return this.place(rect);\n            }\n        }\n        else {\n            if (this.updateBinSize(new Rectangle(rect.width + this.padding, rect.height + this.padding, this.border, this.height + this.padding - this.border)) || this.updateBinSize(new Rectangle(rect.width + this.padding, rect.height + this.padding, this.width + this.padding - this.border, this.border))) {\n                return this.place(rect);\n            }\n        }\n        return undefined;\n    }\n    findNode(width, height) {\n        let score = Number.MAX_VALUE;\n        let areaFit;\n        let r;\n        let bestNode;\n        for (let i in this.freeRects) {\n            r = this.freeRects[i];\n            if (r.width >= width && r.height >= height) {\n                areaFit = (this.options.logic === PACKING_LOGIC.MAX_AREA) ?\n                    r.width * r.height - width * height :\n                    Math.min(r.width - width, r.height - height);\n                if (areaFit < score) {\n                    bestNode = new Rectangle(width, height, r.x, r.y);\n                    score = areaFit;\n                }\n            }\n            if (!this.options.allowRotation)\n                continue;\n            // Continue to test 90-degree rotated rectangle\n            if (r.width >= height && r.height >= width) {\n                areaFit = (this.options.logic === PACKING_LOGIC.MAX_AREA) ?\n                    r.width * r.height - height * width :\n                    Math.min(r.height - width, r.width - height);\n                if (areaFit < score) {\n                    bestNode = new Rectangle(height, width, r.x, r.y, true); // Rotated node\n                    score = areaFit;\n                }\n            }\n        }\n        return bestNode;\n    }\n    splitNode(freeRect, usedNode) {\n        // Test if usedNode intersect with freeRect\n        if (!freeRect.collide(usedNode))\n            return false;\n        // Do vertical split\n        if (usedNode.x < freeRect.x + freeRect.width && usedNode.x + usedNode.width > freeRect.x) {\n            // New node at the top side of the used node\n            if (usedNode.y > freeRect.y && usedNode.y < freeRect.y + freeRect.height) {\n                let newNode = new Rectangle(freeRect.width, usedNode.y - freeRect.y, freeRect.x, freeRect.y);\n                this.freeRects.push(newNode);\n            }\n            // New node at the bottom side of the used node\n            if (usedNode.y + usedNode.height < freeRect.y + freeRect.height) {\n                let newNode = new Rectangle(freeRect.width, freeRect.y + freeRect.height - (usedNode.y + usedNode.height), freeRect.x, usedNode.y + usedNode.height);\n                this.freeRects.push(newNode);\n            }\n        }\n        // Do Horizontal split\n        if (usedNode.y < freeRect.y + freeRect.height &&\n            usedNode.y + usedNode.height > freeRect.y) {\n            // New node at the left side of the used node.\n            if (usedNode.x > freeRect.x && usedNode.x < freeRect.x + freeRect.width) {\n                let newNode = new Rectangle(usedNode.x - freeRect.x, freeRect.height, freeRect.x, freeRect.y);\n                this.freeRects.push(newNode);\n            }\n            // New node at the right side of the used node.\n            if (usedNode.x + usedNode.width < freeRect.x + freeRect.width) {\n                let newNode = new Rectangle(freeRect.x + freeRect.width - (usedNode.x + usedNode.width), freeRect.height, usedNode.x + usedNode.width, freeRect.y);\n                this.freeRects.push(newNode);\n            }\n        }\n        return true;\n    }\n    pruneFreeList() {\n        // Go through each pair of freeRects and remove any rects that is redundant\n        let i = 0;\n        let j = 0;\n        let len = this.freeRects.length;\n        while (i < len) {\n            j = i + 1;\n            let tmpRect1 = this.freeRects[i];\n            while (j < len) {\n                let tmpRect2 = this.freeRects[j];\n                if (tmpRect2.contain(tmpRect1)) {\n                    this.freeRects.splice(i, 1);\n                    i--;\n                    len--;\n                    break;\n                }\n                if (tmpRect1.contain(tmpRect2)) {\n                    this.freeRects.splice(j, 1);\n                    j--;\n                    len--;\n                }\n                j++;\n            }\n            i++;\n        }\n    }\n    updateBinSize(node) {\n        if (!this.options.smart)\n            return false;\n        if (this.stage.contain(node))\n            return false;\n        let tmpWidth = Math.max(this.width, node.x + node.width - this.padding + this.border);\n        let tmpHeight = Math.max(this.height, node.y + node.height - this.padding + this.border);\n        if (this.options.allowRotation) {\n            // do extra test on rotated node whether it's a better choice\n            const rotWidth = Math.max(this.width, node.x + node.height - this.padding + this.border);\n            const rotHeight = Math.max(this.height, node.y + node.width - this.padding + this.border);\n            if (rotWidth * rotHeight < tmpWidth * tmpHeight) {\n                tmpWidth = rotWidth;\n                tmpHeight = rotHeight;\n            }\n        }\n        if (this.options.pot) {\n            tmpWidth = Math.pow(2, Math.ceil(Math.log(tmpWidth) * Math.LOG2E));\n            tmpHeight = Math.pow(2, Math.ceil(Math.log(tmpHeight) * Math.LOG2E));\n        }\n        if (this.options.square) {\n            tmpWidth = tmpHeight = Math.max(tmpWidth, tmpHeight);\n        }\n        if (tmpWidth > this.maxWidth + this.padding || tmpHeight > this.maxHeight + this.padding) {\n            return false;\n        }\n        this.expandFreeRects(tmpWidth + this.padding, tmpHeight + this.padding);\n        this.width = this.stage.width = tmpWidth;\n        this.height = this.stage.height = tmpHeight;\n        return true;\n    }\n    expandFreeRects(width, height) {\n        this.freeRects.forEach((freeRect, index) => {\n            if (freeRect.x + freeRect.width >= Math.min(this.width + this.padding - this.border, width)) {\n                freeRect.width = width - freeRect.x - this.border;\n            }\n            if (freeRect.y + freeRect.height >= Math.min(this.height + this.padding - this.border, height)) {\n                freeRect.height = height - freeRect.y - this.border;\n            }\n        }, this);\n        this.freeRects.push(new Rectangle(width - this.width - this.padding, height - this.border * 2, this.width + this.padding - this.border, this.border));\n        this.freeRects.push(new Rectangle(width - this.border * 2, height - this.height - this.padding, this.border, this.height + this.padding - this.border));\n        this.freeRects = this.freeRects.filter(freeRect => {\n            return !(freeRect.width <= 0 || freeRect.height <= 0 || freeRect.x < this.border || freeRect.y < this.border);\n        });\n        this.pruneFreeList();\n    }\n}\n\nclass OversizedElementBin extends Bin {\n    constructor(...args) {\n        super();\n        this.rects = [];\n        if (args.length === 1) {\n            if (typeof args[0] !== 'object')\n                throw new Error(\"OversizedElementBin: Wrong parameters\");\n            const rect = args[0];\n            this.rects = [rect];\n            this.width = rect.width;\n            this.height = rect.height;\n            this.data = rect.data;\n            rect.oversized = true;\n        }\n        else {\n            this.width = args[0];\n            this.height = args[1];\n            this.data = args.length > 2 ? args[2] : null;\n            const rect = new Rectangle(this.width, this.height);\n            rect.oversized = true;\n            rect.data = this.data;\n            this.rects.push(rect);\n        }\n        this.freeRects = [];\n        this.maxWidth = this.width;\n        this.maxHeight = this.height;\n        this.options = { smart: false, pot: false, square: false };\n    }\n    add() { return undefined; }\n    reset(deepReset = false) {\n        // nothing to do here\n    }\n    repack() { return undefined; }\n}\n\nconst EDGE_MAX_VALUE = 4096;\nvar PACKING_LOGIC;\n(function (PACKING_LOGIC) {\n    PACKING_LOGIC[PACKING_LOGIC[\"MAX_AREA\"] = 0] = \"MAX_AREA\";\n    PACKING_LOGIC[PACKING_LOGIC[\"MAX_EDGE\"] = 1] = \"MAX_EDGE\";\n})(PACKING_LOGIC || (PACKING_LOGIC = {}));\nclass MaxRectsPacker {\n    /**\n     * Creates an instance of MaxRectsPacker.\n     * @param {number} width of the output atlas (default is 4096)\n     * @param {number} height of the output atlas (default is 4096)\n     * @param {number} padding between glyphs/images (default is 0)\n     * @param {IOption} [options={}] (Optional) packing options\n     * @memberof MaxRectsPacker\n     */\n    constructor(width = EDGE_MAX_VALUE, height = EDGE_MAX_VALUE, padding = 0, options = { smart: true, pot: true, square: false, allowRotation: false, tag: false, border: 0, logic: PACKING_LOGIC.MAX_EDGE }) {\n        this.width = width;\n        this.height = height;\n        this.padding = padding;\n        this.options = options;\n        this._currentBinIndex = 0;\n        this.bins = [];\n    }\n    add(...args) {\n        if (args.length === 1) {\n            if (typeof args[0] !== 'object')\n                throw new Error(\"MacrectsPacker.add(): Wrong parameters\");\n            const rect = args[0];\n            if (rect.width > this.width || rect.height > this.height) {\n                this.bins.push(new OversizedElementBin(rect));\n            }\n            else {\n                let added = this.bins.slice(this._currentBinIndex).find(bin => bin.add(rect) !== undefined);\n                if (!added) {\n                    let bin = new MaxRectsBin(this.width, this.height, this.padding, this.options);\n                    let tag = (rect.data && rect.data.tag) ? rect.data.tag : rect.tag ? rect.tag : undefined;\n                    if (this.options.tag && tag)\n                        bin.tag = tag;\n                    bin.add(rect);\n                    this.bins.push(bin);\n                }\n            }\n            return rect;\n        }\n        else {\n            const rect = new Rectangle(args[0], args[1]);\n            if (args.length > 2)\n                rect.data = args[2];\n            if (rect.width > this.width || rect.height > this.height) {\n                this.bins.push(new OversizedElementBin(rect));\n            }\n            else {\n                let added = this.bins.slice(this._currentBinIndex).find(bin => bin.add(rect) !== undefined);\n                if (!added) {\n                    let bin = new MaxRectsBin(this.width, this.height, this.padding, this.options);\n                    if (this.options.tag && rect.data.tag)\n                        bin.tag = rect.data.tag;\n                    bin.add(rect);\n                    this.bins.push(bin);\n                }\n            }\n            return rect;\n        }\n    }\n    /**\n     * Add an Array of bins/rectangles to the packer.\n     *\n     * `Javascript`: Any object has property: { width, height, ... } is accepted.\n     *\n     * `Typescript`: object shall extends `MaxrectsPacker.IRectangle`.\n     *\n     * note: object has `hash` property will have more stable packing result\n     *\n     * @param {IRectangle[]} rects Array of bin/rectangles\n     * @memberof MaxRectsPacker\n     */\n    addArray(rects) {\n        this.sort(rects, this.options.logic).forEach(rect => this.add(rect));\n    }\n    /**\n     * Reset entire packer to initial states, keep settings\n     *\n     * @memberof MaxRectsPacker\n     */\n    reset() {\n        this.bins = [];\n        this._currentBinIndex = 0;\n    }\n    /**\n     * Repack all elements inside bins\n     *\n     * @param {boolean} [quick=true] quick repack only dirty bins\n     * @returns {void}\n     * @memberof MaxRectsPacker\n     */\n    repack(quick = true) {\n        if (quick) {\n            let unpack = [];\n            for (let bin of this.bins) {\n                if (bin.dirty) {\n                    let up = bin.repack();\n                    if (up)\n                        unpack.push(...up);\n                }\n            }\n            this.addArray(unpack);\n            return;\n        }\n        if (!this.dirty)\n            return;\n        const allRects = this.rects;\n        this.reset();\n        this.addArray(allRects);\n    }\n    /**\n     * Stop adding new element to the current bin and return a new bin.\n     *\n     * note: After calling `next()` all elements will no longer added to previous bins.\n     *\n     * @returns {Bin}\n     * @memberof MaxRectsPacker\n     */\n    next() {\n        this._currentBinIndex = this.bins.length;\n        return this._currentBinIndex;\n    }\n    /**\n     * Load bins to the packer, overwrite exist bins\n     * @param {MaxRectsBin[]} bins MaxRectsBin objects\n     * @memberof MaxRectsPacker\n     */\n    load(bins) {\n        bins.forEach((bin, index) => {\n            if (bin.maxWidth > this.width || bin.maxHeight > this.height) {\n                this.bins.push(new OversizedElementBin(bin.width, bin.height, {}));\n            }\n            else {\n                let newBin = new MaxRectsBin(this.width, this.height, this.padding, bin.options);\n                newBin.freeRects.splice(0);\n                bin.freeRects.forEach((r, i) => {\n                    newBin.freeRects.push(new Rectangle(r.width, r.height, r.x, r.y));\n                });\n                newBin.width = bin.width;\n                newBin.height = bin.height;\n                if (bin.tag)\n                    newBin.tag = bin.tag;\n                this.bins[index] = newBin;\n            }\n        }, this);\n    }\n    /**\n     * Output current bins to save\n     * @memberof MaxRectsPacker\n     */\n    save() {\n        let saveBins = [];\n        this.bins.forEach((bin => {\n            let saveBin = {\n                width: bin.width,\n                height: bin.height,\n                maxWidth: bin.maxWidth,\n                maxHeight: bin.maxHeight,\n                freeRects: [],\n                rects: [],\n                options: bin.options\n            };\n            if (bin.tag)\n                saveBin = Object.assign({}, saveBin, { tag: bin.tag });\n            bin.freeRects.forEach(r => {\n                saveBin.freeRects.push({\n                    x: r.x,\n                    y: r.y,\n                    width: r.width,\n                    height: r.height\n                });\n            });\n            saveBins.push(saveBin);\n        }));\n        return saveBins;\n    }\n    /**\n     * Sort the given rects based on longest edge or surface area.\n     *\n     * If rects have the same sort value, will sort by second key `hash` if presented.\n     *\n     * @private\n     * @param {T[]} rects\n     * @param {string} [logic=\"area\"] sorting logic, \"area\" or \"edge\"\n     * @returns\n     * @memberof MaxRectsPacker\n     */\n    sort(rects, logic = PACKING_LOGIC.MAX_EDGE) {\n        return rects.slice().sort((a, b) => {\n            const result = (logic === PACKING_LOGIC.MAX_EDGE) ?\n                Math.max(b.width, b.height) - Math.max(a.width, a.height) :\n                b.width * b.height - a.width * a.height;\n            if (result === 0 && a.hash && b.hash) {\n                return a.hash > b.hash ? -1 : 1;\n            }\n            else\n                return result;\n        });\n    }\n    /**\n     * Return current functioning bin index, perior to this wont accept any new elements\n     *\n     * @readonly\n     * @type {number}\n     * @memberof MaxRectsPacker\n     */\n    get currentBinIndex() { return this._currentBinIndex; }\n    /**\n     * Returns dirty status of all child bins\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberof MaxRectsPacker\n     */\n    get dirty() { return this.bins.some(bin => bin.dirty); }\n    /**\n     * Return all rectangles in this packer\n     *\n     * @readonly\n     * @type {T[]}\n     * @memberof MaxRectsPacker\n     */\n    get rects() {\n        let allRects = [];\n        for (let bin of this.bins) {\n            allRects.push(...bin.rects);\n        }\n        return allRects;\n    }\n}\n\nexport { Bin, MaxRectsBin, MaxRectsPacker, OversizedElementBin, PACKING_LOGIC, Rectangle };\n//# sourceMappingURL=maxrects-packer.mjs.map\n","var vec2 = require('../math/vec2')\n,   Utils = require('../utils/Utils');\n\nmodule.exports = AABB;\n\n/**\n * Axis aligned bounding box class.\n * @class AABB\n * @constructor\n * @param {Object}  [options]\n * @param {Array}   [options.upperBound]\n * @param {Array}   [options.lowerBound]\n */\nfunction AABB(options){\n\n    /**\n     * The lower bound of the bounding box.\n     * @property lowerBound\n     * @type {Array}\n     */\n    this.lowerBound = vec2.create();\n    if(options && options.lowerBound){\n        vec2.copy(this.lowerBound, options.lowerBound);\n    }\n\n    /**\n     * The upper bound of the bounding box.\n     * @property upperBound\n     * @type {Array}\n     */\n    this.upperBound = vec2.create();\n    if(options && options.upperBound){\n        vec2.copy(this.upperBound, options.upperBound);\n    }\n}\n\nvar tmp = vec2.create();\n\n/**\n * Set the AABB bounds from a set of points, transformed by the given position and angle.\n * @method setFromPoints\n * @param {Array} points An array of vec2's.\n * @param {Array} position\n * @param {number} angle\n * @param {number} skinSize Some margin to be added to the AABB.\n */\nAABB.prototype.setFromPoints = function(points, position, angle, skinSize){\n    var l = this.lowerBound,\n        u = this.upperBound;\n\n    if(typeof(angle) !== \"number\"){\n        angle = 0;\n    }\n\n    // Set to the first point\n    if(angle !== 0){\n        vec2.rotate(l, points[0], angle);\n    } else {\n        vec2.copy(l, points[0]);\n    }\n    vec2.copy(u, l);\n\n    // Compute cosines and sines just once\n    var cosAngle = Math.cos(angle),\n        sinAngle = Math.sin(angle);\n    for(var i = 1; i<points.length; i++){\n        var p = points[i];\n\n        if(angle !== 0){\n            var x = p[0],\n                y = p[1];\n            tmp[0] = cosAngle * x -sinAngle * y;\n            tmp[1] = sinAngle * x +cosAngle * y;\n            p = tmp;\n        }\n\n        for(var j=0; j<2; j++){\n            if(p[j] > u[j]){\n                u[j] = p[j];\n            }\n            if(p[j] < l[j]){\n                l[j] = p[j];\n            }\n        }\n    }\n\n    // Add offset\n    if(position){\n        vec2.add(this.lowerBound, this.lowerBound, position);\n        vec2.add(this.upperBound, this.upperBound, position);\n    }\n\n    if(skinSize){\n        this.lowerBound[0] -= skinSize;\n        this.lowerBound[1] -= skinSize;\n        this.upperBound[0] += skinSize;\n        this.upperBound[1] += skinSize;\n    }\n};\n\n/**\n * Copy bounds from an AABB to this AABB\n * @method copy\n * @param  {AABB} aabb\n */\nAABB.prototype.copy = function(aabb){\n    vec2.copy(this.lowerBound, aabb.lowerBound);\n    vec2.copy(this.upperBound, aabb.upperBound);\n};\n\n/**\n * Extend this AABB so that it covers the given AABB too.\n * @method extend\n * @param  {AABB} aabb\n */\nAABB.prototype.extend = function(aabb){\n    // Loop over x and y\n    var i = 2;\n    while(i--){\n        // Extend lower bound\n        var l = aabb.lowerBound[i];\n        if(this.lowerBound[i] > l){\n            this.lowerBound[i] = l;\n        }\n\n        // Upper\n        var u = aabb.upperBound[i];\n        if(this.upperBound[i] < u){\n            this.upperBound[i] = u;\n        }\n    }\n};\n\n/**\n * Returns true if the given AABB overlaps this AABB.\n * @method overlaps\n * @param  {AABB} aabb\n * @return {Boolean}\n */\nAABB.prototype.overlaps = function(aabb){\n    var l1 = this.lowerBound,\n        u1 = this.upperBound,\n        l2 = aabb.lowerBound,\n        u2 = aabb.upperBound;\n\n    //      l2        u2\n    //      |---------|\n    // |--------|\n    // l1       u1\n\n    return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&\n           ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));\n};\n\n/**\n * @method containsPoint\n * @param  {Array} point\n * @return {boolean}\n */\nAABB.prototype.containsPoint = function(point){\n    var l = this.lowerBound,\n        u = this.upperBound;\n    return l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];\n};\n\n/**\n * Check if the AABB is hit by a ray.\n * @method overlapsRay\n * @param  {Ray} ray\n * @return {number} -1 if no hit, a number between 0 and 1 if hit.\n */\nAABB.prototype.overlapsRay = function(ray){\n    var t = 0;\n\n    // ray.direction is unit direction vector of ray\n    var dirFracX = 1 / ray.direction[0];\n    var dirFracY = 1 / ray.direction[1];\n\n    // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n    var t1 = (this.lowerBound[0] - ray.from[0]) * dirFracX;\n    var t2 = (this.upperBound[0] - ray.from[0]) * dirFracX;\n    var t3 = (this.lowerBound[1] - ray.from[1]) * dirFracY;\n    var t4 = (this.upperBound[1] - ray.from[1]) * dirFracY;\n\n    var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));\n    var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));\n\n    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us\n    if (tmax < 0){\n        //t = tmax;\n        return -1;\n    }\n\n    // if tmin > tmax, ray doesn't intersect AABB\n    if (tmin > tmax){\n        //t = tmax;\n        return -1;\n    }\n\n    return tmin;\n};","var vec2 = require('../math/vec2');\nvar Body = require('../objects/Body');\n\nmodule.exports = Broadphase;\n\n/**\n * Base class for broadphase implementations.\n * @class Broadphase\n * @constructor\n */\nfunction Broadphase(type){\n\n    this.type = type;\n\n    /**\n     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().\n     * @property result\n     * @type {Array}\n     */\n    this.result = [];\n\n    /**\n     * The world to search for collision pairs in. To change it, use .setWorld()\n     * @property world\n     * @type {World}\n     * @readOnly\n     */\n    this.world = null;\n\n    /**\n     * The bounding volume type to use in the broadphase algorithms. Should be set to Broadphase.AABB or Broadphase.BOUNDING_CIRCLE.\n     * @property {Number} boundingVolumeType\n     */\n    this.boundingVolumeType = Broadphase.AABB;\n}\n\n/**\n * Axis aligned bounding box type.\n * @static\n * @property {Number} AABB\n */\nBroadphase.AABB = 1;\n\n/**\n * Bounding circle type.\n * @static\n * @property {Number} BOUNDING_CIRCLE\n */\nBroadphase.BOUNDING_CIRCLE = 2;\n\n/**\n * Set the world that we are searching for collision pairs in.\n * @method setWorld\n * @param  {World} world\n */\nBroadphase.prototype.setWorld = function(world){\n    this.world = world;\n};\n\n/**\n * Get all potential intersecting body pairs.\n * @method getCollisionPairs\n * @param  {World} world The world to search in.\n * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).\n */\nBroadphase.prototype.getCollisionPairs = function(world){};\n\nvar dist = vec2.create();\n\n/**\n * Check whether the bounding radius of two bodies overlap.\n * @method  boundingRadiusCheck\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.boundingRadiusCheck = function(bodyA, bodyB){\n    vec2.sub(dist, bodyA.position, bodyB.position);\n    var d2 = vec2.squaredLength(dist),\n        r = bodyA.boundingRadius + bodyB.boundingRadius;\n    return d2 <= r*r;\n};\n\n/**\n * Check whether the bounding radius of two bodies overlap.\n * @method  boundingRadiusCheck\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.aabbCheck = function(bodyA, bodyB){\n    return bodyA.getAABB().overlaps(bodyB.getAABB());\n};\n\n/**\n * Check whether the bounding radius of two bodies overlap.\n * @method  boundingRadiusCheck\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB){\n    var result;\n\n    switch(this.boundingVolumeType){\n    case Broadphase.BOUNDING_CIRCLE:\n        result =  Broadphase.boundingRadiusCheck(bodyA,bodyB);\n        break;\n    case Broadphase.AABB:\n        result = Broadphase.aabbCheck(bodyA,bodyB);\n        break;\n    default:\n        throw new Error('Bounding volume type not recognized: '+this.boundingVolumeType);\n    }\n    return result;\n};\n\n/**\n * Check whether two bodies are allowed to collide at all.\n * @method  canCollide\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.canCollide = function(bodyA, bodyB){\n    var KINEMATIC = Body.KINEMATIC;\n    var STATIC = Body.STATIC;\n\n    // Cannot collide static bodies\n    if(bodyA.type === STATIC && bodyB.type === STATIC){\n        return false;\n    }\n\n    // Cannot collide static vs kinematic bodies\n    if( (bodyA.type === KINEMATIC && bodyB.type === STATIC) ||\n        (bodyA.type === STATIC    && bodyB.type === KINEMATIC)){\n        return false;\n    }\n\n    // Cannot collide kinematic vs kinematic\n    if(bodyA.type === KINEMATIC && bodyB.type === KINEMATIC){\n        return false;\n    }\n\n    // Cannot collide both sleeping bodies\n    if(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){\n        return false;\n    }\n\n    // Cannot collide if one is static and the other is sleeping\n    if( (bodyA.sleepState === Body.SLEEPING && bodyB.type === STATIC) ||\n        (bodyB.sleepState === Body.SLEEPING && bodyA.type === STATIC)){\n        return false;\n    }\n\n    return true;\n};\n\nBroadphase.NAIVE = 1;\nBroadphase.SAP = 2;\n","var Circle = require('../shapes/Circle'),\n    Plane = require('../shapes/Plane'),\n    Shape = require('../shapes/Shape'),\n    Particle = require('../shapes/Particle'),\n    Broadphase = require('../collision/Broadphase'),\n    vec2 = require('../math/vec2');\n\nmodule.exports = NaiveBroadphase;\n\n/**\n * Naive broadphase implementation. Does N^2 tests.\n *\n * @class NaiveBroadphase\n * @constructor\n * @extends Broadphase\n */\nfunction NaiveBroadphase(){\n    Broadphase.call(this, Broadphase.NAIVE);\n}\nNaiveBroadphase.prototype = new Broadphase();\nNaiveBroadphase.prototype.constructor = NaiveBroadphase;\n\n/**\n * Get the colliding pairs\n * @method getCollisionPairs\n * @param  {World} world\n * @return {Array}\n */\nNaiveBroadphase.prototype.getCollisionPairs = function(world){\n    var bodies = world.bodies,\n        result = this.result;\n\n    result.length = 0;\n\n    for(var i=0, Ncolliding=bodies.length; i!==Ncolliding; i++){\n        var bi = bodies[i];\n\n        for(var j=0; j<i; j++){\n            var bj = bodies[j];\n\n            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){\n                result.push(bi,bj);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Returns all the bodies within an AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param {array} result An array to store resulting bodies in.\n * @return {array}\n */\nNaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){\n    result = result || [];\n\n    var bodies = world.bodies;\n    for(var i = 0; i < bodies.length; i++){\n        var b = bodies[i];\n\n        if(b.aabbNeedsUpdate){\n            b.updateAABB();\n        }\n\n        if(b.aabb.overlaps(aabb)){\n            result.push(b);\n        }\n    }\n\n    return result;\n};","var vec2 = require('../math/vec2')\n,   sub = vec2.sub\n,   add = vec2.add\n,   dot = vec2.dot\n,   Utils = require('../utils/Utils')\n,   ContactEquationPool = require('../utils/ContactEquationPool')\n,   FrictionEquationPool = require('../utils/FrictionEquationPool')\n,   TupleDictionary = require('../utils/TupleDictionary')\n,   Equation = require('../equations/Equation')\n,   ContactEquation = require('../equations/ContactEquation')\n,   FrictionEquation = require('../equations/FrictionEquation')\n,   Circle = require('../shapes/Circle')\n,   Convex = require('../shapes/Convex')\n,   Shape = require('../shapes/Shape')\n,   Body = require('../objects/Body')\n,   Box = require('../shapes/Box');\n\nmodule.exports = Narrowphase;\n\n// Temp things\nvar yAxis = vec2.fromValues(0,1);\n\nvar tmp1 = vec2.fromValues(0,0)\n,   tmp2 = vec2.fromValues(0,0)\n,   tmp3 = vec2.fromValues(0,0)\n,   tmp4 = vec2.fromValues(0,0)\n,   tmp5 = vec2.fromValues(0,0)\n,   tmp6 = vec2.fromValues(0,0)\n,   tmp7 = vec2.fromValues(0,0)\n,   tmp8 = vec2.fromValues(0,0)\n,   tmp9 = vec2.fromValues(0,0)\n,   tmp10 = vec2.fromValues(0,0)\n,   tmp11 = vec2.fromValues(0,0)\n,   tmp12 = vec2.fromValues(0,0)\n,   tmp13 = vec2.fromValues(0,0)\n,   tmp14 = vec2.fromValues(0,0)\n,   tmp15 = vec2.fromValues(0,0)\n,   tmp16 = vec2.fromValues(0,0)\n,   tmp17 = vec2.fromValues(0,0)\n,   tmp18 = vec2.fromValues(0,0)\n,   tmpArray = [];\n\n/**\n * Narrowphase. Creates contacts and friction given shapes and transforms.\n * @class Narrowphase\n * @constructor\n */\nfunction Narrowphase(){\n\n    /**\n     * @property contactEquations\n     * @type {Array}\n     */\n    this.contactEquations = [];\n\n    /**\n     * @property frictionEquations\n     * @type {Array}\n     */\n    this.frictionEquations = [];\n\n    /**\n     * Whether to make friction equations in the upcoming contacts.\n     * @property enableFriction\n     * @type {Boolean}\n     */\n    this.enableFriction = true;\n\n    /**\n     * Whether to make equations enabled in upcoming contacts.\n     * @property enabledEquations\n     * @type {Boolean}\n     */\n    this.enabledEquations = true;\n\n    /**\n     * The friction slip force to use when creating friction equations.\n     * @property slipForce\n     * @type {Number}\n     */\n    this.slipForce = 10.0;\n\n    /**\n     * The friction value to use in the upcoming friction equations.\n     * @property frictionCoefficient\n     * @type {Number}\n     */\n    this.frictionCoefficient = 0.3;\n\n    /**\n     * Will be the .relativeVelocity in each produced FrictionEquation.\n     * @property {Number} surfaceVelocity\n     */\n    this.surfaceVelocity = 0;\n\n    /**\n     * Keeps track of the allocated ContactEquations.\n     * @property {ContactEquationPool} contactEquationPool\n     *\n     * @example\n     *\n     *     // Allocate a few equations before starting the simulation.\n     *     // This way, no contact objects need to be created on the fly in the game loop.\n     *     world.narrowphase.contactEquationPool.resize(1024);\n     *     world.narrowphase.frictionEquationPool.resize(1024);\n     */\n    this.contactEquationPool = new ContactEquationPool({ size: 32 });\n\n    /**\n     * Keeps track of the allocated ContactEquations.\n     * @property {FrictionEquationPool} frictionEquationPool\n     */\n    this.frictionEquationPool = new FrictionEquationPool({ size: 64 });\n\n    /**\n     * The restitution value to use in the next contact equations.\n     * @property restitution\n     * @type {Number}\n     */\n    this.restitution = 0;\n\n    /**\n     * The stiffness value to use in the next contact equations.\n     * @property {Number} stiffness\n     */\n    this.stiffness = Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * The stiffness value to use in the next contact equations.\n     * @property {Number} stiffness\n     */\n    this.relaxation = Equation.DEFAULT_RELAXATION;\n\n    /**\n     * The stiffness value to use in the next friction equations.\n     * @property frictionStiffness\n     * @type {Number}\n     */\n    this.frictionStiffness = Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * The relaxation value to use in the next friction equations.\n     * @property frictionRelaxation\n     * @type {Number}\n     */\n    this.frictionRelaxation = Equation.DEFAULT_RELAXATION;\n\n    /**\n     * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.\n     * @property enableFrictionReduction\n     * @type {Boolean}\n     * @deprecated This flag will be removed when the feature is stable enough.\n     * @default true\n     */\n    this.enableFrictionReduction = true;\n\n    /**\n     * Keeps track of the colliding bodies last step.\n     * @private\n     * @property collidingBodiesLastStep\n     * @type {TupleDictionary}\n     */\n    this.collidingBodiesLastStep = new TupleDictionary();\n\n    /**\n     * Contact skin size value to use in the next contact equations.\n     * @property {Number} contactSkinSize\n     * @default 0.01\n     */\n    this.contactSkinSize = 0.01;\n}\n\nvar bodiesOverlap_shapePositionA = vec2.create();\nvar bodiesOverlap_shapePositionB = vec2.create();\n\n/**\n * @method bodiesOverlap\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n * @todo shape world transforms are wrong\n */\nNarrowphase.prototype.bodiesOverlap = function(bodyA, bodyB){\n    var shapePositionA = bodiesOverlap_shapePositionA;\n    var shapePositionB = bodiesOverlap_shapePositionB;\n\n    // Loop over all shapes of bodyA\n    for(var k=0, Nshapesi=bodyA.shapes.length; k!==Nshapesi; k++){\n        var shapeA = bodyA.shapes[k];\n\n        bodyA.toWorldFrame(shapePositionA, shapeA.position);\n\n        // All shapes of body j\n        for(var l=0, Nshapesj=bodyB.shapes.length; l!==Nshapesj; l++){\n            var shapeB = bodyB.shapes[l];\n\n            bodyB.toWorldFrame(shapePositionB, shapeB.position);\n\n            if(this[shapeA.type | shapeB.type](\n                bodyA,\n                shapeA,\n                shapePositionA,\n                shapeA.angle + bodyA.angle,\n                bodyB,\n                shapeB,\n                shapePositionB,\n                shapeB.angle + bodyB.angle,\n                true\n            )){\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Check if the bodies were in contact since the last reset().\n * @method collidedLastStep\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nNarrowphase.prototype.collidedLastStep = function(bodyA, bodyB){\n    var id1 = bodyA.id|0,\n        id2 = bodyB.id|0;\n    return !!this.collidingBodiesLastStep.get(id1, id2);\n};\n\n/**\n * Throws away the old equations and gets ready to create new\n * @method reset\n */\nNarrowphase.prototype.reset = function(){\n    this.collidingBodiesLastStep.reset();\n\n    var eqs = this.contactEquations;\n    var l = eqs.length;\n    while(l--){\n        var eq = eqs[l],\n            id1 = eq.bodyA.id,\n            id2 = eq.bodyB.id;\n        this.collidingBodiesLastStep.set(id1, id2, true);\n    }\n\n    var ce = this.contactEquations,\n        fe = this.frictionEquations;\n    for(var i=0; i<ce.length; i++){\n        this.contactEquationPool.release(ce[i]);\n    }\n    for(var i=0; i<fe.length; i++){\n        this.frictionEquationPool.release(fe[i]);\n    }\n\n    // Reset\n    this.contactEquations.length = this.frictionEquations.length = 0;\n};\n\n/**\n * Creates a ContactEquation, either by reusing an existing object or creating a new one.\n * @method createContactEquation\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {ContactEquation}\n */\nNarrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB){\n    var c = this.contactEquationPool.get();\n    c.bodyA = bodyA;\n    c.bodyB = bodyB;\n    c.shapeA = shapeA;\n    c.shapeB = shapeB;\n    c.restitution = this.restitution;\n    c.firstImpact = !this.collidedLastStep(bodyA,bodyB);\n    c.stiffness = this.stiffness;\n    c.relaxation = this.relaxation;\n    c.needsUpdate = true;\n    c.enabled = this.enabledEquations;\n    c.offset = this.contactSkinSize;\n\n    return c;\n};\n\n/**\n * Creates a FrictionEquation, either by reusing an existing object or creating a new one.\n * @method createFrictionEquation\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {FrictionEquation}\n */\nNarrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB){\n    var c = this.frictionEquationPool.get();\n    c.bodyA = bodyA;\n    c.bodyB = bodyB;\n    c.shapeA = shapeA;\n    c.shapeB = shapeB;\n    c.setSlipForce(this.slipForce);\n    c.frictionCoefficient = this.frictionCoefficient;\n    c.relativeVelocity = this.surfaceVelocity;\n    c.enabled = this.enabledEquations;\n    c.needsUpdate = true;\n    c.stiffness = this.frictionStiffness;\n    c.relaxation = this.frictionRelaxation;\n    c.contactEquations.length = 0;\n    return c;\n};\n\n/**\n * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.\n * @method createFrictionFromContact\n * @param  {ContactEquation} contactEquation\n * @return {FrictionEquation}\n */\nNarrowphase.prototype.createFrictionFromContact = function(c){\n    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);\n    vec2.copy(eq.contactPointA, c.contactPointA);\n    vec2.copy(eq.contactPointB, c.contactPointB);\n    vec2.rotate90cw(eq.t, c.normalA);\n    eq.contactEquations.push(c);\n    return eq;\n};\n\n// Take the average N latest contact point on the plane.\nNarrowphase.prototype.createFrictionFromAverage = function(numContacts){\n    var c = this.contactEquations[this.contactEquations.length - 1];\n    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);\n    var bodyA = c.bodyA;\n    var bodyB = c.bodyB;\n    vec2.set(eq.contactPointA, 0, 0);\n    vec2.set(eq.contactPointB, 0, 0);\n    vec2.set(eq.t, 0, 0);\n    for(var i=0; i!==numContacts; i++){\n        c = this.contactEquations[this.contactEquations.length - 1 - i];\n        if(c.bodyA === bodyA){\n            vec2.add(eq.t, eq.t, c.normalA);\n            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);\n            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);\n        } else {\n            vec2.sub(eq.t, eq.t, c.normalA);\n            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);\n            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);\n        }\n        eq.contactEquations.push(c);\n    }\n\n    var invNumContacts = 1/numContacts;\n    vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);\n    vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);\n    vec2.normalize(eq.t, eq.t);\n    vec2.rotate90cw(eq.t, eq.t);\n    return eq;\n};\n\n/**\n * Convex/line narrowphase\n * @method convexLine\n * @param  {Body}       convexBody\n * @param  {Convex}     convexShape\n * @param  {Array}      convexOffset\n * @param  {Number}     convexAngle\n * @param  {Body}       lineBody\n * @param  {Line}       lineShape\n * @param  {Array}      lineOffset\n * @param  {Number}     lineAngle\n * @param {boolean}     justTest\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.LINE | Shape.CONVEX] =\nNarrowphase.prototype.convexLine = function(\n    convexBody,\n    convexShape,\n    convexOffset,\n    convexAngle,\n    lineBody,\n    lineShape,\n    lineOffset,\n    lineAngle,\n    justTest\n){\n    // TODO\n    if(justTest){\n        return false;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * Line/box narrowphase\n * @method lineBox\n * @param  {Body}       lineBody\n * @param  {Line}       lineShape\n * @param  {Array}      lineOffset\n * @param  {Number}     lineAngle\n * @param  {Body}       boxBody\n * @param  {Box}  boxShape\n * @param  {Array}      boxOffset\n * @param  {Number}     boxAngle\n * @param  {Boolean}    justTest\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.LINE | Shape.BOX] =\nNarrowphase.prototype.lineBox = function(\n    lineBody,\n    lineShape,\n    lineOffset,\n    lineAngle,\n    boxBody,\n    boxShape,\n    boxOffset,\n    boxAngle,\n    justTest\n){\n    // TODO\n    if(justTest){\n        return false;\n    } else {\n        return 0;\n    }\n};\n\nfunction setConvexToCapsuleShapeMiddle(convexShape, capsuleShape){\n    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);\n    vec2.set(convexShape.vertices[1],  capsuleShape.length * 0.5, -capsuleShape.radius);\n    vec2.set(convexShape.vertices[2],  capsuleShape.length * 0.5,  capsuleShape.radius);\n    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5,  capsuleShape.radius);\n}\n\nvar convexCapsule_tempRect = new Box({ width: 1, height: 1 }),\n    convexCapsule_tempVec = vec2.create();\n\n/**\n * Convex/capsule narrowphase\n * @method convexCapsule\n * @param  {Body}       convexBody\n * @param  {Convex}     convexShape\n * @param  {Array}      convexPosition\n * @param  {Number}     convexAngle\n * @param  {Body}       capsuleBody\n * @param  {Capsule}    capsuleShape\n * @param  {Array}      capsulePosition\n * @param  {Number}     capsuleAngle\n */\nNarrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.CAPSULE | Shape.BOX] =\nNarrowphase.prototype.convexCapsule = function(\n    convexBody,\n    convexShape,\n    convexPosition,\n    convexAngle,\n    capsuleBody,\n    capsuleShape,\n    capsulePosition,\n    capsuleAngle,\n    justTest\n){\n\n    // Check the circles\n    // Add offsets!\n    var circlePos = convexCapsule_tempVec;\n    vec2.set(circlePos, capsuleShape.length/2,0);\n    vec2.rotate(circlePos,circlePos,capsuleAngle);\n    vec2.add(circlePos,circlePos,capsulePosition);\n    var result1 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);\n\n    vec2.set(circlePos,-capsuleShape.length/2, 0);\n    vec2.rotate(circlePos,circlePos,capsuleAngle);\n    vec2.add(circlePos,circlePos,capsulePosition);\n    var result2 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);\n\n    if(justTest && (result1 || result2)){\n        return true;\n    }\n\n    // Check center rect\n    var r = convexCapsule_tempRect;\n    setConvexToCapsuleShapeMiddle(r,capsuleShape);\n    var result = this.convexConvex(convexBody,convexShape,convexPosition,convexAngle, capsuleBody,r,capsulePosition,capsuleAngle, justTest);\n\n    return result + result1 + result2;\n};\n\n/**\n * Capsule/line narrowphase\n * @method lineCapsule\n * @param  {Body}       lineBody\n * @param  {Line}       lineShape\n * @param  {Array}      linePosition\n * @param  {Number}     lineAngle\n * @param  {Body}       capsuleBody\n * @param  {Capsule}    capsuleShape\n * @param  {Array}      capsulePosition\n * @param  {Number}     capsuleAngle\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.CAPSULE | Shape.LINE] =\nNarrowphase.prototype.lineCapsule = function(\n    lineBody,\n    lineShape,\n    linePosition,\n    lineAngle,\n    capsuleBody,\n    capsuleShape,\n    capsulePosition,\n    capsuleAngle,\n    justTest\n){\n    // TODO\n    if(justTest){\n        return false;\n    } else {\n        return 0;\n    }\n};\n\nvar capsuleCapsule_tempVec1 = vec2.create();\nvar capsuleCapsule_tempVec2 = vec2.create();\nvar capsuleCapsule_tempRect1 = new Box({ width: 1, height: 1 });\n\n/**\n * Capsule/capsule narrowphase\n * @method capsuleCapsule\n * @param  {Body}       bi\n * @param  {Capsule}    si\n * @param  {Array}      xi\n * @param  {Number}     ai\n * @param  {Body}       bj\n * @param  {Capsule}    sj\n * @param  {Array}      xj\n * @param  {Number}     aj\n */\nNarrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] =\nNarrowphase.prototype.capsuleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n\n    var enableFrictionBefore;\n\n    // Check the circles\n    // Add offsets!\n    var circlePosi = capsuleCapsule_tempVec1,\n        circlePosj = capsuleCapsule_tempVec2;\n\n    var numContacts = 0;\n\n\n    // Need 4 circle checks, between all\n    for(var i=0; i<2; i++){\n\n        vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);\n        vec2.rotate(circlePosi,circlePosi,ai);\n        vec2.add(circlePosi,circlePosi,xi);\n\n        for(var j=0; j<2; j++){\n\n            vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);\n            vec2.rotate(circlePosj,circlePosj,aj);\n            vec2.add(circlePosj,circlePosj,xj);\n\n            // Temporarily turn off friction\n            if(this.enableFrictionReduction){\n                enableFrictionBefore = this.enableFriction;\n                this.enableFriction = false;\n            }\n\n            var result = this.circleCircle(bi,si,circlePosi,ai, bj,sj,circlePosj,aj, justTest, si.radius, sj.radius);\n\n            if(this.enableFrictionReduction){\n                this.enableFriction = enableFrictionBefore;\n            }\n\n            if(justTest && result){\n                return true;\n            }\n\n            numContacts += result;\n        }\n    }\n\n    if(this.enableFrictionReduction){\n        // Temporarily turn off friction\n        enableFrictionBefore = this.enableFriction;\n        this.enableFriction = false;\n    }\n\n    // Check circles against the center boxs\n    var rect = capsuleCapsule_tempRect1;\n    setConvexToCapsuleShapeMiddle(rect,si);\n    var result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);\n\n    if(this.enableFrictionReduction){\n        this.enableFriction = enableFrictionBefore;\n    }\n\n    if(justTest && result1){\n        return true;\n    }\n    numContacts += result1;\n\n    if(this.enableFrictionReduction){\n        // Temporarily turn off friction\n        var enableFrictionBefore = this.enableFriction;\n        this.enableFriction = false;\n    }\n\n    setConvexToCapsuleShapeMiddle(rect,sj);\n    var result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);\n\n    if(this.enableFrictionReduction){\n        this.enableFriction = enableFrictionBefore;\n    }\n\n    if(justTest && result2){\n        return true;\n    }\n    numContacts += result2;\n\n    if(this.enableFrictionReduction){\n        if(numContacts && this.enableFriction){\n            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));\n        }\n    }\n\n    return numContacts;\n};\n\n/**\n * Line/line narrowphase\n * @method lineLine\n * @param  {Body}       bodyA\n * @param  {Line}       shapeA\n * @param  {Array}      positionA\n * @param  {Number}     angleA\n * @param  {Body}       bodyB\n * @param  {Line}       shapeB\n * @param  {Array}      positionB\n * @param  {Number}     angleB\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.LINE | Shape.LINE] =\nNarrowphase.prototype.lineLine = function(\n    bodyA,\n    shapeA,\n    positionA,\n    angleA,\n    bodyB,\n    shapeB,\n    positionB,\n    angleB,\n    justTest\n){\n    // TODO\n    if(justTest){\n        return false;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * Plane/line Narrowphase\n * @method planeLine\n * @param  {Body}   planeBody\n * @param  {Plane}  planeShape\n * @param  {Array}  planeOffset\n * @param  {Number} planeAngle\n * @param  {Body}   lineBody\n * @param  {Line}   lineShape\n * @param  {Array}  lineOffset\n * @param  {Number} lineAngle\n */\nNarrowphase.prototype[Shape.PLANE | Shape.LINE] =\nNarrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle,\n                                           lineBody,  lineShape,  lineOffset,  lineAngle, justTest){\n    var worldVertex0 = tmp1,\n        worldVertex1 = tmp2,\n        worldVertex01 = tmp3,\n        worldVertex11 = tmp4,\n        worldEdge = tmp5,\n        worldEdgeUnit = tmp6,\n        dist = tmp7,\n        worldNormal = tmp8,\n        worldTangent = tmp9,\n        verts = tmpArray,\n        numContacts = 0;\n\n    // Get start and end points\n    vec2.set(worldVertex0, -lineShape.length/2, 0);\n    vec2.set(worldVertex1,  lineShape.length/2, 0);\n\n    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.\n    vec2.rotate(worldVertex01, worldVertex0, lineAngle);\n    vec2.rotate(worldVertex11, worldVertex1, lineAngle);\n\n    add(worldVertex01, worldVertex01, lineOffset);\n    add(worldVertex11, worldVertex11, lineOffset);\n\n    vec2.copy(worldVertex0,worldVertex01);\n    vec2.copy(worldVertex1,worldVertex11);\n\n    // Get vector along the line\n    sub(worldEdge, worldVertex1, worldVertex0);\n    vec2.normalize(worldEdgeUnit, worldEdge);\n\n    // Get tangent to the edge.\n    vec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    // Check line ends\n    verts[0] = worldVertex0;\n    verts[1] = worldVertex1;\n    for(var i=0; i<verts.length; i++){\n        var v = verts[i];\n\n        sub(dist, v, planeOffset);\n\n        var d = dot(dist,worldNormal);\n\n        if(d < 0){\n\n            if(justTest){\n                return true;\n            }\n\n            var c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);\n            numContacts++;\n\n            vec2.copy(c.normalA, worldNormal);\n            vec2.normalize(c.normalA,c.normalA);\n\n            // distance vector along plane normal\n            vec2.scale(dist, worldNormal, d);\n\n            // Vector from plane center to contact\n            sub(c.contactPointA, v, dist);\n            sub(c.contactPointA, c.contactPointA, planeBody.position);\n\n            // From line center to contact\n            sub(c.contactPointB, v,    lineOffset);\n            add(c.contactPointB, c.contactPointB, lineOffset);\n            sub(c.contactPointB, c.contactPointB, lineBody.position);\n\n            this.contactEquations.push(c);\n\n            if(!this.enableFrictionReduction){\n                if(this.enableFriction){\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n                }\n            }\n        }\n    }\n\n    if(justTest){\n        return false;\n    }\n\n    if(!this.enableFrictionReduction){\n        if(numContacts && this.enableFriction){\n            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));\n        }\n    }\n\n    return numContacts;\n};\n\nNarrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =\nNarrowphase.prototype.particleCapsule = function(\n    particleBody,\n    particleShape,\n    particlePosition,\n    particleAngle,\n    capsuleBody,\n    capsuleShape,\n    capsulePosition,\n    capsuleAngle,\n    justTest\n){\n    return this.circleLine(particleBody,particleShape,particlePosition,particleAngle, capsuleBody,capsuleShape,capsulePosition,capsuleAngle, justTest, capsuleShape.radius, 0);\n};\n\n/**\n * Circle/line Narrowphase\n * @method circleLine\n * @param  {Body} circleBody\n * @param  {Circle} circleShape\n * @param  {Array} circleOffset\n * @param  {Number} circleAngle\n * @param  {Body} lineBody\n * @param  {Line} lineShape\n * @param  {Array} lineOffset\n * @param  {Number} lineAngle\n * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.\n * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.\n * @param {Number} circleRadius If set, this value overrides the circle shape radius.\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.LINE] =\nNarrowphase.prototype.circleLine = function(\n    circleBody,\n    circleShape,\n    circleOffset,\n    circleAngle,\n    lineBody,\n    lineShape,\n    lineOffset,\n    lineAngle,\n    justTest,\n    lineRadius,\n    circleRadius\n){\n    var lineRadius = lineRadius || 0,\n        circleRadius = typeof(circleRadius)!==\"undefined\" ? circleRadius : circleShape.radius,\n\n        orthoDist = tmp1,\n        lineToCircleOrthoUnit = tmp2,\n        projectedPoint = tmp3,\n        centerDist = tmp4,\n        worldTangent = tmp5,\n        worldEdge = tmp6,\n        worldEdgeUnit = tmp7,\n        worldVertex0 = tmp8,\n        worldVertex1 = tmp9,\n        worldVertex01 = tmp10,\n        worldVertex11 = tmp11,\n        dist = tmp12,\n        lineToCircle = tmp13,\n        lineEndToLineRadius = tmp14,\n\n        verts = tmpArray;\n\n    // Get start and end points\n    vec2.set(worldVertex0, -lineShape.length/2, 0);\n    vec2.set(worldVertex1,  lineShape.length/2, 0);\n\n    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.\n    vec2.rotate(worldVertex01, worldVertex0, lineAngle);\n    vec2.rotate(worldVertex11, worldVertex1, lineAngle);\n\n    add(worldVertex01, worldVertex01, lineOffset);\n    add(worldVertex11, worldVertex11, lineOffset);\n\n    vec2.copy(worldVertex0,worldVertex01);\n    vec2.copy(worldVertex1,worldVertex11);\n\n    // Get vector along the line\n    sub(worldEdge, worldVertex1, worldVertex0);\n    vec2.normalize(worldEdgeUnit, worldEdge);\n\n    // Get tangent to the edge.\n    vec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n    // Check distance from the plane spanned by the edge vs the circle\n    sub(dist, circleOffset, worldVertex0);\n    var d = dot(dist, worldTangent); // Distance from center of line to circle center\n    sub(centerDist, worldVertex0, lineOffset);\n\n    sub(lineToCircle, circleOffset, lineOffset);\n\n    var radiusSum = circleRadius + lineRadius;\n\n    if(Math.abs(d) < radiusSum){\n\n        // Now project the circle onto the edge\n        vec2.scale(orthoDist, worldTangent, d);\n        sub(projectedPoint, circleOffset, orthoDist);\n\n        // Add the missing line radius\n        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));\n        vec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);\n        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);\n        add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);\n\n        // Check if the point is within the edge span\n        var pos =  dot(worldEdgeUnit, projectedPoint);\n        var pos0 = dot(worldEdgeUnit, worldVertex0);\n        var pos1 = dot(worldEdgeUnit, worldVertex1);\n\n        if(pos > pos0 && pos < pos1){\n            // We got contact!\n\n            if(justTest){\n                return true;\n            }\n\n            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);\n\n            vec2.scale(c.normalA, orthoDist, -1);\n            vec2.normalize(c.normalA, c.normalA);\n\n            vec2.scale( c.contactPointA, c.normalA,  circleRadius);\n            add(c.contactPointA, c.contactPointA, circleOffset);\n            sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n            sub(c.contactPointB, projectedPoint, lineOffset);\n            add(c.contactPointB, c.contactPointB, lineOffset);\n            sub(c.contactPointB, c.contactPointB, lineBody.position);\n\n            this.contactEquations.push(c);\n\n            if(this.enableFriction){\n                this.frictionEquations.push(this.createFrictionFromContact(c));\n            }\n\n            return 1;\n        }\n    }\n\n    // Add corner\n    verts[0] = worldVertex0;\n    verts[1] = worldVertex1;\n\n    for(var i=0; i<verts.length; i++){\n        var v = verts[i];\n\n        sub(dist, v, circleOffset);\n\n        if(vec2.squaredLength(dist) < Math.pow(radiusSum, 2)){\n\n            if(justTest){\n                return true;\n            }\n\n            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);\n\n            vec2.copy(c.normalA, dist);\n            vec2.normalize(c.normalA,c.normalA);\n\n            // Vector from circle to contact point is the normal times the circle radius\n            vec2.scale(c.contactPointA, c.normalA, circleRadius);\n            add(c.contactPointA, c.contactPointA, circleOffset);\n            sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n            sub(c.contactPointB, v, lineOffset);\n            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);\n            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);\n            add(c.contactPointB, c.contactPointB, lineOffset);\n            sub(c.contactPointB, c.contactPointB, lineBody.position);\n\n            this.contactEquations.push(c);\n\n            if(this.enableFriction){\n                this.frictionEquations.push(this.createFrictionFromContact(c));\n            }\n\n            return 1;\n        }\n    }\n\n    return 0;\n};\n\n/**\n * Circle/capsule Narrowphase\n * @method circleCapsule\n * @param  {Body}   bi\n * @param  {Circle} si\n * @param  {Array}  xi\n * @param  {Number} ai\n * @param  {Body}   bj\n * @param  {Line}   sj\n * @param  {Array}  xj\n * @param  {Number} aj\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =\nNarrowphase.prototype.circleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius);\n};\n\n/**\n * Circle/convex Narrowphase.\n * @method circleConvex\n * @param  {Body} circleBody\n * @param  {Circle} circleShape\n * @param  {Array} circleOffset\n * @param  {Number} circleAngle\n * @param  {Body} convexBody\n * @param  {Convex} convexShape\n * @param  {Array} convexOffset\n * @param  {Number} convexAngle\n * @param  {Boolean} justTest\n * @param  {Number} circleRadius\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.CIRCLE | Shape.BOX] =\nNarrowphase.prototype.circleConvex = function(\n    circleBody,\n    circleShape,\n    circleOffset,\n    circleAngle,\n    convexBody,\n    convexShape,\n    convexOffset,\n    convexAngle,\n    justTest,\n    circleRadius\n){\n    var circleRadius = typeof(circleRadius)===\"number\" ? circleRadius : circleShape.radius;\n\n    var worldVertex0 = tmp1,\n        worldVertex1 = tmp2,\n        worldEdge = tmp3,\n        worldEdgeUnit = tmp4,\n        worldNormal = tmp5,\n        centerDist = tmp6,\n        convexToCircle = tmp7,\n        orthoDist = tmp8,\n        projectedPoint = tmp9,\n        dist = tmp10,\n        worldVertex = tmp11,\n\n        closestEdge = -1,\n        closestEdgeDistance = null,\n        closestEdgeOrthoDist = tmp12,\n        closestEdgeProjectedPoint = tmp13,\n        candidate = tmp14,\n        candidateDist = tmp15,\n        minCandidate = tmp16,\n\n        found = false,\n        minCandidateDistance = Number.MAX_VALUE;\n\n    var numReported = 0;\n\n    // New algorithm:\n    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...\n    // 2. For each edge\n    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)\n    // 2. 2. Check if point is inside.\n\n    var verts = convexShape.vertices;\n\n    // Check all edges first\n    for(var i=0; i!==verts.length+1; i++){\n        var v0 = verts[i%verts.length],\n            v1 = verts[(i+1)%verts.length];\n\n        vec2.rotate(worldVertex0, v0, convexAngle);\n        vec2.rotate(worldVertex1, v1, convexAngle);\n        add(worldVertex0, worldVertex0, convexOffset);\n        add(worldVertex1, worldVertex1, convexOffset);\n        sub(worldEdge, worldVertex1, worldVertex0);\n\n        vec2.normalize(worldEdgeUnit, worldEdge);\n\n        // Get tangent to the edge. Points out of the Convex\n        vec2.rotate90cw(worldNormal, worldEdgeUnit);\n\n        // Get point on circle, closest to the polygon\n        vec2.scale(candidate,worldNormal,-circleShape.radius);\n        add(candidate,candidate,circleOffset);\n\n        if(pointInConvex(candidate,convexShape,convexOffset,convexAngle)){\n\n            vec2.sub(candidateDist,worldVertex0,candidate);\n            var candidateDistance = Math.abs(vec2.dot(candidateDist,worldNormal));\n\n            if(candidateDistance < minCandidateDistance){\n                vec2.copy(minCandidate,candidate);\n                minCandidateDistance = candidateDistance;\n                vec2.scale(closestEdgeProjectedPoint,worldNormal,candidateDistance);\n                vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);\n                found = true;\n            }\n        }\n    }\n\n    if(found){\n\n        if(justTest){\n            return true;\n        }\n\n        var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);\n        vec2.sub(c.normalA, minCandidate, circleOffset);\n        vec2.normalize(c.normalA, c.normalA);\n\n        vec2.scale(c.contactPointA,  c.normalA, circleRadius);\n        add(c.contactPointA, c.contactPointA, circleOffset);\n        sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n        add(c.contactPointB, c.contactPointB, convexOffset);\n        sub(c.contactPointB, c.contactPointB, convexBody.position);\n\n        this.contactEquations.push(c);\n\n        if(this.enableFriction){\n            this.frictionEquations.push( this.createFrictionFromContact(c) );\n        }\n\n        return 1;\n    }\n\n    // Check all vertices\n    if(circleRadius > 0){\n        for(var i=0; i<verts.length; i++){\n            var localVertex = verts[i];\n            vec2.rotate(worldVertex, localVertex, convexAngle);\n            add(worldVertex, worldVertex, convexOffset);\n\n            sub(dist, worldVertex, circleOffset);\n            if(vec2.squaredLength(dist) < Math.pow(circleRadius, 2)){\n\n                if(justTest){\n                    return true;\n                }\n\n                var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);\n\n                vec2.copy(c.normalA, dist);\n                vec2.normalize(c.normalA,c.normalA);\n\n                // Vector from circle to contact point is the normal times the circle radius\n                vec2.scale(c.contactPointA, c.normalA, circleRadius);\n                add(c.contactPointA, c.contactPointA, circleOffset);\n                sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n                sub(c.contactPointB, worldVertex, convexOffset);\n                add(c.contactPointB, c.contactPointB, convexOffset);\n                sub(c.contactPointB, c.contactPointB, convexBody.position);\n\n                this.contactEquations.push(c);\n\n                if(this.enableFriction){\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n                }\n\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n};\n\nvar pic_worldVertex0 = vec2.create(),\n    pic_worldVertex1 = vec2.create(),\n    pic_r0 = vec2.create(),\n    pic_r1 = vec2.create();\n\n/*\n * Check if a point is in a polygon\n */\nfunction pointInConvex(worldPoint,convexShape,convexOffset,convexAngle){\n    var worldVertex0 = pic_worldVertex0,\n        worldVertex1 = pic_worldVertex1,\n        r0 = pic_r0,\n        r1 = pic_r1,\n        point = worldPoint,\n        verts = convexShape.vertices,\n        lastCross = null;\n    for(var i=0; i!==verts.length+1; i++){\n        var v0 = verts[i%verts.length],\n            v1 = verts[(i+1)%verts.length];\n\n        // Transform vertices to world\n        // @todo The point should be transformed to local coordinates in the convex, no need to transform each vertex\n        vec2.rotate(worldVertex0, v0, convexAngle);\n        vec2.rotate(worldVertex1, v1, convexAngle);\n        add(worldVertex0, worldVertex0, convexOffset);\n        add(worldVertex1, worldVertex1, convexOffset);\n\n        sub(r0, worldVertex0, point);\n        sub(r1, worldVertex1, point);\n        var cross = vec2.crossLength(r0,r1);\n\n        if(lastCross===null){\n            lastCross = cross;\n        }\n\n        // If we got a different sign of the distance vector, the point is out of the polygon\n        if(cross*lastCross <= 0){\n            return false;\n        }\n        lastCross = cross;\n    }\n    return true;\n}\n\n/**\n * Particle/convex Narrowphase\n * @method particleConvex\n * @param  {Body} particleBody\n * @param  {Particle} particleShape\n * @param  {Array} particleOffset\n * @param  {Number} particleAngle\n * @param  {Body} convexBody\n * @param  {Convex} convexShape\n * @param  {Array} convexOffset\n * @param  {Number} convexAngle\n * @param {Boolean} justTest\n * @todo use pointInConvex and code more similar to circleConvex\n * @todo don't transform each vertex, but transform the particle position to convex-local instead\n */\nNarrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.PARTICLE | Shape.BOX] =\nNarrowphase.prototype.particleConvex = function(\n    particleBody,\n    particleShape,\n    particleOffset,\n    particleAngle,\n    convexBody,\n    convexShape,\n    convexOffset,\n    convexAngle,\n    justTest\n){\n    var worldVertex0 = tmp1,\n        worldVertex1 = tmp2,\n        worldEdge = tmp3,\n        worldEdgeUnit = tmp4,\n        worldTangent = tmp5,\n        centerDist = tmp6,\n        convexToparticle = tmp7,\n        orthoDist = tmp8,\n        projectedPoint = tmp9,\n        dist = tmp10,\n        worldVertex = tmp11,\n        closestEdge = -1,\n        closestEdgeDistance = null,\n        closestEdgeOrthoDist = tmp12,\n        closestEdgeProjectedPoint = tmp13,\n        r0 = tmp14, // vector from particle to vertex0\n        r1 = tmp15,\n        localPoint = tmp16,\n        candidateDist = tmp17,\n        minEdgeNormal = tmp18,\n        minCandidateDistance = Number.MAX_VALUE;\n\n    var numReported = 0,\n        found = false,\n        verts = convexShape.vertices;\n\n    // Check if the particle is in the polygon at all\n    if(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){\n        return 0;\n    }\n\n    if(justTest){\n        return true;\n    }\n\n    // Check edges first\n    var lastCross = null;\n    for(var i=0; i!==verts.length+1; i++){\n        var v0 = verts[i%verts.length],\n            v1 = verts[(i+1)%verts.length];\n\n        // Transform vertices to world\n        vec2.rotate(worldVertex0, v0, convexAngle);\n        vec2.rotate(worldVertex1, v1, convexAngle);\n        add(worldVertex0, worldVertex0, convexOffset);\n        add(worldVertex1, worldVertex1, convexOffset);\n\n        // Get world edge\n        sub(worldEdge, worldVertex1, worldVertex0);\n        vec2.normalize(worldEdgeUnit, worldEdge);\n\n        // Get tangent to the edge. Points out of the Convex\n        vec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n        // Check distance from the infinite line (spanned by the edge) to the particle\n        sub(dist, particleOffset, worldVertex0);\n        var d = dot(dist, worldTangent);\n        sub(centerDist, worldVertex0, convexOffset);\n\n        sub(convexToparticle, particleOffset, convexOffset);\n\n        vec2.sub(candidateDist,worldVertex0,particleOffset);\n        var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));\n\n        if(candidateDistance < minCandidateDistance){\n            minCandidateDistance = candidateDistance;\n            vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);\n            vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);\n            vec2.copy(minEdgeNormal,worldTangent);\n            found = true;\n        }\n    }\n\n    if(found){\n        var c = this.createContactEquation(particleBody,convexBody,particleShape,convexShape);\n\n        vec2.scale(c.normalA, minEdgeNormal, -1);\n        vec2.normalize(c.normalA, c.normalA);\n\n        // Particle has no extent to the contact point\n        vec2.set(c.contactPointA,  0, 0);\n        add(c.contactPointA, c.contactPointA, particleOffset);\n        sub(c.contactPointA, c.contactPointA, particleBody.position);\n\n        // From convex center to point\n        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n        add(c.contactPointB, c.contactPointB, convexOffset);\n        sub(c.contactPointB, c.contactPointB, convexBody.position);\n\n        this.contactEquations.push(c);\n\n        if(this.enableFriction){\n            this.frictionEquations.push( this.createFrictionFromContact(c) );\n        }\n\n        return 1;\n    }\n\n\n    return 0;\n};\n\n/**\n * Circle/circle Narrowphase\n * @method circleCircle\n * @param  {Body} bodyA\n * @param  {Circle} shapeA\n * @param  {Array} offsetA\n * @param  {Number} angleA\n * @param  {Body} bodyB\n * @param  {Circle} shapeB\n * @param  {Array} offsetB\n * @param  {Number} angleB\n * @param {Boolean} justTest\n * @param {Number} [radiusA] Optional radius to use for shapeA\n * @param {Number} [radiusB] Optional radius to use for shapeB\n */\nNarrowphase.prototype[Shape.CIRCLE] =\nNarrowphase.prototype.circleCircle = function(\n    bodyA,\n    shapeA,\n    offsetA,\n    angleA,\n    bodyB,\n    shapeB,\n    offsetB,\n    angleB,\n    justTest,\n    radiusA,\n    radiusB\n){\n\n    var dist = tmp1,\n        radiusA = radiusA || shapeA.radius,\n        radiusB = radiusB || shapeB.radius;\n\n    sub(dist,offsetA,offsetB);\n    var r = radiusA + radiusB;\n    if(vec2.squaredLength(dist) > Math.pow(r,2)){\n        return 0;\n    }\n\n    if(justTest){\n        return true;\n    }\n\n    var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);\n    sub(c.normalA, offsetB, offsetA);\n    vec2.normalize(c.normalA,c.normalA);\n\n    vec2.scale( c.contactPointA, c.normalA,  radiusA);\n    vec2.scale( c.contactPointB, c.normalA, -radiusB);\n\n    add(c.contactPointA, c.contactPointA, offsetA);\n    sub(c.contactPointA, c.contactPointA, bodyA.position);\n\n    add(c.contactPointB, c.contactPointB, offsetB);\n    sub(c.contactPointB, c.contactPointB, bodyB.position);\n\n    this.contactEquations.push(c);\n\n    if(this.enableFriction){\n        this.frictionEquations.push(this.createFrictionFromContact(c));\n    }\n    return 1;\n};\n\n/**\n * Plane/Convex Narrowphase\n * @method planeConvex\n * @param  {Body} planeBody\n * @param  {Plane} planeShape\n * @param  {Array} planeOffset\n * @param  {Number} planeAngle\n * @param  {Body} convexBody\n * @param  {Convex} convexShape\n * @param  {Array} convexOffset\n * @param  {Number} convexAngle\n * @param {Boolean} justTest\n */\nNarrowphase.prototype[Shape.PLANE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.PLANE | Shape.BOX] =\nNarrowphase.prototype.planeConvex = function(\n    planeBody,\n    planeShape,\n    planeOffset,\n    planeAngle,\n    convexBody,\n    convexShape,\n    convexOffset,\n    convexAngle,\n    justTest\n){\n    var worldVertex = tmp1,\n        worldNormal = tmp2,\n        dist = tmp3;\n\n    var numReported = 0;\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    for(var i=0; i!==convexShape.vertices.length; i++){\n        var v = convexShape.vertices[i];\n        vec2.rotate(worldVertex, v, convexAngle);\n        add(worldVertex, worldVertex, convexOffset);\n\n        sub(dist, worldVertex, planeOffset);\n\n        if(dot(dist,worldNormal) <= 0){\n\n            if(justTest){\n                return true;\n            }\n\n            // Found vertex\n            numReported++;\n\n            var c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);\n\n            sub(dist, worldVertex, planeOffset);\n\n            vec2.copy(c.normalA, worldNormal);\n\n            var d = dot(dist, c.normalA);\n            vec2.scale(dist, c.normalA, d);\n\n            // rj is from convex center to contact\n            sub(c.contactPointB, worldVertex, convexBody.position);\n\n\n            // ri is from plane center to contact\n            sub( c.contactPointA, worldVertex, dist);\n            sub( c.contactPointA, c.contactPointA, planeBody.position);\n\n            this.contactEquations.push(c);\n\n            if(!this.enableFrictionReduction){\n                if(this.enableFriction){\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n                }\n            }\n        }\n    }\n\n    if(this.enableFrictionReduction){\n        if(this.enableFriction && numReported){\n            this.frictionEquations.push(this.createFrictionFromAverage(numReported));\n        }\n    }\n\n    return numReported;\n};\n\n/**\n * Narrowphase for particle vs plane\n * @method particlePlane\n * @param  {Body}       particleBody\n * @param  {Particle}   particleShape\n * @param  {Array}      particleOffset\n * @param  {Number}     particleAngle\n * @param  {Body}       planeBody\n * @param  {Plane}      planeShape\n * @param  {Array}      planeOffset\n * @param  {Number}     planeAngle\n * @param {Boolean}     justTest\n */\nNarrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =\nNarrowphase.prototype.particlePlane = function(\n    particleBody,\n    particleShape,\n    particleOffset,\n    particleAngle,\n    planeBody,\n    planeShape,\n    planeOffset,\n    planeAngle,\n    justTest\n){\n    var dist = tmp1,\n        worldNormal = tmp2;\n\n    planeAngle = planeAngle || 0;\n\n    sub(dist, particleOffset, planeOffset);\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    var d = dot(dist, worldNormal);\n\n    if(d > 0){\n        return 0;\n    }\n    if(justTest){\n        return true;\n    }\n\n    var c = this.createContactEquation(planeBody,particleBody,planeShape,particleShape);\n\n    vec2.copy(c.normalA, worldNormal);\n    vec2.scale( dist, c.normalA, d );\n    // dist is now the distance vector in the normal direction\n\n    // ri is the particle position projected down onto the plane, from the plane center\n    sub( c.contactPointA, particleOffset, dist);\n    sub( c.contactPointA, c.contactPointA, planeBody.position);\n\n    // rj is from the body center to the particle center\n    sub( c.contactPointB, particleOffset, particleBody.position );\n\n    this.contactEquations.push(c);\n\n    if(this.enableFriction){\n        this.frictionEquations.push(this.createFrictionFromContact(c));\n    }\n    return 1;\n};\n\n/**\n * Circle/Particle Narrowphase\n * @method circleParticle\n * @param  {Body} circleBody\n * @param  {Circle} circleShape\n * @param  {Array} circleOffset\n * @param  {Number} circleAngle\n * @param  {Body} particleBody\n * @param  {Particle} particleShape\n * @param  {Array} particleOffset\n * @param  {Number} particleAngle\n * @param  {Boolean} justTest\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =\nNarrowphase.prototype.circleParticle = function(\n    circleBody,\n    circleShape,\n    circleOffset,\n    circleAngle,\n    particleBody,\n    particleShape,\n    particleOffset,\n    particleAngle,\n    justTest\n){\n    var dist = tmp1;\n\n    sub(dist, particleOffset, circleOffset);\n    if(vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)){\n        return 0;\n    }\n    if(justTest){\n        return true;\n    }\n\n    var c = this.createContactEquation(circleBody,particleBody,circleShape,particleShape);\n    vec2.copy(c.normalA, dist);\n    vec2.normalize(c.normalA,c.normalA);\n\n    // Vector from circle to contact point is the normal times the circle radius\n    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);\n    add(c.contactPointA, c.contactPointA, circleOffset);\n    sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n    // Vector from particle center to contact point is zero\n    sub(c.contactPointB, particleOffset, particleBody.position);\n\n    this.contactEquations.push(c);\n\n    if(this.enableFriction){\n        this.frictionEquations.push(this.createFrictionFromContact(c));\n    }\n\n    return 1;\n};\n\nvar planeCapsule_tmpCircle = new Circle({ radius: 1 }),\n    planeCapsule_tmp1 = vec2.create(),\n    planeCapsule_tmp2 = vec2.create(),\n    planeCapsule_tmp3 = vec2.create();\n\n/**\n * @method planeCapsule\n * @param  {Body} planeBody\n * @param  {Circle} planeShape\n * @param  {Array} planeOffset\n * @param  {Number} planeAngle\n * @param  {Body} capsuleBody\n * @param  {Particle} capsuleShape\n * @param  {Array} capsuleOffset\n * @param  {Number} capsuleAngle\n * @param {Boolean} justTest\n */\nNarrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =\nNarrowphase.prototype.planeCapsule = function(\n    planeBody,\n    planeShape,\n    planeOffset,\n    planeAngle,\n    capsuleBody,\n    capsuleShape,\n    capsuleOffset,\n    capsuleAngle,\n    justTest\n){\n    var end1 = planeCapsule_tmp1,\n        end2 = planeCapsule_tmp2,\n        circle = planeCapsule_tmpCircle,\n        dst = planeCapsule_tmp3;\n\n    // Compute world end positions\n    vec2.set(end1, -capsuleShape.length/2, 0);\n    vec2.rotate(end1,end1,capsuleAngle);\n    add(end1,end1,capsuleOffset);\n\n    vec2.set(end2,  capsuleShape.length/2, 0);\n    vec2.rotate(end2,end2,capsuleAngle);\n    add(end2,end2,capsuleOffset);\n\n    circle.radius = capsuleShape.radius;\n\n    var enableFrictionBefore;\n\n    // Temporarily turn off friction\n    if(this.enableFrictionReduction){\n        enableFrictionBefore = this.enableFriction;\n        this.enableFriction = false;\n    }\n\n    // Do Narrowphase as two circles\n    var numContacts1 = this.circlePlane(capsuleBody,circle,end1,0, planeBody,planeShape,planeOffset,planeAngle, justTest),\n        numContacts2 = this.circlePlane(capsuleBody,circle,end2,0, planeBody,planeShape,planeOffset,planeAngle, justTest);\n\n    // Restore friction\n    if(this.enableFrictionReduction){\n        this.enableFriction = enableFrictionBefore;\n    }\n\n    if(justTest){\n        return numContacts1 || numContacts2;\n    } else {\n        var numTotal = numContacts1 + numContacts2;\n        if(this.enableFrictionReduction){\n            if(numTotal){\n                this.frictionEquations.push(this.createFrictionFromAverage(numTotal));\n            }\n        }\n        return numTotal;\n    }\n};\n\n/**\n * Creates ContactEquations and FrictionEquations for a collision.\n * @method circlePlane\n * @param  {Body}    bi     The first body that should be connected to the equations.\n * @param  {Circle}  si     The circle shape participating in the collision.\n * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.\n * @param  {Body}    bj     The second body that should be connected to the equations.\n * @param  {Plane}   sj     The Plane shape that is participating\n * @param  {Array}   xj     Extra offset for the plane shape.\n * @param  {Number}  aj     Extra angle to apply to the plane\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =\nNarrowphase.prototype.circlePlane = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){\n    var circleBody = bi,\n        circleShape = si,\n        circleOffset = xi, // Offset from body center, rotated!\n        planeBody = bj,\n        shapeB = sj,\n        planeOffset = xj,\n        planeAngle = aj;\n\n    planeAngle = planeAngle || 0;\n\n    // Vector from plane to circle\n    var planeToCircle = tmp1,\n        worldNormal = tmp2,\n        temp = tmp3;\n\n    sub(planeToCircle, circleOffset, planeOffset);\n\n    // World plane normal\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    // Normal direction distance\n    var d = dot(worldNormal, planeToCircle);\n\n    if(d > circleShape.radius){\n        return 0; // No overlap. Abort.\n    }\n\n    if(justTest){\n        return true;\n    }\n\n    // Create contact\n    var contact = this.createContactEquation(planeBody,circleBody,sj,si);\n\n    // ni is the plane world normal\n    vec2.copy(contact.normalA, worldNormal);\n\n    // rj is the vector from circle center to the contact point\n    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);\n    add(contact.contactPointB, contact.contactPointB, circleOffset);\n    sub(contact.contactPointB, contact.contactPointB, circleBody.position);\n\n    // ri is the distance from plane center to contact.\n    vec2.scale(temp, contact.normalA, d);\n    sub(contact.contactPointA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector\n    add(contact.contactPointA, contact.contactPointA, planeOffset);\n    sub(contact.contactPointA, contact.contactPointA, planeBody.position);\n\n    this.contactEquations.push(contact);\n\n    if(this.enableFriction){\n        this.frictionEquations.push( this.createFrictionFromContact(contact) );\n    }\n\n    return 1;\n};\n\n/**\n * Convex/convex Narrowphase.See <a href=\"http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/\">this article</a> for more info.\n * @method convexConvex\n * @param  {Body} bi\n * @param  {Convex} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Convex} sj\n * @param  {Array} xj\n * @param  {Number} aj\n */\nNarrowphase.prototype[Shape.CONVEX] =\nNarrowphase.prototype[Shape.CONVEX | Shape.BOX] =\nNarrowphase.prototype[Shape.BOX] =\nNarrowphase.prototype.convexConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, precision ){\n    var sepAxis = tmp1,\n        worldPoint = tmp2,\n        worldPoint0 = tmp3,\n        worldPoint1 = tmp4,\n        worldEdge = tmp5,\n        projected = tmp6,\n        penetrationVec = tmp7,\n        dist = tmp8,\n        worldNormal = tmp9,\n        numContacts = 0,\n        precision = typeof(precision) === 'number' ? precision : 0;\n\n    var found = Narrowphase.findSeparatingAxis(si,xi,ai,sj,xj,aj,sepAxis);\n    if(!found){\n        return 0;\n    }\n\n    // Make sure the separating axis is directed from shape i to shape j\n    sub(dist,xj,xi);\n    if(dot(sepAxis,dist) > 0){\n        vec2.scale(sepAxis,sepAxis,-1);\n    }\n\n    // Find edges with normals closest to the separating axis\n    var closestEdge1 = Narrowphase.getClosestEdge(si,ai,sepAxis,true), // Flipped axis\n        closestEdge2 = Narrowphase.getClosestEdge(sj,aj,sepAxis);\n\n    if(closestEdge1 === -1 || closestEdge2 === -1){\n        return 0;\n    }\n\n    // Loop over the shapes\n    for(var k=0; k<2; k++){\n\n        var closestEdgeA = closestEdge1,\n            closestEdgeB = closestEdge2,\n            shapeA =  si, shapeB =  sj,\n            offsetA = xi, offsetB = xj,\n            angleA = ai, angleB = aj,\n            bodyA = bi, bodyB = bj;\n\n        if(k === 0){\n            // Swap!\n            var tmp;\n            tmp = closestEdgeA;\n            closestEdgeA = closestEdgeB;\n            closestEdgeB = tmp;\n\n            tmp = shapeA;\n            shapeA = shapeB;\n            shapeB = tmp;\n\n            tmp = offsetA;\n            offsetA = offsetB;\n            offsetB = tmp;\n\n            tmp = angleA;\n            angleA = angleB;\n            angleB = tmp;\n\n            tmp = bodyA;\n            bodyA = bodyB;\n            bodyB = tmp;\n        }\n\n        // Loop over 2 points in convex B\n        for(var j=closestEdgeB; j<closestEdgeB+2; j++){\n\n            // Get world point\n            var v = shapeB.vertices[(j+shapeB.vertices.length)%shapeB.vertices.length];\n            vec2.rotate(worldPoint, v, angleB);\n            add(worldPoint, worldPoint, offsetB);\n\n            var insideNumEdges = 0;\n\n            // Loop over the 3 closest edges in convex A\n            for(var i=closestEdgeA-1; i<closestEdgeA+2; i++){\n\n                var v0 = shapeA.vertices[(i  +shapeA.vertices.length)%shapeA.vertices.length],\n                    v1 = shapeA.vertices[(i+1+shapeA.vertices.length)%shapeA.vertices.length];\n\n                // Construct the edge\n                vec2.rotate(worldPoint0, v0, angleA);\n                vec2.rotate(worldPoint1, v1, angleA);\n                add(worldPoint0, worldPoint0, offsetA);\n                add(worldPoint1, worldPoint1, offsetA);\n\n                sub(worldEdge, worldPoint1, worldPoint0);\n\n                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1\n                vec2.normalize(worldNormal,worldNormal);\n\n                sub(dist, worldPoint, worldPoint0);\n\n                var d = dot(worldNormal,dist);\n\n                if((i === closestEdgeA && d <= precision) || (i !== closestEdgeA && d <= 0)){\n                    insideNumEdges++;\n                }\n            }\n\n            if(insideNumEdges >= 3){\n\n                if(justTest){\n                    return true;\n                }\n\n                // worldPoint was on the \"inside\" side of each of the 3 checked edges.\n                // Project it to the center edge and use the projection direction as normal\n\n                // Create contact\n                var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);\n                numContacts++;\n\n                // Get center edge from body A\n                var v0 = shapeA.vertices[(closestEdgeA)   % shapeA.vertices.length],\n                    v1 = shapeA.vertices[(closestEdgeA+1) % shapeA.vertices.length];\n\n                // Construct the edge\n                vec2.rotate(worldPoint0, v0, angleA);\n                vec2.rotate(worldPoint1, v1, angleA);\n                add(worldPoint0, worldPoint0, offsetA);\n                add(worldPoint1, worldPoint1, offsetA);\n\n                sub(worldEdge, worldPoint1, worldPoint0);\n\n                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A\n                vec2.normalize(c.normalA,c.normalA);\n\n                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point\n                var d = dot(c.normalA,dist);             // Penetration\n                vec2.scale(penetrationVec, c.normalA, d);     // Vector penetration\n\n                sub(c.contactPointA, worldPoint, offsetA);\n                sub(c.contactPointA, c.contactPointA, penetrationVec);\n                add(c.contactPointA, c.contactPointA, offsetA);\n                sub(c.contactPointA, c.contactPointA, bodyA.position);\n\n                sub(c.contactPointB, worldPoint, offsetB);\n                add(c.contactPointB, c.contactPointB, offsetB);\n                sub(c.contactPointB, c.contactPointB, bodyB.position);\n\n                this.contactEquations.push(c);\n\n                // Todo reduce to 1 friction equation if we have 2 contact points\n                if(!this.enableFrictionReduction){\n                    if(this.enableFriction){\n                        this.frictionEquations.push(this.createFrictionFromContact(c));\n                    }\n                }\n            }\n        }\n    }\n\n    if(this.enableFrictionReduction){\n        if(this.enableFriction && numContacts){\n            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));\n        }\n    }\n\n    return numContacts;\n};\n\n// .projectConvex is called by other functions, need local tmp vectors\nvar pcoa_tmp1 = vec2.fromValues(0,0);\n\n/**\n * Project a Convex onto a world-oriented axis\n * @method projectConvexOntoAxis\n * @static\n * @param  {Convex} convexShape\n * @param  {Array} convexOffset\n * @param  {Number} convexAngle\n * @param  {Array} worldAxis\n * @param  {Array} result\n */\nNarrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result){\n    var max=null,\n        min=null,\n        v,\n        value,\n        localAxis = pcoa_tmp1;\n\n    // Convert the axis to local coords of the body\n    vec2.rotate(localAxis, worldAxis, -convexAngle);\n\n    // Get projected position of all vertices\n    for(var i=0; i<convexShape.vertices.length; i++){\n        v = convexShape.vertices[i];\n        value = dot(v,localAxis);\n        if(max === null || value > max){\n            max = value;\n        }\n        if(min === null || value < min){\n            min = value;\n        }\n    }\n\n    if(min > max){\n        var t = min;\n        min = max;\n        max = t;\n    }\n\n    // Project the position of the body onto the axis - need to add this to the result\n    var offset = dot(convexOffset, worldAxis);\n\n    vec2.set( result, min + offset, max + offset);\n};\n\n// .findSeparatingAxis is called by other functions, need local tmp vectors\nvar fsa_tmp1 = vec2.fromValues(0,0)\n,   fsa_tmp2 = vec2.fromValues(0,0)\n,   fsa_tmp3 = vec2.fromValues(0,0)\n,   fsa_tmp4 = vec2.fromValues(0,0)\n,   fsa_tmp5 = vec2.fromValues(0,0)\n,   fsa_tmp6 = vec2.fromValues(0,0);\n\n/**\n * Find a separating axis between the shapes, that maximizes the separating distance between them.\n * @method findSeparatingAxis\n * @static\n * @param  {Convex}     c1\n * @param  {Array}      offset1\n * @param  {Number}     angle1\n * @param  {Convex}     c2\n * @param  {Array}      offset2\n * @param  {Number}     angle2\n * @param  {Array}      sepAxis     The resulting axis\n * @return {Boolean}                Whether the axis could be found.\n */\nNarrowphase.findSeparatingAxis = function(c1,offset1,angle1,c2,offset2,angle2,sepAxis){\n    var maxDist = null,\n        overlap = false,\n        found = false,\n        edge = fsa_tmp1,\n        worldPoint0 = fsa_tmp2,\n        worldPoint1 = fsa_tmp3,\n        normal = fsa_tmp4,\n        span1 = fsa_tmp5,\n        span2 = fsa_tmp6;\n\n    if(c1 instanceof Box && c2 instanceof Box){\n\n        for(var j=0; j!==2; j++){\n            var c = c1,\n                angle = angle1;\n            if(j===1){\n                c = c2;\n                angle = angle2;\n            }\n\n            for(var i=0; i!==2; i++){\n\n                // Get the world edge\n                if(i === 0){\n                    vec2.set(normal, 0, 1);\n                } else if(i === 1) {\n                    vec2.set(normal, 1, 0);\n                }\n                if(angle !== 0){\n                    vec2.rotate(normal, normal, angle);\n                }\n\n                // Project hulls onto that normal\n                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);\n                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);\n\n                // Order by span position\n                var a=span1,\n                    b=span2,\n                    swapped = false;\n                if(span1[0] > span2[0]){\n                    b=span1;\n                    a=span2;\n                    swapped = true;\n                }\n\n                // Get separating distance\n                var dist = b[0] - a[1];\n                overlap = (dist <= 0);\n\n                if(maxDist===null || dist > maxDist){\n                    vec2.copy(sepAxis, normal);\n                    maxDist = dist;\n                    found = overlap;\n                }\n            }\n        }\n\n    } else {\n\n        for(var j=0; j!==2; j++){\n            var c = c1,\n                angle = angle1;\n            if(j===1){\n                c = c2;\n                angle = angle2;\n            }\n\n            for(var i=0; i!==c.vertices.length; i++){\n                // Get the world edge\n                vec2.rotate(worldPoint0, c.vertices[i], angle);\n                vec2.rotate(worldPoint1, c.vertices[(i+1)%c.vertices.length], angle);\n\n                sub(edge, worldPoint1, worldPoint0);\n\n                // Get normal - just rotate 90 degrees since vertices are given in CCW\n                vec2.rotate90cw(normal, edge);\n                vec2.normalize(normal,normal);\n\n                // Project hulls onto that normal\n                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);\n                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);\n\n                // Order by span position\n                var a=span1,\n                    b=span2,\n                    swapped = false;\n                if(span1[0] > span2[0]){\n                    b=span1;\n                    a=span2;\n                    swapped = true;\n                }\n\n                // Get separating distance\n                var dist = b[0] - a[1];\n                overlap = (dist <= 0);\n\n                if(maxDist===null || dist > maxDist){\n                    vec2.copy(sepAxis, normal);\n                    maxDist = dist;\n                    found = overlap;\n                }\n            }\n        }\n    }\n\n\n    /*\n    // Needs to be tested some more\n    for(var j=0; j!==2; j++){\n        var c = c1,\n            angle = angle1;\n        if(j===1){\n            c = c2;\n            angle = angle2;\n        }\n\n        for(var i=0; i!==c.axes.length; i++){\n\n            var normal = c.axes[i];\n\n            // Project hulls onto that normal\n            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);\n            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);\n\n            // Order by span position\n            var a=span1,\n                b=span2,\n                swapped = false;\n            if(span1[0] > span2[0]){\n                b=span1;\n                a=span2;\n                swapped = true;\n            }\n\n            // Get separating distance\n            var dist = b[0] - a[1];\n            overlap = (dist <= Narrowphase.convexPrecision);\n\n            if(maxDist===null || dist > maxDist){\n                vec2.copy(sepAxis, normal);\n                maxDist = dist;\n                found = overlap;\n            }\n        }\n    }\n    */\n\n    return found;\n};\n\n// .getClosestEdge is called by other functions, need local tmp vectors\nvar gce_tmp1 = vec2.fromValues(0,0)\n,   gce_tmp2 = vec2.fromValues(0,0)\n,   gce_tmp3 = vec2.fromValues(0,0);\n\n/**\n * Get the edge that has a normal closest to an axis.\n * @method getClosestEdge\n * @static\n * @param  {Convex}     c\n * @param  {Number}     angle\n * @param  {Array}      axis\n * @param  {Boolean}    flip\n * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.\n */\nNarrowphase.getClosestEdge = function(c,angle,axis,flip){\n    var localAxis = gce_tmp1,\n        edge = gce_tmp2,\n        normal = gce_tmp3;\n\n    // Convert the axis to local coords of the body\n    vec2.rotate(localAxis, axis, -angle);\n    if(flip){\n        vec2.scale(localAxis,localAxis,-1);\n    }\n\n    var closestEdge = -1,\n        N = c.vertices.length,\n        maxDot = -1;\n    for(var i=0; i!==N; i++){\n        // Get the edge\n        sub(edge, c.vertices[(i+1)%N], c.vertices[i%N]);\n\n        // Get normal - just rotate 90 degrees since vertices are given in CCW\n        vec2.rotate90cw(normal, edge);\n        vec2.normalize(normal,normal);\n\n        var d = dot(normal,localAxis);\n        if(closestEdge === -1 || d > maxDot){\n            closestEdge = i % N;\n            maxDot = d;\n        }\n    }\n\n    return closestEdge;\n};\n\nvar circleHeightfield_candidate = vec2.create(),\n    circleHeightfield_dist = vec2.create(),\n    circleHeightfield_v0 = vec2.create(),\n    circleHeightfield_v1 = vec2.create(),\n    circleHeightfield_minCandidate = vec2.create(),\n    circleHeightfield_worldNormal = vec2.create(),\n    circleHeightfield_minCandidateNormal = vec2.create();\n\n/**\n * @method circleHeightfield\n * @param  {Body}           bi\n * @param  {Circle}         si\n * @param  {Array}          xi\n * @param  {Body}           bj\n * @param  {Heightfield}    sj\n * @param  {Array}          xj\n * @param  {Number}         aj\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =\nNarrowphase.prototype.circleHeightfield = function( circleBody,circleShape,circlePos,circleAngle,\n                                                    hfBody,hfShape,hfPos,hfAngle, justTest, radius ){\n    var data = hfShape.heights,\n        radius = radius || circleShape.radius,\n        w = hfShape.elementWidth,\n        dist = circleHeightfield_dist,\n        candidate = circleHeightfield_candidate,\n        minCandidate = circleHeightfield_minCandidate,\n        minCandidateNormal = circleHeightfield_minCandidateNormal,\n        worldNormal = circleHeightfield_worldNormal,\n        v0 = circleHeightfield_v0,\n        v1 = circleHeightfield_v1;\n\n    // Get the index of the points to test against\n    var idxA = Math.floor( (circlePos[0] - radius - hfPos[0]) / w ),\n        idxB = Math.ceil(  (circlePos[0] + radius - hfPos[0]) / w );\n\n    /*if(idxB < 0 || idxA >= data.length)\n        return justTest ? false : 0;*/\n\n    if(idxA < 0){\n        idxA = 0;\n    }\n    if(idxB >= data.length){\n        idxB = data.length-1;\n    }\n\n    // Get max and min\n    var max = data[idxA],\n        min = data[idxB];\n    for(var i=idxA; i<idxB; i++){\n        if(data[i] < min){\n            min = data[i];\n        }\n        if(data[i] > max){\n            max = data[i];\n        }\n    }\n\n    if(circlePos[1]-radius > max){\n        return justTest ? false : 0;\n    }\n\n    /*\n    if(circlePos[1]+radius < min){\n        // Below the minimum point... We can just guess.\n        // TODO\n    }\n    */\n\n    // 1. Check so center of circle is not inside the field. If it is, this wont work...\n    // 2. For each edge\n    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)\n    // 2. 2. Check if point is inside.\n\n    var found = false;\n\n    // Check all edges first\n    for(var i=idxA; i<idxB; i++){\n\n        // Get points\n        vec2.set(v0,     i*w, data[i]  );\n        vec2.set(v1, (i+1)*w, data[i+1]);\n        vec2.add(v0,v0,hfPos);\n        vec2.add(v1,v1,hfPos);\n\n        // Get normal\n        vec2.sub(worldNormal, v1, v0);\n        vec2.rotate(worldNormal, worldNormal, Math.PI/2);\n        vec2.normalize(worldNormal,worldNormal);\n\n        // Get point on circle, closest to the edge\n        vec2.scale(candidate,worldNormal,-radius);\n        vec2.add(candidate,candidate,circlePos);\n\n        // Distance from v0 to the candidate point\n        vec2.sub(dist,candidate,v0);\n\n        // Check if it is in the element \"stick\"\n        var d = vec2.dot(dist,worldNormal);\n        if(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){\n\n            if(justTest){\n                return true;\n            }\n\n            found = true;\n\n            // Store the candidate point, projected to the edge\n            vec2.scale(dist,worldNormal,-d);\n            vec2.add(minCandidate,candidate,dist);\n            vec2.copy(minCandidateNormal,worldNormal);\n\n            var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);\n\n            // Normal is out of the heightfield\n            vec2.copy(c.normalA, minCandidateNormal);\n\n            // Vector from circle to heightfield\n            vec2.scale(c.contactPointB,  c.normalA, -radius);\n            add(c.contactPointB, c.contactPointB, circlePos);\n            sub(c.contactPointB, c.contactPointB, circleBody.position);\n\n            vec2.copy(c.contactPointA, minCandidate);\n            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);\n\n            this.contactEquations.push(c);\n\n            if(this.enableFriction){\n                this.frictionEquations.push( this.createFrictionFromContact(c) );\n            }\n        }\n    }\n\n    // Check all vertices\n    found = false;\n    if(radius > 0){\n        for(var i=idxA; i<=idxB; i++){\n\n            // Get point\n            vec2.set(v0, i*w, data[i]);\n            vec2.add(v0,v0,hfPos);\n\n            vec2.sub(dist, circlePos, v0);\n\n            if(vec2.squaredLength(dist) < Math.pow(radius, 2)){\n\n                if(justTest){\n                    return true;\n                }\n\n                found = true;\n\n                var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);\n\n                // Construct normal - out of heightfield\n                vec2.copy(c.normalA, dist);\n                vec2.normalize(c.normalA,c.normalA);\n\n                vec2.scale(c.contactPointB, c.normalA, -radius);\n                add(c.contactPointB, c.contactPointB, circlePos);\n                sub(c.contactPointB, c.contactPointB, circleBody.position);\n\n                sub(c.contactPointA, v0, hfPos);\n                add(c.contactPointA, c.contactPointA, hfPos);\n                sub(c.contactPointA, c.contactPointA, hfBody.position);\n\n                this.contactEquations.push(c);\n\n                if(this.enableFriction){\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n                }\n            }\n        }\n    }\n\n    if(found){\n        return 1;\n    }\n\n    return 0;\n\n};\n\nvar convexHeightfield_v0 = vec2.create(),\n    convexHeightfield_v1 = vec2.create(),\n    convexHeightfield_tilePos = vec2.create(),\n    convexHeightfield_tempConvexShape = new Convex({ vertices: [vec2.create(),vec2.create(),vec2.create(),vec2.create()] });\n/**\n * @method circleHeightfield\n * @param  {Body}           bi\n * @param  {Circle}         si\n * @param  {Array}          xi\n * @param  {Body}           bj\n * @param  {Heightfield}    sj\n * @param  {Array}          xj\n * @param  {Number}         aj\n */\nNarrowphase.prototype[Shape.BOX | Shape.HEIGHTFIELD] =\nNarrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =\nNarrowphase.prototype.convexHeightfield = function( convexBody,convexShape,convexPos,convexAngle,\n                                                    hfBody,hfShape,hfPos,hfAngle, justTest ){\n    var data = hfShape.heights,\n        w = hfShape.elementWidth,\n        v0 = convexHeightfield_v0,\n        v1 = convexHeightfield_v1,\n        tilePos = convexHeightfield_tilePos,\n        tileConvex = convexHeightfield_tempConvexShape;\n\n    // Get the index of the points to test against\n    var idxA = Math.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ),\n        idxB = Math.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w );\n\n    if(idxA < 0){\n        idxA = 0;\n    }\n    if(idxB >= data.length){\n        idxB = data.length-1;\n    }\n\n    // Get max and min\n    var max = data[idxA],\n        min = data[idxB];\n    for(var i=idxA; i<idxB; i++){\n        if(data[i] < min){\n            min = data[i];\n        }\n        if(data[i] > max){\n            max = data[i];\n        }\n    }\n\n    if(convexBody.aabb.lowerBound[1] > max){\n        return justTest ? false : 0;\n    }\n\n    var found = false;\n    var numContacts = 0;\n\n    // Loop over all edges\n    // TODO: If possible, construct a convex from several data points (need o check if the points make a convex shape)\n    for(var i=idxA; i<idxB; i++){\n\n        // Get points\n        vec2.set(v0,     i*w, data[i]  );\n        vec2.set(v1, (i+1)*w, data[i+1]);\n        vec2.add(v0,v0,hfPos);\n        vec2.add(v1,v1,hfPos);\n\n        // Construct a convex\n        var tileHeight = 100; // todo\n        vec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);\n\n        vec2.sub(tileConvex.vertices[0], v1, tilePos);\n        vec2.sub(tileConvex.vertices[1], v0, tilePos);\n        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);\n        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);\n        tileConvex.vertices[2][1] -= tileHeight;\n        tileConvex.vertices[3][1] -= tileHeight;\n\n        // Do convex collision\n        numContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,\n                                            hfBody, tileConvex, tilePos, 0, justTest);\n    }\n\n    return numContacts;\n};","module.exports = Ray;\n\nvar vec2 = require('../math/vec2');\nvar RaycastResult = require('../collision/RaycastResult');\nvar Shape = require('../shapes/Shape');\nvar AABB = require('../collision/AABB');\n\n/**\n * A line with a start and end point that is used to intersect shapes. For an example, see {{#crossLink \"World/raycast:method\"}}World.raycast{{/crossLink}}\n * @class Ray\n * @constructor\n * @param {object} [options]\n * @param {array} [options.from]\n * @param {array} [options.to]\n * @param {boolean} [options.checkCollisionResponse=true]\n * @param {boolean} [options.skipBackfaces=false]\n * @param {number} [options.collisionMask=-1]\n * @param {number} [options.collisionGroup=-1]\n * @param {number} [options.mode=Ray.ANY]\n * @param {number} [options.callback]\n */\nfunction Ray(options){\n    options = options || {};\n\n    /**\n     * Ray start point.\n     * @property {array} from\n     */\n    this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();\n\n    /**\n     * Ray end point\n     * @property {array} to\n     */\n    this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();\n\n    /**\n     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.\n     * @property {Boolean} checkCollisionResponse\n     */\n    this.checkCollisionResponse = options.checkCollisionResponse !== undefined ? options.checkCollisionResponse : true;\n\n    /**\n     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.\n     * @property {Boolean} skipBackfaces\n     */\n    this.skipBackfaces = !!options.skipBackfaces;\n\n    /**\n     * @property {number} collisionMask\n     * @default -1\n     */\n    this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : -1;\n\n    /**\n     * @property {number} collisionGroup\n     * @default -1\n     */\n    this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : -1;\n\n    /**\n     * The intersection mode. Should be {{#crossLink \"Ray/ANY:property\"}}Ray.ANY{{/crossLink}}, {{#crossLink \"Ray/ALL:property\"}}Ray.ALL{{/crossLink}} or {{#crossLink \"Ray/CLOSEST:property\"}}Ray.CLOSEST{{/crossLink}}.\n     * @property {number} mode\n     */\n    this.mode = options.mode !== undefined ? options.mode : Ray.ANY;\n\n    /**\n     * Current, user-provided result callback. Will be used if mode is Ray.ALL.\n     * @property {Function} callback\n     */\n    this.callback = options.callback || function(result){};\n\n    /**\n     * @readOnly\n     * @property {array} direction\n     */\n    this.direction = vec2.create();\n\n    /**\n     * Length of the ray\n     * @readOnly\n     * @property {number} length\n     */\n    this.length = 1;\n\n    this.update();\n}\nRay.prototype.constructor = Ray;\n\n/**\n * This raycasting mode will make the Ray traverse through all intersection points and only return the closest one.\n * @static\n * @property {Number} CLOSEST\n */\nRay.CLOSEST = 1;\n\n/**\n * This raycasting mode will make the Ray stop when it finds the first intersection point.\n * @static\n * @property {Number} ANY\n */\nRay.ANY = 2;\n\n/**\n * This raycasting mode will traverse all intersection points and executes a callback for each one.\n * @static\n * @property {Number} ALL\n */\nRay.ALL = 4;\n\n/**\n * Should be called if you change the from or to point.\n * @method update\n */\nRay.prototype.update = function(){\n\n    // Update .direction and .length\n    var d = this.direction;\n    vec2.sub(d, this.to, this.from);\n    this.length = vec2.length(d);\n    vec2.normalize(d, d);\n\n};\n\n/**\n * @method intersectBodies\n * @param {Array} bodies An array of Body objects.\n */\nRay.prototype.intersectBodies = function (result, bodies) {\n    for (var i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++) {\n        var body = bodies[i];\n        var aabb = body.getAABB();\n        if(aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)){\n            this.intersectBody(result, body);\n        }\n    }\n};\n\nvar intersectBody_worldPosition = vec2.create();\n\n/**\n * Shoot a ray at a body, get back information about the hit.\n * @method intersectBody\n * @private\n * @param {Body} body\n */\nRay.prototype.intersectBody = function (result, body) {\n    var checkCollisionResponse = this.checkCollisionResponse;\n\n    if(checkCollisionResponse && !body.collisionResponse){\n        return;\n    }\n\n    var worldPosition = intersectBody_worldPosition;\n\n    for (var i = 0, N = body.shapes.length; i < N; i++) {\n        var shape = body.shapes[i];\n\n        if(checkCollisionResponse && !shape.collisionResponse){\n            continue; // Skip\n        }\n\n        if((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0){\n            continue;\n        }\n\n        // Get world angle and position of the shape\n        vec2.rotate(worldPosition, shape.position, body.angle);\n        vec2.add(worldPosition, worldPosition, body.position);\n        var worldAngle = shape.angle + body.angle;\n\n        this.intersectShape(\n            result,\n            shape,\n            worldAngle,\n            worldPosition,\n            body\n        );\n\n        if(result.shouldStop(this)){\n            break;\n        }\n    }\n};\n\n/**\n * @method intersectShape\n * @private\n * @param {Shape} shape\n * @param {number} angle\n * @param {array} position\n * @param {Body} body\n */\nRay.prototype.intersectShape = function(result, shape, angle, position, body){\n    var from = this.from;\n\n    // Checking radius\n    var distance = distanceFromIntersectionSquared(from, this.direction, position);\n    if (distance > shape.boundingRadius * shape.boundingRadius) {\n        return;\n    }\n\n    this._currentBody = body;\n    this._currentShape = shape;\n\n    shape.raycast(result, this, position, angle);\n\n    this._currentBody = this._currentShape = null;\n};\n\n/**\n * Get the AABB of the ray.\n * @method getAABB\n * @param  {AABB} aabb\n */\nRay.prototype.getAABB = function(result){\n    var to = this.to;\n    var from = this.from;\n    vec2.set(\n        result.lowerBound,\n        Math.min(to[0], from[0]),\n        Math.min(to[1], from[1])\n    );\n    vec2.set(\n        result.upperBound,\n        Math.max(to[0], from[0]),\n        Math.max(to[1], from[1])\n    );\n};\n\nvar hitPointWorld = vec2.create();\n\n/**\n * @method reportIntersection\n * @private\n * @param  {number} fraction\n * @param  {array} normal\n * @param  {number} [faceIndex=-1]\n * @return {boolean} True if the intersections should continue\n */\nRay.prototype.reportIntersection = function(result, fraction, normal, faceIndex){\n    var from = this.from;\n    var to = this.to;\n    var shape = this._currentShape;\n    var body = this._currentBody;\n\n    // Skip back faces?\n    if(this.skipBackfaces && vec2.dot(normal, this.direction) > 0){\n        return;\n    }\n\n    switch(this.mode){\n\n    case Ray.ALL:\n        result.set(\n            normal,\n            shape,\n            body,\n            fraction,\n            faceIndex\n        );\n        this.callback(result);\n        break;\n\n    case Ray.CLOSEST:\n\n        // Store if closer than current closest\n        if(fraction < result.fraction || !result.hasHit()){\n            result.set(\n                normal,\n                shape,\n                body,\n                fraction,\n                faceIndex\n            );\n        }\n        break;\n\n    case Ray.ANY:\n\n        // Report and stop.\n        result.set(\n            normal,\n            shape,\n            body,\n            fraction,\n            faceIndex\n        );\n        break;\n    }\n};\n\nvar v0 = vec2.create(),\n    intersect = vec2.create();\nfunction distanceFromIntersectionSquared(from, direction, position) {\n\n    // v0 is vector from from to position\n    vec2.sub(v0, position, from);\n    var dot = vec2.dot(v0, direction);\n\n    // intersect = direction * dot + from\n    vec2.scale(intersect, direction, dot);\n    vec2.add(intersect, intersect, from);\n\n    return vec2.squaredDistance(position, intersect);\n}\n\n","var vec2 = require('../math/vec2');\nvar Ray = require('../collision/Ray');\n\nmodule.exports = RaycastResult;\n\n/**\n * Storage for Ray casting hit data.\n * @class RaycastResult\n * @constructor\n */\nfunction RaycastResult(){\n\n\t/**\n\t * The normal of the hit, oriented in world space.\n\t * @property {array} normal\n\t */\n\tthis.normal = vec2.create();\n\n\t/**\n\t * The hit shape, or null.\n\t * @property {Shape} shape\n\t */\n\tthis.shape = null;\n\n\t/**\n\t * The hit body, or null.\n\t * @property {Body} body\n\t */\n\tthis.body = null;\n\n\t/**\n\t * The index of the hit triangle, if the hit shape was indexable.\n\t * @property {number} faceIndex\n\t * @default -1\n\t */\n\tthis.faceIndex = -1;\n\n\t/**\n\t * Distance to the hit, as a fraction. 0 is at the \"from\" point, 1 is at the \"to\" point. Will be set to -1 if there was no hit yet.\n\t * @property {number} fraction\n\t * @default -1\n\t */\n\tthis.fraction = -1;\n\n\t/**\n\t * If the ray should stop traversing.\n\t * @readonly\n\t * @property {Boolean} isStopped\n\t */\n\tthis.isStopped = false;\n}\n\n/**\n * Reset all result data. Must be done before re-using the result object.\n * @method reset\n */\nRaycastResult.prototype.reset = function () {\n\tvec2.set(this.normal, 0, 0);\n\tthis.shape = null;\n\tthis.body = null;\n\tthis.faceIndex = -1;\n\tthis.fraction = -1;\n\tthis.isStopped = false;\n};\n\n/**\n * Get the distance to the hit point.\n * @method getHitDistance\n * @param {Ray} ray\n */\nRaycastResult.prototype.getHitDistance = function (ray) {\n\treturn vec2.distance(ray.from, ray.to) * this.fraction;\n};\n\n/**\n * Returns true if the ray hit something since the last reset().\n * @method hasHit\n */\nRaycastResult.prototype.hasHit = function () {\n\treturn this.fraction !== -1;\n};\n\n/**\n * Get world hit point.\n * @method getHitPoint\n * @param {array} out\n * @param {Ray} ray\n */\nRaycastResult.prototype.getHitPoint = function (out, ray) {\n\tvec2.lerp(out, ray.from, ray.to, this.fraction);\n};\n\n/**\n * Can be called while iterating over hits to stop searching for hit points.\n * @method stop\n */\nRaycastResult.prototype.stop = function(){\n\tthis.isStopped = true;\n};\n\n/**\n * @method shouldStop\n * @private\n * @param {Ray} ray\n * @return {boolean}\n */\nRaycastResult.prototype.shouldStop = function(ray){\n\treturn this.isStopped || (this.fraction !== -1 && ray.mode === Ray.ANY);\n};\n\n/**\n * @method set\n * @private\n * @param {array} normal\n * @param {Shape} shape\n * @param {Body} body\n * @param {number} fraction\n */\nRaycastResult.prototype.set = function(\n\tnormal,\n\tshape,\n\tbody,\n\tfraction,\n\tfaceIndex\n){\n\tvec2.copy(this.normal, normal);\n\tthis.shape = shape;\n\tthis.body = body;\n\tthis.fraction = fraction;\n\tthis.faceIndex = faceIndex;\n};","var Utils = require('../utils/Utils')\n,   Broadphase = require('../collision/Broadphase');\n\nmodule.exports = SAPBroadphase;\n\n/**\n * Sweep and prune broadphase along one axis.\n *\n * @class SAPBroadphase\n * @constructor\n * @extends Broadphase\n */\nfunction SAPBroadphase(){\n    Broadphase.call(this,Broadphase.SAP);\n\n    /**\n     * List of bodies currently in the broadphase.\n     * @property axisList\n     * @type {Array}\n     */\n    this.axisList = [];\n\n    /**\n     * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.\n     * @property axisIndex\n     * @type {Number}\n     */\n    this.axisIndex = 0;\n\n    var that = this;\n    this._addBodyHandler = function(e){\n        that.axisList.push(e.body);\n    };\n\n    this._removeBodyHandler = function(e){\n        // Remove from list\n        var idx = that.axisList.indexOf(e.body);\n        if(idx !== -1){\n            that.axisList.splice(idx,1);\n        }\n    };\n}\nSAPBroadphase.prototype = new Broadphase();\nSAPBroadphase.prototype.constructor = SAPBroadphase;\n\n/**\n * Change the world\n * @method setWorld\n * @param {World} world\n */\nSAPBroadphase.prototype.setWorld = function(world){\n    // Clear the old axis array\n    this.axisList.length = 0;\n\n    // Add all bodies from the new world\n    Utils.appendArray(this.axisList, world.bodies);\n\n    // Remove old handlers, if any\n    world\n        .off(\"addBody\",this._addBodyHandler)\n        .off(\"removeBody\",this._removeBodyHandler);\n\n    // Add handlers to update the list of bodies.\n    world.on(\"addBody\",this._addBodyHandler).on(\"removeBody\",this._removeBodyHandler);\n\n    this.world = world;\n};\n\n/**\n * Sorts bodies along an axis.\n * @method sortAxisList\n * @param {Array} a\n * @param {number} axisIndex\n * @return {Array}\n */\nSAPBroadphase.sortAxisList = function(a, axisIndex){\n    axisIndex = axisIndex|0;\n    for(var i=1,l=a.length; i<l; i++) {\n        var v = a[i];\n        for(var j=i - 1;j>=0;j--) {\n            if(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){\n                break;\n            }\n            a[j+1] = a[j];\n        }\n        a[j+1] = v;\n    }\n    return a;\n};\n\nSAPBroadphase.prototype.sortList = function(){\n    var bodies = this.axisList,\n    axisIndex = this.axisIndex;\n\n    // Sort the lists\n    SAPBroadphase.sortAxisList(bodies, axisIndex);\n};\n\n/**\n * Get the colliding pairs\n * @method getCollisionPairs\n * @param  {World} world\n * @return {Array}\n */\nSAPBroadphase.prototype.getCollisionPairs = function(world){\n    var bodies = this.axisList,\n        result = this.result,\n        axisIndex = this.axisIndex;\n\n    result.length = 0;\n\n    // Update all AABBs if needed\n    var l = bodies.length;\n    while(l--){\n        var b = bodies[l];\n        if(b.aabbNeedsUpdate){\n            b.updateAABB();\n        }\n    }\n\n    // Sort the lists\n    this.sortList();\n\n    // Look through the X list\n    for(var i=0, N=bodies.length|0; i!==N; i++){\n        var bi = bodies[i];\n\n        for(var j=i+1; j<N; j++){\n            var bj = bodies[j];\n\n            // Bounds overlap?\n            var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);\n            if(!overlaps){\n                break;\n            }\n\n            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){\n                result.push(bi,bj);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Returns all the bodies within an AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param {array} result An array to store resulting bodies in.\n * @return {array}\n */\nSAPBroadphase.prototype.aabbQuery = function(world, aabb, result){\n    result = result || [];\n\n    this.sortList();\n\n    var axisIndex = this.axisIndex;\n    var axis = 'x';\n    if(axisIndex === 1){ axis = 'y'; }\n    if(axisIndex === 2){ axis = 'z'; }\n\n    var axisList = this.axisList;\n    var lower = aabb.lowerBound[axis];\n    var upper = aabb.upperBound[axis];\n    for(var i = 0; i < axisList.length; i++){\n        var b = axisList[i];\n\n        if(b.aabbNeedsUpdate){\n            b.updateAABB();\n        }\n\n        if(b.aabb.overlaps(aabb)){\n            result.push(b);\n        }\n    }\n\n    return result;\n};","module.exports = Constraint;\n\nvar Utils = require('../utils/Utils');\n\n/**\n * Base constraint class.\n *\n * @class Constraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} type\n * @param {Object} [options]\n * @param {Object} [options.collideConnected=true]\n */\nfunction Constraint(bodyA, bodyB, type, options){\n\n    /**\n     * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.\n     * @property {number} type\n     */\n    this.type = type;\n\n    options = Utils.defaults(options,{\n        collideConnected : true,\n        wakeUpBodies : true,\n    });\n\n    /**\n     * Equations to be solved in this constraint\n     *\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * First body participating in the constraint.\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second body participating in the constraint.\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * Set to true if you want the connected bodies to collide.\n     * @property collideConnected\n     * @type {Boolean}\n     * @default true\n     */\n    this.collideConnected = options.collideConnected;\n\n    // Wake up bodies when connected\n    if(options.wakeUpBodies){\n        if(bodyA){\n            bodyA.wakeUp();\n        }\n        if(bodyB){\n            bodyB.wakeUp();\n        }\n    }\n}\n\n/**\n * Updates the internal constraint parameters before solve.\n * @method update\n */\nConstraint.prototype.update = function(){\n    throw new Error(\"method update() not implmemented in this Constraint subclass!\");\n};\n\n/**\n * @static\n * @property {number} DISTANCE\n */\nConstraint.DISTANCE = 1;\n\n/**\n * @static\n * @property {number} GEAR\n */\nConstraint.GEAR = 2;\n\n/**\n * @static\n * @property {number} LOCK\n */\nConstraint.LOCK = 3;\n\n/**\n * @static\n * @property {number} PRISMATIC\n */\nConstraint.PRISMATIC = 4;\n\n/**\n * @static\n * @property {number} REVOLUTE\n */\nConstraint.REVOLUTE = 5;\n\n/**\n * Set stiffness for this constraint.\n * @method setStiffness\n * @param {Number} stiffness\n */\nConstraint.prototype.setStiffness = function(stiffness){\n    var eqs = this.equations;\n    for(var i=0; i !== eqs.length; i++){\n        var eq = eqs[i];\n        eq.stiffness = stiffness;\n        eq.needsUpdate = true;\n    }\n};\n\n/**\n * Set relaxation for this constraint.\n * @method setRelaxation\n * @param {Number} relaxation\n */\nConstraint.prototype.setRelaxation = function(relaxation){\n    var eqs = this.equations;\n    for(var i=0; i !== eqs.length; i++){\n        var eq = eqs[i];\n        eq.relaxation = relaxation;\n        eq.needsUpdate = true;\n    }\n};\n","var Constraint = require('./Constraint')\n,   Equation = require('../equations/Equation')\n,   vec2 = require('../math/vec2')\n,   Utils = require('../utils/Utils');\n\nmodule.exports = DistanceConstraint;\n\n/**\n * Constraint that tries to keep the distance between two bodies constant.\n *\n * @class DistanceConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.\n * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].\n * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].\n * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.\n * @extends Constraint\n *\n * @example\n *     // If distance is not given as an option, then the current distance between the bodies is used.\n *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.\n *     var bodyA = new Body({ mass: 1, position: [-1, 0] });\n *     var bodyB = new Body({ mass: 1, position: [1, 0] });\n *     var constraint = new DistanceConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n *\n * @example\n *     // Manually set the distance and anchors\n *     var constraint = new DistanceConstraint(bodyA, bodyB, {\n *         distance: 1,          // Distance to keep between the points\n *         localAnchorA: [1, 0], // Point on bodyA\n *         localAnchorB: [-1, 0] // Point on bodyB\n *     });\n *     world.addConstraint(constraint);\n */\nfunction DistanceConstraint(bodyA,bodyB,options){\n    options = Utils.defaults(options,{\n        localAnchorA:[0,0],\n        localAnchorB:[0,0]\n    });\n\n    Constraint.call(this,bodyA,bodyB,Constraint.DISTANCE,options);\n\n    /**\n     * Local anchor in body A.\n     * @property localAnchorA\n     * @type {Array}\n     */\n    this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);\n\n    /**\n     * Local anchor in body B.\n     * @property localAnchorB\n     * @type {Array}\n     */\n    this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);\n\n    var localAnchorA = this.localAnchorA;\n    var localAnchorB = this.localAnchorB;\n\n    /**\n     * The distance to keep.\n     * @property distance\n     * @type {Number}\n     */\n    this.distance = 0;\n\n    if(typeof(options.distance) === 'number'){\n        this.distance = options.distance;\n    } else {\n        // Use the current world distance between the world anchor points.\n        var worldAnchorA = vec2.create(),\n            worldAnchorB = vec2.create(),\n            r = vec2.create();\n\n        // Transform local anchors to world\n        vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);\n        vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);\n\n        vec2.add(r, bodyB.position, worldAnchorB);\n        vec2.sub(r, r, worldAnchorA);\n        vec2.sub(r, r, bodyA.position);\n\n        this.distance = vec2.length(r);\n    }\n\n    var maxForce;\n    if(typeof(options.maxForce)===\"undefined\" ){\n        maxForce = Number.MAX_VALUE;\n    } else {\n        maxForce = options.maxForce;\n    }\n\n    var normal = new Equation(bodyA,bodyB,-maxForce,maxForce); // Just in the normal direction\n    this.equations = [ normal ];\n\n    /**\n     * Max force to apply.\n     * @property {number} maxForce\n     */\n    this.maxForce = maxForce;\n\n    // g = (xi - xj).dot(n)\n    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'\n\n    // ...and if we were to include offset points:\n    // g =\n    //      (xj + rj - xi - ri).dot(n) - distance\n    //\n    // dg/dt =\n    //      (vj + wj x rj - vi - wi x ri).dot(n) =\n    //      { term 2 is near zero } =\n    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =\n    //      G * W\n    //\n    // => G = [-n -rixn n rjxn]\n\n    var r = vec2.create();\n    var ri = vec2.create(); // worldAnchorA\n    var rj = vec2.create(); // worldAnchorB\n    var that = this;\n    normal.computeGq = function(){\n        var bodyA = this.bodyA,\n            bodyB = this.bodyB,\n            xi = bodyA.position,\n            xj = bodyB.position;\n\n        // Transform local anchors to world\n        vec2.rotate(ri, localAnchorA, bodyA.angle);\n        vec2.rotate(rj, localAnchorB, bodyB.angle);\n\n        vec2.add(r, xj, rj);\n        vec2.sub(r, r, ri);\n        vec2.sub(r, r, xi);\n\n        //vec2.sub(r, bodyB.position, bodyA.position);\n        return vec2.length(r) - that.distance;\n    };\n\n    // Make the contact constraint bilateral\n    this.setMaxForce(maxForce);\n\n    /**\n     * If the upper limit is enabled or not.\n     * @property {Boolean} upperLimitEnabled\n     */\n    this.upperLimitEnabled = false;\n\n    /**\n     * The upper constraint limit.\n     * @property {number} upperLimit\n     */\n    this.upperLimit = 1;\n\n    /**\n     * If the lower limit is enabled or not.\n     * @property {Boolean} lowerLimitEnabled\n     */\n    this.lowerLimitEnabled = false;\n\n    /**\n     * The lower constraint limit.\n     * @property {number} lowerLimit\n     */\n    this.lowerLimit = 0;\n\n    /**\n     * Current constraint position. This is equal to the current distance between the world anchor points.\n     * @property {number} position\n     */\n    this.position = 0;\n}\nDistanceConstraint.prototype = new Constraint();\nDistanceConstraint.prototype.constructor = DistanceConstraint;\n\n/**\n * Update the constraint equations. Should be done if any of the bodies changed position, before solving.\n * @method update\n */\nvar n = vec2.create();\nvar ri = vec2.create(); // worldAnchorA\nvar rj = vec2.create(); // worldAnchorB\nDistanceConstraint.prototype.update = function(){\n    var normal = this.equations[0],\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        distance = this.distance,\n        xi = bodyA.position,\n        xj = bodyB.position,\n        normalEquation = this.equations[0],\n        G = normal.G;\n\n    // Transform local anchors to world\n    vec2.rotate(ri, this.localAnchorA, bodyA.angle);\n    vec2.rotate(rj, this.localAnchorB, bodyB.angle);\n\n    // Get world anchor points and normal\n    vec2.add(n, xj, rj);\n    vec2.sub(n, n, ri);\n    vec2.sub(n, n, xi);\n    this.position = vec2.length(n);\n\n    var violating = false;\n    if(this.upperLimitEnabled){\n        if(this.position > this.upperLimit){\n            normalEquation.maxForce = 0;\n            normalEquation.minForce = -this.maxForce;\n            this.distance = this.upperLimit;\n            violating = true;\n        }\n    }\n\n    if(this.lowerLimitEnabled){\n        if(this.position < this.lowerLimit){\n            normalEquation.maxForce = this.maxForce;\n            normalEquation.minForce = 0;\n            this.distance = this.lowerLimit;\n            violating = true;\n        }\n    }\n\n    if((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating){\n        // No constraint needed.\n        normalEquation.enabled = false;\n        return;\n    }\n\n    normalEquation.enabled = true;\n\n    vec2.normalize(n,n);\n\n    // Caluclate cross products\n    var rixn = vec2.crossLength(ri, n),\n        rjxn = vec2.crossLength(rj, n);\n\n    // G = [-n -rixn n rjxn]\n    G[0] = -n[0];\n    G[1] = -n[1];\n    G[2] = -rixn;\n    G[3] = n[0];\n    G[4] = n[1];\n    G[5] = rjxn;\n};\n\n/**\n * Set the max force to be used\n * @method setMaxForce\n * @param {Number} maxForce\n */\nDistanceConstraint.prototype.setMaxForce = function(maxForce){\n    var normal = this.equations[0];\n    normal.minForce = -maxForce;\n    normal.maxForce =  maxForce;\n};\n\n/**\n * Get the max force\n * @method getMaxForce\n * @return {Number}\n */\nDistanceConstraint.prototype.getMaxForce = function(){\n    var normal = this.equations[0];\n    return normal.maxForce;\n};\n","var Constraint = require('./Constraint')\n,   Equation = require('../equations/Equation')\n,   AngleLockEquation = require('../equations/AngleLockEquation')\n,   vec2 = require('../math/vec2');\n\nmodule.exports = GearConstraint;\n\n/**\n * Constrains the angle of two bodies to each other to be equal. If a gear ratio is not one, the angle of bodyA must be a multiple of the angle of bodyB.\n * @class GearConstraint\n * @constructor\n * @author schteppe\n * @param {Body}            bodyA\n * @param {Body}            bodyB\n * @param {Object}          [options]\n * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).\n * @param {Number}          [options.ratio=1] Gear ratio.\n * @param {Number}          [options.maxTorque] Maximum torque to apply.\n * @extends Constraint\n *\n * @example\n *     var constraint = new GearConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n *\n * @example\n *     var constraint = new GearConstraint(bodyA, bodyB, {\n *         ratio: 2,\n *         maxTorque: 1000\n *     });\n *     world.addConstraint(constraint);\n */\nfunction GearConstraint(bodyA, bodyB, options){\n    options = options || {};\n\n    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);\n\n    /**\n     * The gear ratio.\n     * @property ratio\n     * @type {Number}\n     */\n    this.ratio = options.ratio !== undefined ? options.ratio : 1;\n\n    /**\n     * The relative angle\n     * @property angle\n     * @type {Number}\n     */\n    this.angle = options.angle !== undefined ? options.angle : bodyB.angle - this.ratio * bodyA.angle;\n\n    // Send same parameters to the equation\n    options.angle = this.angle;\n    options.ratio = this.ratio;\n\n    this.equations = [\n        new AngleLockEquation(bodyA,bodyB,options),\n    ];\n\n    // Set max torque\n    if(options.maxTorque !== undefined){\n        this.setMaxTorque(options.maxTorque);\n    }\n}\nGearConstraint.prototype = new Constraint();\nGearConstraint.prototype.constructor = GearConstraint;\n\nGearConstraint.prototype.update = function(){\n    var eq = this.equations[0];\n    if(eq.ratio !== this.ratio){\n        eq.setRatio(this.ratio);\n    }\n    eq.angle = this.angle;\n};\n\n/**\n * Set the max torque for the constraint.\n * @method setMaxTorque\n * @param {Number} torque\n */\nGearConstraint.prototype.setMaxTorque = function(torque){\n    this.equations[0].setMaxTorque(torque);\n};\n\n/**\n * Get the max torque for the constraint.\n * @method getMaxTorque\n * @return {Number}\n */\nGearConstraint.prototype.getMaxTorque = function(torque){\n    return this.equations[0].maxForce;\n};","var Constraint = require('./Constraint')\n,   vec2 = require('../math/vec2')\n,   Equation = require('../equations/Equation');\n\nmodule.exports = LockConstraint;\n\n/**\n * Locks the relative position and rotation between two bodies.\n *\n * @class LockConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.\n * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.\n * @param {number} [options.maxForce]\n * @extends Constraint\n *\n * @example\n *     // Locks the relative position and rotation between bodyA and bodyB\n *     var constraint = new LockConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n */\nfunction LockConstraint(bodyA, bodyB, options){\n    options = options || {};\n\n    Constraint.call(this,bodyA,bodyB,Constraint.LOCK,options);\n\n    var maxForce = ( typeof(options.maxForce)===\"undefined\" ? Number.MAX_VALUE : options.maxForce );\n\n    var localAngleB = options.localAngleB || 0;\n\n    // Use 3 equations:\n    // gx =   (xj - xi - l) * xhat = 0\n    // gy =   (xj - xi - l) * yhat = 0\n    // gr =   (xi - xj + r) * that = 0\n    //\n    // ...where:\n    //   l is the localOffsetB vector rotated to world in bodyA frame\n    //   r is the same vector but reversed and rotated from bodyB frame\n    //   xhat, yhat are world axis vectors\n    //   that is the tangent of r\n    //\n    // For the first two constraints, we get\n    // G*W = (vj - vi - ldot  ) * xhat\n    //     = (vj - vi - wi x l) * xhat\n    //\n    // Since (wi x l) * xhat = (l x xhat) * wi, we get\n    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]\n    //\n    // The last constraint gives\n    // GW = (vi - vj + wj x r) * that\n    //    = [  that   0  -that  (r x t) ]\n\n    var x =     new Equation(bodyA,bodyB,-maxForce,maxForce),\n        y =     new Equation(bodyA,bodyB,-maxForce,maxForce),\n        rot =   new Equation(bodyA,bodyB,-maxForce,maxForce);\n\n    var l = vec2.create(),\n        g = vec2.create(),\n        that = this;\n    x.computeGq = function(){\n        vec2.rotate(l, that.localOffsetB, bodyA.angle);\n        vec2.sub(g, bodyB.position, bodyA.position);\n        vec2.sub(g, g, l);\n        return g[0];\n    };\n    y.computeGq = function(){\n        vec2.rotate(l, that.localOffsetB, bodyA.angle);\n        vec2.sub(g, bodyB.position, bodyA.position);\n        vec2.sub(g, g, l);\n        return g[1];\n    };\n    var r = vec2.create(),\n        t = vec2.create();\n    rot.computeGq = function(){\n        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);\n        vec2.scale(r,r,-1);\n        vec2.sub(g,bodyA.position,bodyB.position);\n        vec2.add(g,g,r);\n        vec2.rotate(t,r,-Math.PI/2);\n        vec2.normalize(t,t);\n        return vec2.dot(g,t);\n    };\n\n    /**\n     * The offset of bodyB in bodyA's frame.\n     * @property {Array} localOffsetB\n     */\n    this.localOffsetB = vec2.create();\n    if(options.localOffsetB){\n        vec2.copy(this.localOffsetB, options.localOffsetB);\n    } else {\n        // Construct from current positions\n        vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);\n        vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);\n    }\n\n    /**\n     * The offset angle of bodyB in bodyA's frame.\n     * @property {Number} localAngleB\n     */\n    this.localAngleB = 0;\n    if(typeof(options.localAngleB) === 'number'){\n        this.localAngleB = options.localAngleB;\n    } else {\n        // Construct\n        this.localAngleB = bodyB.angle - bodyA.angle;\n    }\n\n    this.equations.push(x, y, rot);\n    this.setMaxForce(maxForce);\n}\nLockConstraint.prototype = new Constraint();\nLockConstraint.prototype.constructor = LockConstraint;\n\n/**\n * Set the maximum force to be applied.\n * @method setMaxForce\n * @param {Number} force\n */\nLockConstraint.prototype.setMaxForce = function(force){\n    var eqs = this.equations;\n    for(var i=0; i<this.equations.length; i++){\n        eqs[i].maxForce =  force;\n        eqs[i].minForce = -force;\n    }\n};\n\n/**\n * Get the max force.\n * @method getMaxForce\n * @return {Number}\n */\nLockConstraint.prototype.getMaxForce = function(){\n    return this.equations[0].maxForce;\n};\n\nvar l = vec2.create();\nvar r = vec2.create();\nvar t = vec2.create();\nvar xAxis = vec2.fromValues(1,0);\nvar yAxis = vec2.fromValues(0,1);\nLockConstraint.prototype.update = function(){\n    var x =   this.equations[0],\n        y =   this.equations[1],\n        rot = this.equations[2],\n        bodyA = this.bodyA,\n        bodyB = this.bodyB;\n\n    vec2.rotate(l,this.localOffsetB,bodyA.angle);\n    vec2.rotate(r,this.localOffsetB,bodyB.angle - this.localAngleB);\n    vec2.scale(r,r,-1);\n\n    vec2.rotate(t,r,Math.PI/2);\n    vec2.normalize(t,t);\n\n    x.G[0] = -1;\n    x.G[1] =  0;\n    x.G[2] = -vec2.crossLength(l,xAxis);\n    x.G[3] =  1;\n\n    y.G[0] =  0;\n    y.G[1] = -1;\n    y.G[2] = -vec2.crossLength(l,yAxis);\n    y.G[4] =  1;\n\n    rot.G[0] =  -t[0];\n    rot.G[1] =  -t[1];\n    rot.G[3] =  t[0];\n    rot.G[4] =  t[1];\n    rot.G[5] =  vec2.crossLength(r,t);\n};\n","var Constraint = require('./Constraint')\n,   ContactEquation = require('../equations/ContactEquation')\n,   Equation = require('../equations/Equation')\n,   vec2 = require('../math/vec2')\n,   RotationalLockEquation = require('../equations/RotationalLockEquation');\n\nmodule.exports = PrismaticConstraint;\n\n/**\n * Constraint that only allows bodies to move along a line, relative to each other. See <a href=\"http://www.iforce2d.net/b2dtut/joints-prismatic\">this tutorial</a>. Also called \"slider constraint\".\n *\n * @class PrismaticConstraint\n * @constructor\n * @extends Constraint\n * @author schteppe\n * @param {Body}    bodyA\n * @param {Body}    bodyB\n * @param {Object}  [options]\n * @param {Number}  [options.maxForce]                Max force to be applied by the constraint\n * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.\n * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.\n * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.\n * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.\n * @param {Number}  [options.upperLimit]\n * @param {Number}  [options.lowerLimit]\n * @todo Ability to create using only a point and a worldAxis\n */\nfunction PrismaticConstraint(bodyA, bodyB, options){\n    options = options || {};\n    Constraint.call(this,bodyA,bodyB,Constraint.PRISMATIC,options);\n\n    // Get anchors\n    var localAnchorA = vec2.fromValues(0,0),\n        localAxisA = vec2.fromValues(1,0),\n        localAnchorB = vec2.fromValues(0,0);\n    if(options.localAnchorA){ vec2.copy(localAnchorA, options.localAnchorA); }\n    if(options.localAxisA){ vec2.copy(localAxisA,   options.localAxisA); }\n    if(options.localAnchorB){ vec2.copy(localAnchorB, options.localAnchorB); }\n\n    /**\n     * @property localAnchorA\n     * @type {Array}\n     */\n    this.localAnchorA = localAnchorA;\n\n    /**\n     * @property localAnchorB\n     * @type {Array}\n     */\n    this.localAnchorB = localAnchorB;\n\n    /**\n     * @property localAxisA\n     * @type {Array}\n     */\n    this.localAxisA = localAxisA;\n\n    /*\n\n    The constraint violation for the common axis point is\n\n        g = ( xj + rj - xi - ri ) * t   :=  gg*t\n\n    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.\n\n        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )\n\n    Note the use of the chain rule. Now we identify the jacobian\n\n        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]\n\n    The rotational part is just a rotation lock.\n\n     */\n\n    var maxForce = this.maxForce = typeof(options.maxForce)!==\"undefined\" ? options.maxForce : Number.MAX_VALUE;\n\n    // Translational part\n    var trans = new Equation(bodyA,bodyB,-maxForce,maxForce);\n    var ri = new vec2.create(),\n        rj = new vec2.create(),\n        gg = new vec2.create(),\n        t =  new vec2.create();\n    trans.computeGq = function(){\n        // g = ( xj + rj - xi - ri ) * t\n        return vec2.dot(gg,t);\n    };\n    trans.updateJacobian = function(){\n        var G = this.G,\n            xi = bodyA.position,\n            xj = bodyB.position;\n        vec2.rotate(ri,localAnchorA,bodyA.angle);\n        vec2.rotate(rj,localAnchorB,bodyB.angle);\n        vec2.add(gg,xj,rj);\n        vec2.sub(gg,gg,xi);\n        vec2.sub(gg,gg,ri);\n        vec2.rotate(t,localAxisA,bodyA.angle+Math.PI/2);\n\n        G[0] = -t[0];\n        G[1] = -t[1];\n        G[2] = -vec2.crossLength(ri,t) + vec2.crossLength(t,gg);\n        G[3] = t[0];\n        G[4] = t[1];\n        G[5] = vec2.crossLength(rj,t);\n    };\n    this.equations.push(trans);\n\n    // Rotational part\n    if(!options.disableRotationalLock){\n        var rot = new RotationalLockEquation(bodyA,bodyB,-maxForce,maxForce);\n        this.equations.push(rot);\n    }\n\n    /**\n     * The position of anchor A relative to anchor B, along the constraint axis.\n     * @property position\n     * @type {Number}\n     */\n    this.position = 0;\n\n    // Is this one used at all?\n    this.velocity = 0;\n\n    /**\n     * Set to true to enable lower limit.\n     * @property lowerLimitEnabled\n     * @type {Boolean}\n     */\n    this.lowerLimitEnabled = typeof(options.lowerLimit)!==\"undefined\" ? true : false;\n\n    /**\n     * Set to true to enable upper limit.\n     * @property upperLimitEnabled\n     * @type {Boolean}\n     */\n    this.upperLimitEnabled = typeof(options.upperLimit)!==\"undefined\" ? true : false;\n\n    /**\n     * Lower constraint limit. The constraint position is forced to be larger than this value.\n     * @property lowerLimit\n     * @type {Number}\n     */\n    this.lowerLimit = typeof(options.lowerLimit)!==\"undefined\" ? options.lowerLimit : 0;\n\n    /**\n     * Upper constraint limit. The constraint position is forced to be smaller than this value.\n     * @property upperLimit\n     * @type {Number}\n     */\n    this.upperLimit = typeof(options.upperLimit)!==\"undefined\" ? options.upperLimit : 1;\n\n    // Equations used for limits\n    this.upperLimitEquation = new ContactEquation(bodyA,bodyB);\n    this.lowerLimitEquation = new ContactEquation(bodyA,bodyB);\n\n    // Set max/min forces\n    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;\n    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;\n\n    /**\n     * Equation used for the motor.\n     * @property motorEquation\n     * @type {Equation}\n     */\n    this.motorEquation = new Equation(bodyA,bodyB);\n\n    /**\n     * The current motor state. Enable or disable the motor using .enableMotor\n     * @property motorEnabled\n     * @type {Boolean}\n     */\n    this.motorEnabled = false;\n\n    /**\n     * Set the target speed for the motor.\n     * @property motorSpeed\n     * @type {Number}\n     */\n    this.motorSpeed = 0;\n\n    var that = this;\n    var motorEquation = this.motorEquation;\n    var old = motorEquation.computeGW;\n    motorEquation.computeGq = function(){ return 0; };\n    motorEquation.computeGW = function(){\n        var G = this.G,\n            bi = this.bodyA,\n            bj = this.bodyB,\n            vi = bi.velocity,\n            vj = bj.velocity,\n            wi = bi.angularVelocity,\n            wj = bj.angularVelocity;\n        return this.gmult(G,vi,wi,vj,wj) + that.motorSpeed;\n    };\n}\n\nPrismaticConstraint.prototype = new Constraint();\nPrismaticConstraint.prototype.constructor = PrismaticConstraint;\n\nvar worldAxisA = vec2.create(),\n    worldAnchorA = vec2.create(),\n    worldAnchorB = vec2.create(),\n    orientedAnchorA = vec2.create(),\n    orientedAnchorB = vec2.create(),\n    tmp = vec2.create();\n\n/**\n * Update the constraint equations. Should be done if any of the bodies changed position, before solving.\n * @method update\n */\nPrismaticConstraint.prototype.update = function(){\n    var eqs = this.equations,\n        trans = eqs[0],\n        upperLimit = this.upperLimit,\n        lowerLimit = this.lowerLimit,\n        upperLimitEquation = this.upperLimitEquation,\n        lowerLimitEquation = this.lowerLimitEquation,\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        localAxisA = this.localAxisA,\n        localAnchorA = this.localAnchorA,\n        localAnchorB = this.localAnchorB;\n\n    trans.updateJacobian();\n\n    // Transform local things to world\n    vec2.rotate(worldAxisA,      localAxisA,      bodyA.angle);\n    vec2.rotate(orientedAnchorA, localAnchorA,    bodyA.angle);\n    vec2.add(worldAnchorA,       orientedAnchorA, bodyA.position);\n    vec2.rotate(orientedAnchorB, localAnchorB,    bodyB.angle);\n    vec2.add(worldAnchorB,       orientedAnchorB, bodyB.position);\n\n    var relPosition = this.position = vec2.dot(worldAnchorB,worldAxisA) - vec2.dot(worldAnchorA,worldAxisA);\n\n    // Motor\n    if(this.motorEnabled){\n        // G = [ a     a x ri   -a   -a x rj ]\n        var G = this.motorEquation.G;\n        G[0] = worldAxisA[0];\n        G[1] = worldAxisA[1];\n        G[2] = vec2.crossLength(worldAxisA,orientedAnchorB);\n        G[3] = -worldAxisA[0];\n        G[4] = -worldAxisA[1];\n        G[5] = -vec2.crossLength(worldAxisA,orientedAnchorA);\n    }\n\n    /*\n        Limits strategy:\n        Add contact equation, with normal along the constraint axis.\n        min/maxForce is set so the constraint is repulsive in the correct direction.\n        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.\n\n                 ^\n                 |\n      upperLimit x\n                 |    ------\n         anchorB x<---|  B |\n                 |    |    |\n        ------   |    ------\n        |    |   |\n        |  A |-->x anchorA\n        ------   |\n                 x lowerLimit\n                 |\n                axis\n     */\n\n\n    if(this.upperLimitEnabled && relPosition > upperLimit){\n        // Update contact constraint normal, etc\n        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);\n        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);\n        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);\n        vec2.scale(tmp,worldAxisA,upperLimit);\n        vec2.add(upperLimitEquation.contactPointA,upperLimitEquation.contactPointA,tmp);\n        if(eqs.indexOf(upperLimitEquation) === -1){\n            eqs.push(upperLimitEquation);\n        }\n    } else {\n        var idx = eqs.indexOf(upperLimitEquation);\n        if(idx !== -1){\n            eqs.splice(idx,1);\n        }\n    }\n\n    if(this.lowerLimitEnabled && relPosition < lowerLimit){\n        // Update contact constraint normal, etc\n        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);\n        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);\n        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);\n        vec2.scale(tmp,worldAxisA,lowerLimit);\n        vec2.sub(lowerLimitEquation.contactPointB,lowerLimitEquation.contactPointB,tmp);\n        if(eqs.indexOf(lowerLimitEquation) === -1){\n            eqs.push(lowerLimitEquation);\n        }\n    } else {\n        var idx = eqs.indexOf(lowerLimitEquation);\n        if(idx !== -1){\n            eqs.splice(idx,1);\n        }\n    }\n};\n\n/**\n * Enable the motor\n * @method enableMotor\n */\nPrismaticConstraint.prototype.enableMotor = function(){\n    if(this.motorEnabled){\n        return;\n    }\n    this.equations.push(this.motorEquation);\n    this.motorEnabled = true;\n};\n\n/**\n * Disable the rotational motor\n * @method disableMotor\n */\nPrismaticConstraint.prototype.disableMotor = function(){\n    if(!this.motorEnabled){\n        return;\n    }\n    var i = this.equations.indexOf(this.motorEquation);\n    this.equations.splice(i,1);\n    this.motorEnabled = false;\n};\n\n/**\n * Set the constraint limits.\n * @method setLimits\n * @param {number} lower Lower limit.\n * @param {number} upper Upper limit.\n */\nPrismaticConstraint.prototype.setLimits = function (lower, upper) {\n    if(typeof(lower) === 'number'){\n        this.lowerLimit = lower;\n        this.lowerLimitEnabled = true;\n    } else {\n        this.lowerLimit = lower;\n        this.lowerLimitEnabled = false;\n    }\n\n    if(typeof(upper) === 'number'){\n        this.upperLimit = upper;\n        this.upperLimitEnabled = true;\n    } else {\n        this.upperLimit = upper;\n        this.upperLimitEnabled = false;\n    }\n};\n\n","var Constraint = require('./Constraint')\n,   Equation = require('../equations/Equation')\n,   RotationalVelocityEquation = require('../equations/RotationalVelocityEquation')\n,   RotationalLockEquation = require('../equations/RotationalLockEquation')\n,   vec2 = require('../math/vec2');\n\nmodule.exports = RevoluteConstraint;\n\nvar worldPivotA = vec2.create(),\n    worldPivotB = vec2.create(),\n    xAxis = vec2.fromValues(1,0),\n    yAxis = vec2.fromValues(0,1),\n    g = vec2.create();\n\n/**\n * Connects two bodies at given offset points, letting them rotate relative to each other around this point.\n * @class RevoluteConstraint\n * @constructor\n * @author schteppe\n * @param {Body}    bodyA\n * @param {Body}    bodyB\n * @param {Object}  [options]\n * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.\n * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.\n * @param {Array}   [options.localPivotB] See localPivotA.\n * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.\n * @extends Constraint\n *\n * @example\n *     // This will create a revolute constraint between two bodies with pivot point in between them.\n *     var bodyA = new Body({ mass: 1, position: [-1, 0] });\n *     var bodyB = new Body({ mass: 1, position: [1, 0] });\n *     var constraint = new RevoluteConstraint(bodyA, bodyB, {\n *         worldPivot: [0, 0]\n *     });\n *     world.addConstraint(constraint);\n *\n *     // Using body-local pivot points, the constraint could have been constructed like this:\n *     var constraint = new RevoluteConstraint(bodyA, bodyB, {\n *         localPivotA: [1, 0],\n *         localPivotB: [-1, 0]\n *     });\n */\nfunction RevoluteConstraint(bodyA, bodyB, options){\n    options = options || {};\n    Constraint.call(this,bodyA,bodyB,Constraint.REVOLUTE,options);\n\n    var maxForce = this.maxForce = typeof(options.maxForce) !== \"undefined\" ? options.maxForce : Number.MAX_VALUE;\n\n    /**\n     * @property {Array} pivotA\n     */\n    this.pivotA = vec2.create();\n\n    /**\n     * @property {Array} pivotB\n     */\n    this.pivotB = vec2.create();\n\n    if(options.worldPivot){\n        // Compute pivotA and pivotB\n        vec2.sub(this.pivotA, options.worldPivot, bodyA.position);\n        vec2.sub(this.pivotB, options.worldPivot, bodyB.position);\n        // Rotate to local coordinate system\n        vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);\n        vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);\n    } else {\n        // Get pivotA and pivotB\n        vec2.copy(this.pivotA, options.localPivotA);\n        vec2.copy(this.pivotB, options.localPivotB);\n    }\n\n    // Equations to be fed to the solver\n    var eqs = this.equations = [\n        new Equation(bodyA,bodyB,-maxForce,maxForce),\n        new Equation(bodyA,bodyB,-maxForce,maxForce),\n    ];\n\n    var x = eqs[0];\n    var y = eqs[1];\n    var that = this;\n\n    x.computeGq = function(){\n        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);\n        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);\n        vec2.add(g, bodyB.position, worldPivotB);\n        vec2.sub(g, g, bodyA.position);\n        vec2.sub(g, g, worldPivotA);\n        return vec2.dot(g,xAxis);\n    };\n\n    y.computeGq = function(){\n        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);\n        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);\n        vec2.add(g, bodyB.position, worldPivotB);\n        vec2.sub(g, g, bodyA.position);\n        vec2.sub(g, g, worldPivotA);\n        return vec2.dot(g,yAxis);\n    };\n\n    y.minForce = x.minForce = -maxForce;\n    y.maxForce = x.maxForce =  maxForce;\n\n    this.motorEquation = new RotationalVelocityEquation(bodyA,bodyB);\n\n    /**\n     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.\n     * @property {Boolean} motorEnabled\n     * @readOnly\n     */\n    this.motorEnabled = false;\n\n    /**\n     * The constraint position.\n     * @property angle\n     * @type {Number}\n     * @readOnly\n     */\n    this.angle = 0;\n\n    /**\n     * Set to true to enable lower limit\n     * @property lowerLimitEnabled\n     * @type {Boolean}\n     */\n    this.lowerLimitEnabled = false;\n\n    /**\n     * Set to true to enable upper limit\n     * @property upperLimitEnabled\n     * @type {Boolean}\n     */\n    this.upperLimitEnabled = false;\n\n    /**\n     * The lower limit on the constraint angle.\n     * @property lowerLimit\n     * @type {Boolean}\n     */\n    this.lowerLimit = 0;\n\n    /**\n     * The upper limit on the constraint angle.\n     * @property upperLimit\n     * @type {Boolean}\n     */\n    this.upperLimit = 0;\n\n    this.upperLimitEquation = new RotationalLockEquation(bodyA,bodyB);\n    this.lowerLimitEquation = new RotationalLockEquation(bodyA,bodyB);\n    this.upperLimitEquation.minForce = 0;\n    this.lowerLimitEquation.maxForce = 0;\n}\nRevoluteConstraint.prototype = new Constraint();\nRevoluteConstraint.prototype.constructor = RevoluteConstraint;\n\n/**\n * Set the constraint angle limits.\n * @method setLimits\n * @param {number} lower Lower angle limit.\n * @param {number} upper Upper angle limit.\n */\nRevoluteConstraint.prototype.setLimits = function (lower, upper) {\n    if(typeof(lower) === 'number'){\n        this.lowerLimit = lower;\n        this.lowerLimitEnabled = true;\n    } else {\n        this.lowerLimit = lower;\n        this.lowerLimitEnabled = false;\n    }\n\n    if(typeof(upper) === 'number'){\n        this.upperLimit = upper;\n        this.upperLimitEnabled = true;\n    } else {\n        this.upperLimit = upper;\n        this.upperLimitEnabled = false;\n    }\n};\n\nRevoluteConstraint.prototype.update = function(){\n    var bodyA =  this.bodyA,\n        bodyB =  this.bodyB,\n        pivotA = this.pivotA,\n        pivotB = this.pivotB,\n        eqs =    this.equations,\n        normal = eqs[0],\n        tangent= eqs[1],\n        x = eqs[0],\n        y = eqs[1],\n        upperLimit = this.upperLimit,\n        lowerLimit = this.lowerLimit,\n        upperLimitEquation = this.upperLimitEquation,\n        lowerLimitEquation = this.lowerLimitEquation;\n\n    var relAngle = this.angle = bodyB.angle - bodyA.angle;\n\n    if(this.upperLimitEnabled && relAngle > upperLimit){\n        upperLimitEquation.angle = upperLimit;\n        if(eqs.indexOf(upperLimitEquation) === -1){\n            eqs.push(upperLimitEquation);\n        }\n    } else {\n        var idx = eqs.indexOf(upperLimitEquation);\n        if(idx !== -1){\n            eqs.splice(idx,1);\n        }\n    }\n\n    if(this.lowerLimitEnabled && relAngle < lowerLimit){\n        lowerLimitEquation.angle = lowerLimit;\n        if(eqs.indexOf(lowerLimitEquation) === -1){\n            eqs.push(lowerLimitEquation);\n        }\n    } else {\n        var idx = eqs.indexOf(lowerLimitEquation);\n        if(idx !== -1){\n            eqs.splice(idx,1);\n        }\n    }\n\n    /*\n\n    The constraint violation is\n\n        g = xj + rj - xi - ri\n\n    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:\n\n        gdot = vj + wj x rj - vi - wi x ri\n\n    We split this into x and y directions. (let x and y be unit vectors along the respective axes)\n\n        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x\n                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x\n                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi\n                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]\n                 = G*W\n\n    ...and similar for y. We have then identified the jacobian entries for x and y directions:\n\n        Gx = [ x   (rj x x)   -x   -(ri x x)]\n        Gy = [ y   (rj x y)   -y   -(ri x y)]\n\n     */\n\n    vec2.rotate(worldPivotA, pivotA, bodyA.angle);\n    vec2.rotate(worldPivotB, pivotB, bodyB.angle);\n\n    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc\n\n    x.G[0] = -1;\n    x.G[1] =  0;\n    x.G[2] = -vec2.crossLength(worldPivotA,xAxis);\n    x.G[3] =  1;\n    x.G[4] =  0;\n    x.G[5] =  vec2.crossLength(worldPivotB,xAxis);\n\n    y.G[0] =  0;\n    y.G[1] = -1;\n    y.G[2] = -vec2.crossLength(worldPivotA,yAxis);\n    y.G[3] =  0;\n    y.G[4] =  1;\n    y.G[5] =  vec2.crossLength(worldPivotB,yAxis);\n};\n\n/**\n * Enable the rotational motor\n * @method enableMotor\n */\nRevoluteConstraint.prototype.enableMotor = function(){\n    if(this.motorEnabled){\n        return;\n    }\n    this.equations.push(this.motorEquation);\n    this.motorEnabled = true;\n};\n\n/**\n * Disable the rotational motor\n * @method disableMotor\n */\nRevoluteConstraint.prototype.disableMotor = function(){\n    if(!this.motorEnabled){\n        return;\n    }\n    var i = this.equations.indexOf(this.motorEquation);\n    this.equations.splice(i,1);\n    this.motorEnabled = false;\n};\n\n/**\n * Check if the motor is enabled.\n * @method motorIsEnabled\n * @deprecated use property motorEnabled instead.\n * @return {Boolean}\n */\nRevoluteConstraint.prototype.motorIsEnabled = function(){\n    return !!this.motorEnabled;\n};\n\n/**\n * Set the speed of the rotational constraint motor\n * @method setMotorSpeed\n * @param  {Number} speed\n */\nRevoluteConstraint.prototype.setMotorSpeed = function(speed){\n    if(!this.motorEnabled){\n        return;\n    }\n    var i = this.equations.indexOf(this.motorEquation);\n    this.equations[i].relativeVelocity = speed;\n};\n\n/**\n * Get the speed of the rotational constraint motor\n * @method getMotorSpeed\n * @return {Number} The current speed, or false if the motor is not enabled.\n */\nRevoluteConstraint.prototype.getMotorSpeed = function(){\n    if(!this.motorEnabled){\n        return false;\n    }\n    return this.motorEquation.relativeVelocity;\n};\n","var Equation = require(\"./Equation\"),\n    vec2 = require('../math/vec2');\n\nmodule.exports = AngleLockEquation;\n\n/**\n * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.\n *\n * @class AngleLockEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {Number} [options.angle] Angle to add to the local vector in body A.\n * @param {Number} [options.ratio] Gear ratio\n */\nfunction AngleLockEquation(bodyA, bodyB, options){\n    options = options || {};\n    Equation.call(this,bodyA,bodyB,-Number.MAX_VALUE,Number.MAX_VALUE);\n    this.angle = options.angle || 0;\n\n    /**\n     * The gear ratio.\n     * @property {Number} ratio\n     * @private\n     * @see setRatio\n     */\n    this.ratio = typeof(options.ratio)===\"number\" ? options.ratio : 1;\n\n    this.setRatio(this.ratio);\n}\nAngleLockEquation.prototype = new Equation();\nAngleLockEquation.prototype.constructor = AngleLockEquation;\n\nAngleLockEquation.prototype.computeGq = function(){\n    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;\n};\n\n/**\n * Set the gear ratio for this equation\n * @method setRatio\n * @param {Number} ratio\n */\nAngleLockEquation.prototype.setRatio = function(ratio){\n    var G = this.G;\n    G[2] =  ratio;\n    G[5] = -1;\n    this.ratio = ratio;\n};\n\n/**\n * Set the max force for the equation.\n * @method setMaxTorque\n * @param {Number} torque\n */\nAngleLockEquation.prototype.setMaxTorque = function(torque){\n    this.maxForce =  torque;\n    this.minForce = -torque;\n};\n","var Equation = require(\"./Equation\"),\n    vec2 = require('../math/vec2');\n\nmodule.exports = ContactEquation;\n\n/**\n * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.\n *\n * @class ContactEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nfunction ContactEquation(bodyA, bodyB){\n    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);\n\n    /**\n     * Vector from body i center of mass to the contact point.\n     * @property contactPointA\n     * @type {Array}\n     */\n    this.contactPointA = vec2.create();\n    this.penetrationVec = vec2.create();\n\n    /**\n     * World-oriented vector from body A center of mass to the contact point.\n     * @property contactPointB\n     * @type {Array}\n     */\n    this.contactPointB = vec2.create();\n\n    /**\n     * The normal vector, pointing out of body i\n     * @property normalA\n     * @type {Array}\n     */\n    this.normalA = vec2.create();\n\n    /**\n     * The restitution to use (0=no bounciness, 1=max bounciness).\n     * @property restitution\n     * @type {Number}\n     */\n    this.restitution = 0;\n\n    /**\n     * This property is set to true if this is the first impact between the bodies (not persistant contact).\n     * @property firstImpact\n     * @type {Boolean}\n     * @readOnly\n     */\n    this.firstImpact = false;\n\n    /**\n     * The shape in body i that triggered this contact.\n     * @property shapeA\n     * @type {Shape}\n     */\n    this.shapeA = null;\n\n    /**\n     * The shape in body j that triggered this contact.\n     * @property shapeB\n     * @type {Shape}\n     */\n    this.shapeB = null;\n}\nContactEquation.prototype = new Equation();\nContactEquation.prototype.constructor = ContactEquation;\nContactEquation.prototype.computeB = function(a,b,h){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        ri = this.contactPointA,\n        rj = this.contactPointB,\n        xi = bi.position,\n        xj = bj.position;\n\n    var penetrationVec = this.penetrationVec,\n        n = this.normalA,\n        G = this.G;\n\n    // Caluclate cross products\n    var rixn = vec2.crossLength(ri,n),\n        rjxn = vec2.crossLength(rj,n);\n\n    // G = [-n -rixn n rjxn]\n    G[0] = -n[0];\n    G[1] = -n[1];\n    G[2] = -rixn;\n    G[3] = n[0];\n    G[4] = n[1];\n    G[5] = rjxn;\n\n    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector\n    vec2.add(penetrationVec,xj,rj);\n    vec2.sub(penetrationVec,penetrationVec,xi);\n    vec2.sub(penetrationVec,penetrationVec,ri);\n\n    // Compute iteration\n    var GW, Gq;\n    if(this.firstImpact && this.restitution !== 0){\n        Gq = 0;\n        GW = (1/b)*(1+this.restitution) * this.computeGW();\n    } else {\n        Gq = vec2.dot(n,penetrationVec) + this.offset;\n        GW = this.computeGW();\n    }\n\n    var GiMf = this.computeGiMf();\n    var B = - Gq * a - GW * b - h*GiMf;\n\n    return B;\n};\n\nvar vi = vec2.create();\nvar vj = vec2.create();\nvar relVel = vec2.create();\n\n/**\n * Get the relative velocity along the normal vector.\n * @return {number}\n */\nContactEquation.prototype.getVelocityAlongNormal = function(){\n\n    this.bodyA.getVelocityAtPoint(vi, this.contactPointA);\n    this.bodyB.getVelocityAtPoint(vj, this.contactPointB);\n\n    vec2.subtract(relVel, vi, vj);\n\n    return vec2.dot(this.normalA, relVel);\n};","module.exports = Equation;\n\nvar vec2 = require('../math/vec2'),\n    Utils = require('../utils/Utils'),\n    Body = require('../objects/Body');\n\n/**\n * Base class for constraint equations.\n * @class Equation\n * @constructor\n * @param {Body} bodyA First body participating in the equation\n * @param {Body} bodyB Second body participating in the equation\n * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE\n * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE\n */\nfunction Equation(bodyA, bodyB, minForce, maxForce){\n\n    /**\n     * Minimum force to apply when solving.\n     * @property minForce\n     * @type {Number}\n     */\n    this.minForce = typeof(minForce)===\"undefined\" ? -Number.MAX_VALUE : minForce;\n\n    /**\n     * Max force to apply when solving.\n     * @property maxForce\n     * @type {Number}\n     */\n    this.maxForce = typeof(maxForce)===\"undefined\" ? Number.MAX_VALUE : maxForce;\n\n    /**\n     * First body participating in the constraint\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second body participating in the constraint\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.\n     * @property stiffness\n     * @type {Number}\n     */\n    this.stiffness = Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.\n     * @property relaxation\n     * @type {Number}\n     */\n    this.relaxation = Equation.DEFAULT_RELAXATION;\n\n    /**\n     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).\n     * @property G\n     * @type {Array}\n     */\n    this.G = new Utils.ARRAY_TYPE(6);\n    for(var i=0; i<6; i++){\n        this.G[i]=0;\n    }\n\n    this.offset = 0;\n\n    this.a = 0;\n    this.b = 0;\n    this.epsilon = 0;\n    this.timeStep = 1/60;\n\n    /**\n     * Indicates if stiffness or relaxation was changed.\n     * @property {Boolean} needsUpdate\n     */\n    this.needsUpdate = true;\n\n    /**\n     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.\n     * @property multiplier\n     * @type {Number}\n     */\n    this.multiplier = 0;\n\n    /**\n     * Relative velocity.\n     * @property {Number} relativeVelocity\n     */\n    this.relativeVelocity = 0;\n\n    /**\n     * Whether this equation is enabled or not. If true, it will be added to the solver.\n     * @property {Boolean} enabled\n     */\n    this.enabled = true;\n}\nEquation.prototype.constructor = Equation;\n\n/**\n * The default stiffness when creating a new Equation.\n * @static\n * @property {Number} DEFAULT_STIFFNESS\n * @default 1e6\n */\nEquation.DEFAULT_STIFFNESS = 1e6;\n\n/**\n * The default relaxation when creating a new Equation.\n * @static\n * @property {Number} DEFAULT_RELAXATION\n * @default 4\n */\nEquation.DEFAULT_RELAXATION = 4;\n\n/**\n * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href=\"http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf\">SPOOK notes</a>.\n * @method update\n */\nEquation.prototype.update = function(){\n    var k = this.stiffness,\n        d = this.relaxation,\n        h = this.timeStep;\n\n    this.a = 4.0 / (h * (1 + 4 * d));\n    this.b = (4.0 * d) / (1 + 4 * d);\n    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));\n\n    this.needsUpdate = false;\n};\n\n/**\n * Multiply a jacobian entry with corresponding positions or velocities\n * @method gmult\n * @return {Number}\n */\nEquation.prototype.gmult = function(G,vi,wi,vj,wj){\n    return  G[0] * vi[0] +\n            G[1] * vi[1] +\n            G[2] * wi +\n            G[3] * vj[0] +\n            G[4] * vj[1] +\n            G[5] * wj;\n};\n\n/**\n * Computes the RHS of the SPOOK equation\n * @method computeB\n * @return {Number}\n */\nEquation.prototype.computeB = function(a,b,h){\n    var GW = this.computeGW();\n    var Gq = this.computeGq();\n    var GiMf = this.computeGiMf();\n    return - Gq * a - GW * b - GiMf*h;\n};\n\n/**\n * Computes G\\*q, where q are the generalized body coordinates\n * @method computeGq\n * @return {Number}\n */\nvar qi = vec2.create(),\n    qj = vec2.create();\nEquation.prototype.computeGq = function(){\n    var G = this.G,\n        bi = this.bodyA,\n        bj = this.bodyB,\n        xi = bi.position,\n        xj = bj.position,\n        ai = bi.angle,\n        aj = bj.angle;\n\n    return this.gmult(G, qi, ai, qj, aj) + this.offset;\n};\n\n/**\n * Computes G\\*W, where W are the body velocities\n * @method computeGW\n * @return {Number}\n */\nEquation.prototype.computeGW = function(){\n    var G = this.G,\n        bi = this.bodyA,\n        bj = this.bodyB,\n        vi = bi.velocity,\n        vj = bj.velocity,\n        wi = bi.angularVelocity,\n        wj = bj.angularVelocity;\n    return this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;\n};\n\n/**\n * Computes G\\*Wlambda, where W are the body velocities\n * @method computeGWlambda\n * @return {Number}\n */\nEquation.prototype.computeGWlambda = function(){\n    var G = this.G,\n        bi = this.bodyA,\n        bj = this.bodyB,\n        vi = bi.vlambda,\n        vj = bj.vlambda,\n        wi = bi.wlambda,\n        wj = bj.wlambda;\n    return this.gmult(G,vi,wi,vj,wj);\n};\n\n/**\n * Computes G\\*inv(M)\\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.\n * @method computeGiMf\n * @return {Number}\n */\nvar iMfi = vec2.create(),\n    iMfj = vec2.create();\nEquation.prototype.computeGiMf = function(){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        fi = bi.force,\n        ti = bi.angularForce,\n        fj = bj.force,\n        tj = bj.angularForce,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve,\n        invIi = bi.invInertiaSolve,\n        invIj = bj.invInertiaSolve,\n        G = this.G;\n\n    vec2.scale(iMfi, fi, invMassi);\n    vec2.multiply(iMfi, bi.massMultiplier, iMfi);\n    vec2.scale(iMfj, fj,invMassj);\n    vec2.multiply(iMfj, bj.massMultiplier, iMfj);\n\n    return this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);\n};\n\n/**\n * Computes G\\*inv(M)\\*G'\n * @method computeGiMGt\n * @return {Number}\n */\nEquation.prototype.computeGiMGt = function(){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve,\n        invIi = bi.invInertiaSolve,\n        invIj = bj.invInertiaSolve,\n        G = this.G;\n\n    return  G[0] * G[0] * invMassi * bi.massMultiplier[0] +\n            G[1] * G[1] * invMassi * bi.massMultiplier[1] +\n            G[2] * G[2] *    invIi +\n            G[3] * G[3] * invMassj * bj.massMultiplier[0] +\n            G[4] * G[4] * invMassj * bj.massMultiplier[1] +\n            G[5] * G[5] *    invIj;\n};\n\nvar addToWlambda_temp = vec2.create(),\n    addToWlambda_Gi = vec2.create(),\n    addToWlambda_Gj = vec2.create(),\n    addToWlambda_ri = vec2.create(),\n    addToWlambda_rj = vec2.create(),\n    addToWlambda_Mdiag = vec2.create();\n\n/**\n * Add constraint velocity to the bodies.\n * @method addToWlambda\n * @param {Number} deltalambda\n */\nEquation.prototype.addToWlambda = function(deltalambda){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        temp = addToWlambda_temp,\n        Gi = addToWlambda_Gi,\n        Gj = addToWlambda_Gj,\n        ri = addToWlambda_ri,\n        rj = addToWlambda_rj,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve,\n        invIi = bi.invInertiaSolve,\n        invIj = bj.invInertiaSolve,\n        Mdiag = addToWlambda_Mdiag,\n        G = this.G;\n\n    Gi[0] = G[0];\n    Gi[1] = G[1];\n    Gj[0] = G[3];\n    Gj[1] = G[4];\n\n    // Add to linear velocity\n    // v_lambda += inv(M) * delta_lamba * G\n    vec2.scale(temp, Gi, invMassi*deltalambda);\n    vec2.multiply(temp, temp, bi.massMultiplier);\n    vec2.add( bi.vlambda, bi.vlambda, temp);\n    // This impulse is in the offset frame\n    // Also add contribution to angular\n    //bi.wlambda -= vec2.crossLength(temp,ri);\n    bi.wlambda += invIi * G[2] * deltalambda;\n\n\n    vec2.scale(temp, Gj, invMassj*deltalambda);\n    vec2.multiply(temp, temp, bj.massMultiplier);\n    vec2.add( bj.vlambda, bj.vlambda, temp);\n    //bj.wlambda -= vec2.crossLength(temp,rj);\n    bj.wlambda += invIj * G[5] * deltalambda;\n};\n\n/**\n * Compute the denominator part of the SPOOK equation: C = G\\*inv(M)\\*G' + eps\n * @method computeInvC\n * @param  {Number} eps\n * @return {Number}\n */\nEquation.prototype.computeInvC = function(eps){\n    return 1.0 / (this.computeGiMGt() + eps);\n};\n","var vec2 = require('../math/vec2')\n,   Equation = require('./Equation')\n,   Utils = require('../utils/Utils');\n\nmodule.exports = FrictionEquation;\n\n/**\n * Constrains the slipping in a contact along a tangent\n *\n * @class FrictionEquation\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} slipForce\n * @extends Equation\n */\nfunction FrictionEquation(bodyA, bodyB, slipForce){\n    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);\n\n    /**\n     * Relative vector from center of body A to the contact point, world oriented.\n     * @property contactPointA\n     * @type {Array}\n     */\n    this.contactPointA = vec2.create();\n\n    /**\n     * Relative vector from center of body B to the contact point, world oriented.\n     * @property contactPointB\n     * @type {Array}\n     */\n    this.contactPointB = vec2.create();\n\n    /**\n     * Tangent vector that the friction force will act along. World oriented.\n     * @property t\n     * @type {Array}\n     */\n    this.t = vec2.create();\n\n    /**\n     * ContactEquations connected to this friction equation. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.\n     * @property contactEquations\n     * @type {ContactEquation}\n     */\n    this.contactEquations = [];\n\n    /**\n     * The shape in body i that triggered this friction.\n     * @property shapeA\n     * @type {Shape}\n     * @todo Needed? The shape can be looked up via contactEquation.shapeA...\n     */\n    this.shapeA = null;\n\n    /**\n     * The shape in body j that triggered this friction.\n     * @property shapeB\n     * @type {Shape}\n     * @todo Needed? The shape can be looked up via contactEquation.shapeB...\n     */\n    this.shapeB = null;\n\n    /**\n     * The friction coefficient to use.\n     * @property frictionCoefficient\n     * @type {Number}\n     */\n    this.frictionCoefficient = 0.3;\n}\nFrictionEquation.prototype = new Equation();\nFrictionEquation.prototype.constructor = FrictionEquation;\n\n/**\n * Set the slipping condition for the constraint. The friction force cannot be\n * larger than this value.\n * @method setSlipForce\n * @param  {Number} slipForce\n */\nFrictionEquation.prototype.setSlipForce = function(slipForce){\n    this.maxForce = slipForce;\n    this.minForce = -slipForce;\n};\n\n/**\n * Get the max force for the constraint.\n * @method getSlipForce\n * @return {Number}\n */\nFrictionEquation.prototype.getSlipForce = function(){\n    return this.maxForce;\n};\n\nFrictionEquation.prototype.computeB = function(a,b,h){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        ri = this.contactPointA,\n        rj = this.contactPointB,\n        t = this.t,\n        G = this.G;\n\n    // G = [-t -rixt t rjxt]\n    // And remember, this is a pure velocity constraint, g is always zero!\n    G[0] = -t[0];\n    G[1] = -t[1];\n    G[2] = -vec2.crossLength(ri,t);\n    G[3] = t[0];\n    G[4] = t[1];\n    G[5] = vec2.crossLength(rj,t);\n\n    var GW = this.computeGW(),\n        GiMf = this.computeGiMf();\n\n    var B = /* - g * a  */ - GW * b - h*GiMf;\n\n    return B;\n};\n","var Equation = require(\"./Equation\"),\n    vec2 = require('../math/vec2');\n\nmodule.exports = RotationalLockEquation;\n\n/**\n * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.\n *\n * @class RotationalLockEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {Number} [options.angle] Angle to add to the local vector in bodyA.\n */\nfunction RotationalLockEquation(bodyA, bodyB, options){\n    options = options || {};\n    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);\n\n    /**\n     * @property {number} angle\n     */\n    this.angle = options.angle || 0;\n\n    var G = this.G;\n    G[2] =  1;\n    G[5] = -1;\n}\nRotationalLockEquation.prototype = new Equation();\nRotationalLockEquation.prototype.constructor = RotationalLockEquation;\n\nvar worldVectorA = vec2.create(),\n    worldVectorB = vec2.create(),\n    xAxis = vec2.fromValues(1,0),\n    yAxis = vec2.fromValues(0,1);\nRotationalLockEquation.prototype.computeGq = function(){\n    vec2.rotate(worldVectorA,xAxis,this.bodyA.angle+this.angle);\n    vec2.rotate(worldVectorB,yAxis,this.bodyB.angle);\n    return vec2.dot(worldVectorA,worldVectorB);\n};\n","var Equation = require(\"./Equation\"),\n    vec2 = require('../math/vec2');\n\nmodule.exports = RotationalVelocityEquation;\n\n/**\n * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).\n *\n * @class RotationalVelocityEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nfunction RotationalVelocityEquation(bodyA, bodyB){\n    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);\n    this.relativeVelocity = 1;\n    this.ratio = 1;\n}\nRotationalVelocityEquation.prototype = new Equation();\nRotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;\nRotationalVelocityEquation.prototype.computeB = function(a,b,h){\n    var G = this.G;\n    G[2] = -1;\n    G[5] = this.ratio;\n\n    var GiMf = this.computeGiMf();\n    var GW = this.computeGW();\n    var B = - GW * b - h*GiMf;\n\n    return B;\n};\n","/**\n * Base class for objects that dispatches events.\n * @class EventEmitter\n * @constructor\n */\nvar EventEmitter = function () {};\n\nmodule.exports = EventEmitter;\n\nEventEmitter.prototype = {\n    constructor: EventEmitter,\n\n    /**\n     * Add an event listener\n     * @method on\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {EventEmitter} The self object, for chainability.\n     */\n    on: function ( type, listener, context ) {\n        listener.context = context || this;\n        if ( this._listeners === undefined ){\n            this._listeners = {};\n        }\n        var listeners = this._listeners;\n        if ( listeners[ type ] === undefined ) {\n            listeners[ type ] = [];\n        }\n        if ( listeners[ type ].indexOf( listener ) === - 1 ) {\n            listeners[ type ].push( listener );\n        }\n        return this;\n    },\n\n    /**\n     * Check if an event listener is added\n     * @method has\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {Boolean}\n     */\n    has: function ( type, listener ) {\n        if ( this._listeners === undefined ){\n            return false;\n        }\n        var listeners = this._listeners;\n        if(listener){\n            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n                return true;\n            }\n        } else {\n            if ( listeners[ type ] !== undefined ) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    /**\n     * Remove an event listener\n     * @method off\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {EventEmitter} The self object, for chainability.\n     */\n    off: function ( type, listener ) {\n        if ( this._listeners === undefined ){\n            return this;\n        }\n        var listeners = this._listeners;\n        var index = listeners[ type ].indexOf( listener );\n        if ( index !== - 1 ) {\n            listeners[ type ].splice( index, 1 );\n        }\n        return this;\n    },\n\n    /**\n     * Emit an event.\n     * @method emit\n     * @param  {Object} event\n     * @param  {String} event.type\n     * @return {EventEmitter} The self object, for chainability.\n     */\n    emit: function ( event ) {\n        if ( this._listeners === undefined ){\n            return this;\n        }\n        var listeners = this._listeners;\n        var listenerArray = listeners[ event.type ];\n        if ( listenerArray !== undefined ) {\n            event.target = this;\n            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {\n                var listener = listenerArray[ i ];\n                listener.call( listener.context, event );\n            }\n        }\n        return this;\n    }\n};\n","var Material = require('./Material');\nvar Equation = require('../equations/Equation');\n\nmodule.exports = ContactMaterial;\n\n/**\n * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.\n * @class ContactMaterial\n * @constructor\n * @param {Material} materialA\n * @param {Material} materialB\n * @param {Object}   [options]\n * @param {Number}   [options.friction=0.3]       Friction coefficient.\n * @param {Number}   [options.restitution=0]      Restitution coefficient aka \"bounciness\".\n * @param {Number}   [options.stiffness]          ContactEquation stiffness.\n * @param {Number}   [options.relaxation]         ContactEquation relaxation.\n * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.\n * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.\n * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.\n * @author schteppe\n */\nfunction ContactMaterial(materialA, materialB, options){\n    options = options || {};\n\n    if(!(materialA instanceof Material) || !(materialB instanceof Material)){\n        throw new Error(\"First two arguments must be Material instances.\");\n    }\n\n    /**\n     * The contact material identifier\n     * @property id\n     * @type {Number}\n     */\n    this.id = ContactMaterial.idCounter++;\n\n    /**\n     * First material participating in the contact material\n     * @property materialA\n     * @type {Material}\n     */\n    this.materialA = materialA;\n\n    /**\n     * Second material participating in the contact material\n     * @property materialB\n     * @type {Material}\n     */\n    this.materialB = materialB;\n\n    /**\n     * Friction coefficient to use in the contact of these two materials. Friction = 0 will make the involved objects super slippery, and friction = 1 will make it much less slippery. A friction coefficient larger than 1 will allow for very large friction forces, which can be convenient for preventing car tires not slip on the ground.\n     * @property friction\n     * @type {Number}\n     * @default 0.3\n     */\n    this.friction = typeof(options.friction) !== \"undefined\" ? Number(options.friction) : 0.3;\n\n    /**\n     * Restitution, or \"bounciness\" to use in the contact of these two materials. A restitution of 0 will make no bounce, while restitution=1 will approximately bounce back with the same velocity the object came with.\n     * @property restitution\n     * @type {Number}\n     * @default 0\n     */\n    this.restitution = typeof(options.restitution) !== \"undefined\" ? Number(options.restitution) : 0;\n\n    /**\n     * Hardness of the contact. Less stiffness will make the objects penetrate more, and will make the contact act more like a spring than a contact force. Default value is {{#crossLink \"Equation/DEFAULT_STIFFNESS:property\"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.\n     * @property stiffness\n     * @type {Number}\n     */\n    this.stiffness = typeof(options.stiffness) !== \"undefined\" ? Number(options.stiffness) : Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * Relaxation of the resulting ContactEquation that this ContactMaterial generate. Default value is {{#crossLink \"Equation/DEFAULT_RELAXATION:property\"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.\n     * @property relaxation\n     * @type {Number}\n     */\n    this.relaxation = typeof(options.relaxation) !== \"undefined\" ? Number(options.relaxation) : Equation.DEFAULT_RELAXATION;\n\n    /**\n     * Stiffness of the resulting friction force. For most cases, the value of this property should be a large number. I cannot think of any case where you would want less frictionStiffness. Default value is {{#crossLink \"Equation/DEFAULT_STIFFNESS:property\"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.\n     * @property frictionStiffness\n     * @type {Number}\n     */\n    this.frictionStiffness = typeof(options.frictionStiffness) !== \"undefined\" ? Number(options.frictionStiffness) : Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * Relaxation of the resulting friction force. The default value should be good for most simulations. Default value is {{#crossLink \"Equation/DEFAULT_RELAXATION:property\"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.\n     * @property frictionRelaxation\n     * @type {Number}\n     */\n    this.frictionRelaxation = typeof(options.frictionRelaxation) !== \"undefined\" ? Number(options.frictionRelaxation)  : Equation.DEFAULT_RELAXATION;\n\n    /**\n     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.\n     * @property {Number} surfaceVelocity\n     * @default 0\n     */\n    this.surfaceVelocity = typeof(options.surfaceVelocity) !== \"undefined\" ? Number(options.surfaceVelocity) : 0;\n\n    /**\n     * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka \"cure for nervous contacts\".\n     * @property contactSkinSize\n     * @type {Number}\n     */\n    this.contactSkinSize = 0.005;\n}\n\nContactMaterial.idCounter = 0;\n","module.exports = Material;\n\n/**\n * Defines a physics material.\n * @class Material\n * @constructor\n * @param {number} id Material identifier\n * @author schteppe\n */\nfunction Material(id){\n    /**\n     * The material identifier\n     * @property id\n     * @type {Number}\n     */\n    this.id = id || Material.idCounter++;\n}\n\nMaterial.idCounter = 0;\n","\n    /*\n        PolyK library\n        url: http://polyk.ivank.net\n        Released under MIT licence.\n\n        Copyright (c) 2012 Ivan Kuckir\n\n        Permission is hereby granted, free of charge, to any person\n        obtaining a copy of this software and associated documentation\n        files (the \"Software\"), to deal in the Software without\n        restriction, including without limitation the rights to use,\n        copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the\n        Software is furnished to do so, subject to the following\n        conditions:\n\n        The above copyright notice and this permission notice shall be\n        included in all copies or substantial portions of the Software.\n\n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n        OTHER DEALINGS IN THE SOFTWARE.\n    */\n\n    var PolyK = {};\n\n    /*\n        Is Polygon self-intersecting?\n\n        O(n^2)\n    */\n    /*\n    PolyK.IsSimple = function(p)\n    {\n        var n = p.length>>1;\n        if(n<4) return true;\n        var a1 = new PolyK._P(), a2 = new PolyK._P();\n        var b1 = new PolyK._P(), b2 = new PolyK._P();\n        var c = new PolyK._P();\n\n        for(var i=0; i<n; i++)\n        {\n            a1.x = p[2*i  ];\n            a1.y = p[2*i+1];\n            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }\n            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }\n\n            for(var j=0; j<n; j++)\n            {\n                if(Math.abs(i-j) < 2) continue;\n                if(j==n-1 && i==0) continue;\n                if(i==n-1 && j==0) continue;\n\n                b1.x = p[2*j  ];\n                b1.y = p[2*j+1];\n                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }\n                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }\n\n                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;\n            }\n        }\n        return true;\n    }\n\n    PolyK.IsConvex = function(p)\n    {\n        if(p.length<6) return true;\n        var l = p.length - 4;\n        for(var i=0; i<l; i+=2)\n            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;\n        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;\n        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;\n        return true;\n    }\n    */\n    PolyK.GetArea = function(p)\n    {\n        if(p.length <6) return 0;\n        var l = p.length - 2;\n        var sum = 0;\n        for(var i=0; i<l; i+=2)\n            sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);\n        sum += (p[0]-p[l]) * (p[l+1]+p[1]);\n        return - sum * 0.5;\n    }\n    /*\n    PolyK.GetAABB = function(p)\n    {\n        var minx = Infinity;\n        var miny = Infinity;\n        var maxx = -minx;\n        var maxy = -miny;\n        for(var i=0; i<p.length; i+=2)\n        {\n            minx = Math.min(minx, p[i  ]);\n            maxx = Math.max(maxx, p[i  ]);\n            miny = Math.min(miny, p[i+1]);\n            maxy = Math.max(maxy, p[i+1]);\n        }\n        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};\n    }\n    */\n\n    PolyK.Triangulate = function(p)\n    {\n        var n = p.length>>1;\n        if(n<3) return [];\n        var tgs = [];\n        var avl = [];\n        for(var i=0; i<n; i++) avl.push(i);\n\n        var i = 0;\n        var al = n;\n        while(al > 3)\n        {\n            var i0 = avl[(i+0)%al];\n            var i1 = avl[(i+1)%al];\n            var i2 = avl[(i+2)%al];\n\n            var ax = p[2*i0],  ay = p[2*i0+1];\n            var bx = p[2*i1],  by = p[2*i1+1];\n            var cx = p[2*i2],  cy = p[2*i2+1];\n\n            var earFound = false;\n            if(PolyK._convex(ax, ay, bx, by, cx, cy))\n            {\n                earFound = true;\n                for(var j=0; j<al; j++)\n                {\n                    var vi = avl[j];\n                    if(vi==i0 || vi==i1 || vi==i2) continue;\n                    if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}\n                }\n            }\n            if(earFound)\n            {\n                tgs.push(i0, i1, i2);\n                avl.splice((i+1)%al, 1);\n                al--;\n                i= 0;\n            }\n            else if(i++ > 3*al) break;      // no convex angles :(\n        }\n        tgs.push(avl[0], avl[1], avl[2]);\n        return tgs;\n    }\n    /*\n    PolyK.ContainsPoint = function(p, px, py)\n    {\n        var n = p.length>>1;\n        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;\n        var depth = 0;\n        for(var i=0; i<n; i++)\n        {\n            ax = bx;  ay = by;\n            bx = p[2*i  ] - px;\n            by = p[2*i+1] - py;\n            if(ay< 0 && by< 0) continue;    // both \"up\" or both \"donw\"\n            if(ay>=0 && by>=0) continue;    // both \"up\" or both \"donw\"\n            if(ax< 0 && bx< 0) continue;\n\n            var lx = ax + (bx-ax)*(-ay)/(by-ay);\n            if(lx>0) depth++;\n        }\n        return (depth & 1) == 1;\n    }\n\n    PolyK.Slice = function(p, ax, ay, bx, by)\n    {\n        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];\n\n        var a = new PolyK._P(ax, ay);\n        var b = new PolyK._P(bx, by);\n        var iscs = [];  // intersections\n        var ps = [];    // points\n        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));\n\n        for(var i=0; i<ps.length; i++)\n        {\n            var isc = new PolyK._P(0,0);\n            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);\n\n            if(isc)\n            {\n                isc.flag = true;\n                iscs.push(isc);\n                ps.splice(i+1,0,isc);\n                i++;\n            }\n        }\n        if(iscs.length == 0) return [p.slice(0)];\n        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }\n        iscs.sort(comp);\n\n        var pgs = [];\n        var dir = 0;\n        while(iscs.length > 0)\n        {\n            var n = ps.length;\n            var i0 = iscs[0];\n            var i1 = iscs[1];\n            var ind0 = ps.indexOf(i0);\n            var ind1 = ps.indexOf(i1);\n            var solved = false;\n\n            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;\n            else\n            {\n                i0 = iscs[1];\n                i1 = iscs[0];\n                ind0 = ps.indexOf(i0);\n                ind1 = ps.indexOf(i1);\n                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;\n            }\n            if(solved)\n            {\n                dir--;\n                var pgn = PolyK._getPoints(ps, ind0, ind1);\n                pgs.push(pgn);\n                ps = PolyK._getPoints(ps, ind1, ind0);\n                i0.flag = i1.flag = false;\n                iscs.splice(0,2);\n                if(iscs.length == 0) pgs.push(ps);\n            }\n            else { dir++; iscs.reverse(); }\n            if(dir>1) break;\n        }\n        var result = [];\n        for(var i=0; i<pgs.length; i++)\n        {\n            var pg = pgs[i];\n            var npg = [];\n            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);\n            result.push(npg);\n        }\n        return result;\n    }\n\n    PolyK.Raycast = function(p, x, y, dx, dy, isc)\n    {\n        var l = p.length - 2;\n        var tp = PolyK._tp;\n        var a1 = tp[0], a2 = tp[1],\n        b1 = tp[2], b2 = tp[3], c = tp[4];\n        a1.x = x; a1.y = y;\n        a2.x = x+dx; a2.y = y+dy;\n\n        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};\n        isc.dist = Infinity;\n\n        for(var i=0; i<l; i+=2)\n        {\n            b1.x = p[i  ];  b1.y = p[i+1];\n            b2.x = p[i+2];  b2.y = p[i+3];\n            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);\n            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);\n        }\n        b1.x = b2.x;  b1.y = b2.y;\n        b2.x = p[0];  b2.y = p[1];\n        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);\n        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);\n\n        return (isc.dist != Infinity) ? isc : null;\n    }\n\n    PolyK.ClosestEdge = function(p, x, y, isc)\n    {\n        var l = p.length - 2;\n        var tp = PolyK._tp;\n        var a1 = tp[0],\n        b1 = tp[2], b2 = tp[3], c = tp[4];\n        a1.x = x; a1.y = y;\n\n        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};\n        isc.dist = Infinity;\n\n        for(var i=0; i<l; i+=2)\n        {\n            b1.x = p[i  ];  b1.y = p[i+1];\n            b2.x = p[i+2];  b2.y = p[i+3];\n            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);\n        }\n        b1.x = b2.x;  b1.y = b2.y;\n        b2.x = p[0];  b2.y = p[1];\n        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);\n\n        var idst = 1/isc.dist;\n        isc.norm.x = (x-isc.point.x)*idst;\n        isc.norm.y = (y-isc.point.y)*idst;\n        return isc;\n    }\n\n    PolyK._pointLineDist = function(p, a, b, edge, isc)\n    {\n        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;\n\n        var A = x - x1;\n        var B = y - y1;\n        var C = x2 - x1;\n        var D = y2 - y1;\n\n        var dot = A * C + B * D;\n        var len_sq = C * C + D * D;\n        var param = dot / len_sq;\n\n        var xx, yy;\n\n        if (param < 0 || (x1 == x2 && y1 == y2)) {\n            xx = x1;\n            yy = y1;\n        }\n        else if (param > 1) {\n            xx = x2;\n            yy = y2;\n        }\n        else {\n            xx = x1 + param * C;\n            yy = y1 + param * D;\n        }\n\n        var dx = x - xx;\n        var dy = y - yy;\n        var dst = Math.sqrt(dx * dx + dy * dy);\n        if(dst<isc.dist)\n        {\n            isc.dist = dst;\n            isc.edge = edge;\n            isc.point.x = xx;\n            isc.point.y = yy;\n        }\n    }\n\n    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)\n    {\n        var nrl = PolyK._P.dist(a1, c);\n        if(nrl<isc.dist)\n        {\n            var ibl = 1/PolyK._P.dist(b1, b2);\n            var nx = -(b2.y-b1.y)*ibl;\n            var ny =  (b2.x-b1.x)*ibl;\n            var ddot = 2*(dx*nx+dy*ny);\n            isc.dist = nrl;\n            isc.norm.x = nx;\n            isc.norm.y = ny;\n            isc.refl.x = -ddot*nx+dx;\n            isc.refl.y = -ddot*ny+dy;\n            isc.edge = edge;\n        }\n    }\n\n    PolyK._getPoints = function(ps, ind0, ind1)\n    {\n        var n = ps.length;\n        var nps = [];\n        if(ind1<ind0) ind1 += n;\n        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);\n        return nps;\n    }\n\n    PolyK._firstWithFlag = function(ps, ind)\n    {\n        var n = ps.length;\n        while(true)\n        {\n            ind = (ind+1)%n;\n            if(ps[ind].flag) return ind;\n        }\n    }\n    */\n    PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)\n    {\n        var v0x = cx-ax;\n        var v0y = cy-ay;\n        var v1x = bx-ax;\n        var v1y = by-ay;\n        var v2x = px-ax;\n        var v2y = py-ay;\n\n        var dot00 = v0x*v0x+v0y*v0y;\n        var dot01 = v0x*v1x+v0y*v1y;\n        var dot02 = v0x*v2x+v0y*v2y;\n        var dot11 = v1x*v1x+v1y*v1y;\n        var dot12 = v1x*v2x+v1y*v2y;\n\n        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n        // Check if point is in triangle\n        return (u >= 0) && (v >= 0) && (u + v < 1);\n    }\n    /*\n    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)\n    {\n        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);\n        var day = (a1.y-a2.y), dby = (b1.y-b2.y);\n\n        var Den = dax*dby - day*dbx;\n        if (Den == 0) return null;  // parallel\n\n        var A = (a1.x * a2.y - a1.y * a2.x);\n        var B = (b1.x * b2.y - b1.y * b2.x);\n\n        var I = c;\n        var iDen = 1/Den;\n        I.x = ( A*dbx - dax*B ) * iDen;\n        I.y = ( A*dby - day*B ) * iDen;\n\n        if(!PolyK._InRect(I, b1, b2)) return null;\n        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;\n        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;\n        return I;\n    }\n\n    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)\n    {\n        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);\n        var day = (a1.y-a2.y), dby = (b1.y-b2.y);\n\n        var Den = dax*dby - day*dbx;\n        if (Den == 0) return null;  // parallel\n\n        var A = (a1.x * a2.y - a1.y * a2.x);\n        var B = (b1.x * b2.y - b1.y * b2.x);\n\n        var I = c;\n        I.x = ( A*dbx - dax*B ) / Den;\n        I.y = ( A*dby - day*B ) / Den;\n\n        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;\n        return null;\n    }\n\n    PolyK._InRect = function(a, b, c)\n    {\n        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));\n        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));\n\n        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)\n        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))\n        return true;\n        return false;\n    }\n    */\n    PolyK._convex = function(ax, ay, bx, by, cx, cy)\n    {\n        return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;\n    }\n    /*\n    PolyK._P = function(x,y)\n    {\n        this.x = x;\n        this.y = y;\n        this.flag = false;\n    }\n    PolyK._P.prototype.toString = function()\n    {\n        return \"Point [\"+this.x+\", \"+this.y+\"]\";\n    }\n    PolyK._P.dist = function(a,b)\n    {\n        var dx = b.x-a.x;\n        var dy = b.y-a.y;\n        return Math.sqrt(dx*dx + dy*dy);\n    }\n\n    PolyK._tp = [];\n    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));\n        */\n\nmodule.exports = PolyK;\n","/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.\n * @class vec2\n */\n\nvar vec2 = module.exports = {};\n\nvar Utils = require('../utils/Utils');\n\n/**\n * Make a cross product and only return the z component\n * @method crossLength\n * @static\n * @param  {Array} a\n * @param  {Array} b\n * @return {Number}\n */\nvec2.crossLength = function(a,b){\n    return a[0] * b[1] - a[1] * b[0];\n};\n\n/**\n * Cross product between a vector and the Z component of a vector\n * @method crossVZ\n * @static\n * @param  {Array} out\n * @param  {Array} vec\n * @param  {Number} zcomp\n * @return {Number}\n */\nvec2.crossVZ = function(out, vec, zcomp){\n    vec2.rotate(out,vec,-Math.PI/2);// Rotate according to the right hand rule\n    vec2.scale(out,out,zcomp);      // Scale with z\n    return out;\n};\n\n/**\n * Cross product between a vector and the Z component of a vector\n * @method crossZV\n * @static\n * @param  {Array} out\n * @param  {Number} zcomp\n * @param  {Array} vec\n * @return {Number}\n */\nvec2.crossZV = function(out, zcomp, vec){\n    vec2.rotate(out,vec,Math.PI/2); // Rotate according to the right hand rule\n    vec2.scale(out,out,zcomp);      // Scale with z\n    return out;\n};\n\n/**\n * Rotate a vector by an angle\n * @method rotate\n * @static\n * @param  {Array} out\n * @param  {Array} a\n * @param  {Number} angle\n */\nvec2.rotate = function(out,a,angle){\n    if(angle !== 0){\n        var c = Math.cos(angle),\n            s = Math.sin(angle),\n            x = a[0],\n            y = a[1];\n        out[0] = c*x -s*y;\n        out[1] = s*x +c*y;\n    } else {\n        out[0] = a[0];\n        out[1] = a[1];\n    }\n};\n\n/**\n * Rotate a vector 90 degrees clockwise\n * @method rotate90cw\n * @static\n * @param  {Array} out\n * @param  {Array} a\n * @param  {Number} angle\n */\nvec2.rotate90cw = function(out, a) {\n    var x = a[0];\n    var y = a[1];\n    out[0] = y;\n    out[1] = -x;\n};\n\n/**\n * Transform a point position to local frame.\n * @method toLocalFrame\n * @param  {Array} out\n * @param  {Array} worldPoint\n * @param  {Array} framePosition\n * @param  {Number} frameAngle\n */\nvec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle){\n    vec2.copy(out, worldPoint);\n    vec2.sub(out, out, framePosition);\n    vec2.rotate(out, out, -frameAngle);\n};\n\n/**\n * Transform a point position to global frame.\n * @method toGlobalFrame\n * @param  {Array} out\n * @param  {Array} localPoint\n * @param  {Array} framePosition\n * @param  {Number} frameAngle\n */\nvec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle){\n    vec2.copy(out, localPoint);\n    vec2.rotate(out, out, frameAngle);\n    vec2.add(out, out, framePosition);\n};\n\n/**\n * Transform a vector to local frame.\n * @method vectorToLocalFrame\n * @param  {Array} out\n * @param  {Array} worldVector\n * @param  {Number} frameAngle\n */\nvec2.vectorToLocalFrame = function(out, worldVector, frameAngle){\n    vec2.rotate(out, worldVector, -frameAngle);\n};\n\n/**\n * Transform a point position to global frame.\n * @method toGlobalFrame\n * @param  {Array} out\n * @param  {Array} localVector\n * @param  {Number} frameAngle\n */\nvec2.vectorToGlobalFrame = function(out, localVector, frameAngle){\n    vec2.rotate(out, localVector, frameAngle);\n};\n\n/**\n * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php\n * @method centroid\n * @static\n * @param  {Array} out\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return  {Array} The out object\n */\nvec2.centroid = function(out, a, b, c){\n    vec2.add(out, a, b);\n    vec2.add(out, out, c);\n    vec2.scale(out, out, 1/3);\n    return out;\n};\n\n/**\n * Creates a new, empty vec2\n * @static\n * @method create\n * @return {Array} a new 2D vector\n */\nvec2.create = function() {\n    var out = new Utils.ARRAY_TYPE(2);\n    out[0] = 0;\n    out[1] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n * @static\n * @method clone\n * @param {Array} a vector to clone\n * @return {Array} a new 2D vector\n */\nvec2.clone = function(a) {\n    var out = new Utils.ARRAY_TYPE(2);\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with the given values\n * @static\n * @method fromValues\n * @param {Number} x X component\n * @param {Number} y Y component\n * @return {Array} a new 2D vector\n */\nvec2.fromValues = function(x, y) {\n    var out = new Utils.ARRAY_TYPE(2);\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Copy the values from one vec2 to another\n * @static\n * @method copy\n * @param {Array} out the receiving vector\n * @param {Array} a the source vector\n * @return {Array} out\n */\nvec2.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Set the components of a vec2 to the given values\n * @static\n * @method set\n * @param {Array} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @return {Array} out\n */\nvec2.set = function(out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Adds two vec2's\n * @static\n * @method add\n * @param {Array} out the receiving vector\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Array} out\n */\nvec2.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n};\n\n/**\n * Subtracts two vec2's\n * @static\n * @method subtract\n * @param {Array} out the receiving vector\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Array} out\n */\nvec2.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n};\n\n/**\n * Alias for vec2.subtract\n * @static\n * @method sub\n */\nvec2.sub = vec2.subtract;\n\n/**\n * Multiplies two vec2's\n * @static\n * @method multiply\n * @param {Array} out the receiving vector\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Array} out\n */\nvec2.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n};\n\n/**\n * Alias for vec2.multiply\n * @static\n * @method mul\n */\nvec2.mul = vec2.multiply;\n\n/**\n * Divides two vec2's\n * @static\n * @method divide\n * @param {Array} out the receiving vector\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Array} out\n */\nvec2.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n};\n\n/**\n * Alias for vec2.divide\n * @static\n * @method div\n */\nvec2.div = vec2.divide;\n\n/**\n * Scales a vec2 by a scalar number\n * @static\n * @method scale\n * @param {Array} out the receiving vector\n * @param {Array} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @return {Array} out\n */\nvec2.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec2's\n * @static\n * @method distance\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Number} distance between a and b\n */\nvec2.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for vec2.distance\n * @static\n * @method dist\n */\nvec2.dist = vec2.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n * @static\n * @method squaredDistance\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Number} squared distance between a and b\n */\nvec2.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for vec2.squaredDistance\n * @static\n * @method sqrDist\n */\nvec2.sqrDist = vec2.squaredDistance;\n\n/**\n * Calculates the length of a vec2\n * @static\n * @method length\n * @param {Array} a vector to calculate length of\n * @return {Number} length of a\n */\nvec2.length = function (a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for vec2.length\n * @method len\n * @static\n */\nvec2.len = vec2.length;\n\n/**\n * Calculates the squared length of a vec2\n * @static\n * @method squaredLength\n * @param {Array} a vector to calculate squared length of\n * @return {Number} squared length of a\n */\nvec2.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for vec2.squaredLength\n * @static\n * @method sqrLen\n */\nvec2.sqrLen = vec2.squaredLength;\n\n/**\n * Negates the components of a vec2\n * @static\n * @method negate\n * @param {Array} out the receiving vector\n * @param {Array} a vector to negate\n * @return {Array} out\n */\nvec2.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n};\n\n/**\n * Normalize a vec2\n * @static\n * @method normalize\n * @param {Array} out the receiving vector\n * @param {Array} a vector to normalize\n * @return {Array} out\n */\nvec2.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x*x + y*y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec2's\n * @static\n * @method dot\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Number} dot product of a and b\n */\nvec2.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n};\n\n/**\n * Returns a string representation of a vector\n * @static\n * @method str\n * @param {Array} vec vector to represent as a string\n * @return {String} string representation of the vector\n */\nvec2.str = function (a) {\n    return 'vec2(' + a[0] + ', ' + a[1] + ')';\n};\n\n/**\n * Linearly interpolate/mix two vectors.\n * @static\n * @method lerp\n * @param {Array} out\n * @param {Array} a First vector\n * @param {Array} b Second vector\n * @param {number} t Lerp factor\n */\nvec2.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n};\n\n/**\n * Reflect a vector along a normal.\n * @static\n * @method reflect\n * @param {Array} out\n * @param {Array} vector\n * @param {Array} normal\n */\nvec2.reflect = function(out, vector, normal){\n    var dot = vector[0] * normal[0] + vector[1] * normal[1];\n    out[0] = vector[0] - 2 * normal[0] * dot;\n    out[1] = vector[1] - 2 * normal[1] * dot;\n};\n\n/**\n * Get the intersection point between two line segments.\n * @static\n * @method getLineSegmentsIntersection\n * @param  {Array} out\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @return {boolean} True if there was an intersection, otherwise false.\n */\nvec2.getLineSegmentsIntersection = function(out, p0, p1, p2, p3) {\n    var t = vec2.getLineSegmentsIntersectionFraction(p0, p1, p2, p3);\n    if(t < 0){\n        return false;\n    } else {\n        out[0] = p0[0] + (t * (p1[0] - p0[0]));\n        out[1] = p0[1] + (t * (p1[1] - p0[1]));\n        return true;\n    }\n};\n\n/**\n * Get the intersection fraction between two line segments. If successful, the intersection is at p0 + t * (p1 - p0)\n * @static\n * @method getLineSegmentsIntersectionFraction\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @return {number} A number between 0 and 1 if there was an intersection, otherwise -1.\n */\nvec2.getLineSegmentsIntersectionFraction = function(p0, p1, p2, p3) {\n    var s1_x = p1[0] - p0[0];\n    var s1_y = p1[1] - p0[1];\n    var s2_x = p3[0] - p2[0];\n    var s2_y = p3[1] - p2[1];\n\n    var s, t;\n    s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected\n        return t;\n    }\n    return -1; // No collision\n};\n","var vec2 = require('../math/vec2')\n,   decomp = require('poly-decomp')\n,   Convex = require('../shapes/Convex')\n,   RaycastResult = require('../collision/RaycastResult')\n,   Ray = require('../collision/Ray')\n,   AABB = require('../collision/AABB')\n,   EventEmitter = require('../events/EventEmitter');\n\nmodule.exports = Body;\n\n/**\n * A rigid body. Has got a center of mass, position, velocity and a number of\n * shapes that are used for collisions.\n *\n * @class Body\n * @constructor\n * @extends EventEmitter\n * @param {Object} [options]\n * @param {Array} [options.force]\n * @param {Array} [options.position]\n * @param {Array} [options.velocity]\n * @param {Boolean} [options.allowSleep]\n * @param {Boolean} [options.collisionResponse]\n * @param {Number} [options.angle=0]\n * @param {Number} [options.angularForce=0]\n * @param {Number} [options.angularVelocity=0]\n * @param {Number} [options.ccdIterations=10]\n * @param {Number} [options.ccdSpeedThreshold=-1]\n * @param {Number} [options.fixedRotation=false]\n * @param {Number} [options.gravityScale]\n * @param {Number} [options.id]\n * @param {Number} [options.mass=0] A number >= 0. If zero, the .type will be set to Body.STATIC.\n * @param {Number} [options.sleepSpeedLimit]\n * @param {Number} [options.sleepTimeLimit]\n *\n * @example\n *\n *     // Create a typical dynamic body\n *     var body = new Body({\n *         mass: 1,\n *         position: [0, 0],\n *         angle: 0,\n *         velocity: [0, 0],\n *         angularVelocity: 0\n *     });\n *\n *     // Add a circular shape to the body\n *     body.addShape(new Circle({ radius: 1 }));\n *\n *     // Add the body to the world\n *     world.addBody(body);\n */\nfunction Body(options){\n    options = options || {};\n\n    EventEmitter.call(this);\n\n    /**\n     * The body identifyer\n     * @property id\n     * @type {Number}\n     */\n    this.id = options.id || ++Body._idCounter;\n\n    /**\n     * The world that this body is added to. This property is set to NULL if the body is not added to any world.\n     * @property world\n     * @type {World}\n     */\n    this.world = null;\n\n    /**\n     * The shapes of the body.\n     *\n     * @property shapes\n     * @type {Array}\n     */\n    this.shapes = [];\n\n    /**\n     * The mass of the body.\n     * @property mass\n     * @type {number}\n     */\n    this.mass = options.mass || 0;\n\n    /**\n     * The inverse mass of the body.\n     * @property invMass\n     * @type {number}\n     */\n    this.invMass = 0;\n\n    /**\n     * The inertia of the body around the Z axis.\n     * @property inertia\n     * @type {number}\n     */\n    this.inertia = 0;\n\n    /**\n     * The inverse inertia of the body.\n     * @property invInertia\n     * @type {number}\n     */\n    this.invInertia = 0;\n\n    this.invMassSolve = 0;\n    this.invInertiaSolve = 0;\n\n    /**\n     * Set to true if you want to fix the rotation of the body.\n     * @property fixedRotation\n     * @type {Boolean}\n     */\n    this.fixedRotation = !!options.fixedRotation;\n\n    /**\n     * Set to true if you want to fix the body movement along the X axis. The body will still be able to move along Y.\n     * @property {Boolean} fixedX\n     */\n    this.fixedX = !!options.fixedX;\n\n    /**\n     * Set to true if you want to fix the body movement along the Y axis. The body will still be able to move along X.\n     * @property {Boolean} fixedY\n     */\n    this.fixedY = !!options.fixedY;\n\n    /**\n     * @private\n     * @property {array} massMultiplier\n     */\n    this.massMultiplier = vec2.create();\n\n    /**\n     * The position of the body\n     * @property position\n     * @type {Array}\n     */\n    this.position = vec2.fromValues(0,0);\n    if(options.position){\n        vec2.copy(this.position, options.position);\n    }\n\n    /**\n     * The interpolated position of the body. Use this for rendering.\n     * @property interpolatedPosition\n     * @type {Array}\n     */\n    this.interpolatedPosition = vec2.fromValues(0,0);\n\n    /**\n     * The interpolated angle of the body. Use this for rendering.\n     * @property interpolatedAngle\n     * @type {Number}\n     */\n    this.interpolatedAngle = 0;\n\n    /**\n     * The previous position of the body.\n     * @property previousPosition\n     * @type {Array}\n     */\n    this.previousPosition = vec2.fromValues(0,0);\n\n    /**\n     * The previous angle of the body.\n     * @property previousAngle\n     * @type {Number}\n     */\n    this.previousAngle = 0;\n\n    /**\n     * The current velocity of the body.\n     * @property velocity\n     * @type {Array}\n     */\n    this.velocity = vec2.fromValues(0,0);\n    if(options.velocity){\n        vec2.copy(this.velocity, options.velocity);\n    }\n\n    /**\n     * Constraint velocity that was added to the body during the last step.\n     * @property vlambda\n     * @type {Array}\n     */\n    this.vlambda = vec2.fromValues(0,0);\n\n    /**\n     * Angular constraint velocity that was added to the body during last step.\n     * @property wlambda\n     * @type {Array}\n     */\n    this.wlambda = 0;\n\n    /**\n     * The angle of the body, in radians.\n     * @property angle\n     * @type {number}\n     * @example\n     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.\n     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.\n     *     function normalizeAngle(angle){\n     *         angle = angle % (2*Math.PI);\n     *         if(angle < 0){\n     *             angle += (2*Math.PI);\n     *         }\n     *         return angle;\n     *     }\n     */\n    this.angle = options.angle || 0;\n\n    /**\n     * The angular velocity of the body, in radians per second.\n     * @property angularVelocity\n     * @type {number}\n     */\n    this.angularVelocity = options.angularVelocity || 0;\n\n    /**\n     * The force acting on the body. Since the body force (and {{#crossLink \"Body/angularForce:property\"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.\n     * @property force\n     * @type {Array}\n     *\n     * @example\n     *     // This produces a forcefield of 1 Newton in the positive x direction.\n     *     for(var i=0; i<numSteps; i++){\n     *         body.force[0] = 1;\n     *         world.step(1/60);\n     *     }\n     *\n     * @example\n     *     // This will apply a rotational force on the body\n     *     for(var i=0; i<numSteps; i++){\n     *         body.angularForce = -3;\n     *         world.step(1/60);\n     *     }\n     */\n    this.force = vec2.create();\n    if(options.force){\n        vec2.copy(this.force, options.force);\n    }\n\n    /**\n     * The angular force acting on the body. See {{#crossLink \"Body/force:property\"}}{{/crossLink}}.\n     * @property angularForce\n     * @type {number}\n     */\n    this.angularForce = options.angularForce || 0;\n\n    /**\n     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.\n     * @property damping\n     * @type {Number}\n     * @default 0.1\n     */\n    this.damping = typeof(options.damping) === \"number\" ? options.damping : 0.1;\n\n    /**\n     * The angular force acting on the body. Should be a value between 0 and 1.\n     * @property angularDamping\n     * @type {Number}\n     * @default 0.1\n     */\n    this.angularDamping = typeof(options.angularDamping) === \"number\" ? options.angularDamping : 0.1;\n\n    /**\n     * The type of motion this body has. Should be one of: {{#crossLink \"Body/STATIC:property\"}}Body.STATIC{{/crossLink}}, {{#crossLink \"Body/DYNAMIC:property\"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink \"Body/KINEMATIC:property\"}}Body.KINEMATIC{{/crossLink}}.\n     *\n     * * Static bodies do not move, and they do not respond to forces or collision.\n     * * Dynamic bodies body can move and respond to collisions and forces.\n     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.\n     *\n     * @property type\n     * @type {number}\n     *\n     * @example\n     *     // Bodies are static by default. Static bodies will never move.\n     *     var body = new Body();\n     *     console.log(body.type == Body.STATIC); // true\n     *\n     * @example\n     *     // By setting the mass of a body to a nonzero number, the body\n     *     // will become dynamic and will move and interact with other bodies.\n     *     var dynamicBody = new Body({\n     *         mass : 1\n     *     });\n     *     console.log(dynamicBody.type == Body.DYNAMIC); // true\n     *\n     * @example\n     *     // Kinematic bodies will only move if you change their velocity.\n     *     var kinematicBody = new Body({\n     *         type: Body.KINEMATIC // Type can be set via the options object.\n     *     });\n     */\n    this.type = Body.STATIC;\n\n    if(typeof(options.type) !== 'undefined'){\n        this.type = options.type;\n    } else if(!options.mass){\n        this.type = Body.STATIC;\n    } else {\n        this.type = Body.DYNAMIC;\n    }\n\n    /**\n     * Bounding circle radius.\n     * @property boundingRadius\n     * @type {Number}\n     */\n    this.boundingRadius = 0;\n\n    /**\n     * Bounding box of this body.\n     * @property aabb\n     * @type {AABB}\n     */\n    this.aabb = new AABB();\n\n    /**\n     * Indicates if the AABB needs update. Update it with {{#crossLink \"Body/updateAABB:method\"}}.updateAABB(){{/crossLink}}.\n     * @property aabbNeedsUpdate\n     * @type {Boolean}\n     * @see updateAABB\n     *\n     * @example\n     *     // Force update the AABB\n     *     body.aabbNeedsUpdate = true;\n     *     body.updateAABB();\n     *     console.log(body.aabbNeedsUpdate); // false\n     */\n    this.aabbNeedsUpdate = true;\n\n    /**\n     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink \"World\"}}{{/crossLink}} before anything will happen.\n     * @property allowSleep\n     * @type {Boolean}\n     * @default true\n     */\n    this.allowSleep = options.allowSleep !== undefined ? options.allowSleep : true;\n\n    this.wantsToSleep = false;\n\n    /**\n     * One of {{#crossLink \"Body/AWAKE:property\"}}Body.AWAKE{{/crossLink}}, {{#crossLink \"Body/SLEEPY:property\"}}Body.SLEEPY{{/crossLink}} and {{#crossLink \"Body/SLEEPING:property\"}}Body.SLEEPING{{/crossLink}}.\n     *\n     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).\n     *\n     * @property sleepState\n     * @type {Number}\n     * @default Body.AWAKE\n     */\n    this.sleepState = Body.AWAKE;\n\n    /**\n     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.\n     * @property sleepSpeedLimit\n     * @type {Number}\n     * @default 0.2\n     */\n    this.sleepSpeedLimit = options.sleepSpeedLimit !== undefined ? options.sleepSpeedLimit : 0.2;\n\n    /**\n     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.\n     * @property sleepTimeLimit\n     * @type {Number}\n     * @default 1\n     */\n    this.sleepTimeLimit = options.sleepTimeLimit !== undefined ? options.sleepTimeLimit : 1;\n\n    /**\n     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.\n     * @property {Number} gravityScale\n     * @default 1\n     */\n    this.gravityScale = options.gravityScale !== undefined ? options.gravityScale : 1;\n\n    /**\n     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.\n     * @property {Boolean} collisionResponse\n     */\n    this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;\n\n    /**\n     * How long the body has been sleeping.\n     * @property {Number} idleTime\n     */\n    this.idleTime = 0;\n\n    /**\n     * The last time when the body went to SLEEPY state.\n     * @property {Number} timeLastSleepy\n     * @private\n     */\n    this.timeLastSleepy = 0;\n\n    /**\n     * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.\n     * @property {number} ccdSpeedThreshold\n     * @default -1\n     */\n    this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;\n\n    /**\n     * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.\n     * @property {number} ccdIterations\n     * @default 10\n     */\n    this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;\n\n    this.concavePath = null;\n\n    this._wakeUpAfterNarrowphase = false;\n\n    this.updateMassProperties();\n}\nBody.prototype = new EventEmitter();\nBody.prototype.constructor = Body;\n\nBody._idCounter = 0;\n\n/**\n * @private\n * @method updateSolveMassProperties\n */\nBody.prototype.updateSolveMassProperties = function(){\n    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){\n        this.invMassSolve = 0;\n        this.invInertiaSolve = 0;\n    } else {\n        this.invMassSolve = this.invMass;\n        this.invInertiaSolve = this.invInertia;\n    }\n};\n\n/**\n * Set the total density of the body\n * @method setDensity\n * @param {number} density\n */\nBody.prototype.setDensity = function(density) {\n    var totalArea = this.getArea();\n    this.mass = totalArea * density;\n    this.updateMassProperties();\n};\n\n/**\n * Get the total area of all shapes in the body\n * @method getArea\n * @return {Number}\n */\nBody.prototype.getArea = function() {\n    var totalArea = 0;\n    for(var i=0; i<this.shapes.length; i++){\n        totalArea += this.shapes[i].area;\n    }\n    return totalArea;\n};\n\n/**\n * Get the AABB from the body. The AABB is updated if necessary.\n * @method getAABB\n * @return {AABB} The AABB instance (this.aabb)\n */\nBody.prototype.getAABB = function(){\n    if(this.aabbNeedsUpdate){\n        this.updateAABB();\n    }\n    return this.aabb;\n};\n\nvar shapeAABB = new AABB(),\n    tmp = vec2.create();\n\n/**\n * Updates the AABB of the Body, and set .aabbNeedsUpdate = false.\n * @method updateAABB\n */\nBody.prototype.updateAABB = function() {\n    var shapes = this.shapes,\n        N = shapes.length,\n        offset = tmp,\n        bodyAngle = this.angle;\n\n    for(var i=0; i!==N; i++){\n        var shape = shapes[i],\n            angle = shape.angle + bodyAngle;\n\n        // Get shape world offset\n        vec2.rotate(offset, shape.position, bodyAngle);\n        vec2.add(offset, offset, this.position);\n\n        // Get shape AABB\n        shape.computeAABB(shapeAABB, offset, angle);\n\n        if(i===0){\n            this.aabb.copy(shapeAABB);\n        } else {\n            this.aabb.extend(shapeAABB);\n        }\n    }\n\n    this.aabbNeedsUpdate = false;\n};\n\n/**\n * Update the bounding radius of the body (this.boundingRadius). Should be done if any of the shape dimensions or positions are changed.\n * @method updateBoundingRadius\n */\nBody.prototype.updateBoundingRadius = function(){\n    var shapes = this.shapes,\n        N = shapes.length,\n        radius = 0;\n\n    for(var i=0; i!==N; i++){\n        var shape = shapes[i],\n            offset = vec2.length(shape.position),\n            r = shape.boundingRadius;\n        if(offset + r > radius){\n            radius = offset + r;\n        }\n    }\n\n    this.boundingRadius = radius;\n};\n\n/**\n * Add a shape to the body. You can pass a local transform when adding a shape,\n * so that the shape gets an offset and angle relative to the body center of mass.\n * Will automatically update the mass properties and bounding radius.\n *\n * @method addShape\n * @param  {Shape}              shape\n * @param  {Array} [offset] Local body offset of the shape.\n * @param  {Number}             [angle]  Local body angle.\n *\n * @example\n *     var body = new Body(),\n *         shape = new Circle({ radius: 1 });\n *\n *     // Add the shape to the body, positioned in the center\n *     body.addShape(shape);\n *\n *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.\n *     body.addShape(shape,[1,0]);\n *\n *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.\n *     body.addShape(shape,[0,1],Math.PI/2);\n */\nBody.prototype.addShape = function(shape, offset, angle){\n    if(shape.body){\n        throw new Error('A shape can only be added to one body.');\n    }\n    shape.body = this;\n\n    // Copy the offset vector\n    if(offset){\n        vec2.copy(shape.position, offset);\n    } else {\n        vec2.set(shape.position, 0, 0);\n    }\n\n    shape.angle = angle || 0;\n\n    this.shapes.push(shape);\n    this.updateMassProperties();\n    this.updateBoundingRadius();\n\n    this.aabbNeedsUpdate = true;\n};\n\n/**\n * Remove a shape\n * @method removeShape\n * @param  {Shape} shape\n * @return {Boolean} True if the shape was found and removed, else false.\n */\nBody.prototype.removeShape = function(shape){\n    var idx = this.shapes.indexOf(shape);\n\n    if(idx !== -1){\n        this.shapes.splice(idx,1);\n        this.aabbNeedsUpdate = true;\n        shape.body = null;\n        return true;\n    } else {\n        return false;\n    }\n};\n\n/**\n * Updates .inertia, .invMass, .invInertia for this Body. Should be called when\n * changing the structure or mass of the Body.\n *\n * @method updateMassProperties\n *\n * @example\n *     body.mass += 1;\n *     body.updateMassProperties();\n */\nBody.prototype.updateMassProperties = function(){\n    if(this.type === Body.STATIC || this.type === Body.KINEMATIC){\n\n        this.mass = Number.MAX_VALUE;\n        this.invMass = 0;\n        this.inertia = Number.MAX_VALUE;\n        this.invInertia = 0;\n\n    } else {\n\n        var shapes = this.shapes,\n            N = shapes.length,\n            m = this.mass / N,\n            I = 0;\n\n        if(!this.fixedRotation){\n            for(var i=0; i<N; i++){\n                var shape = shapes[i],\n                    r2 = vec2.squaredLength(shape.position),\n                    Icm = shape.computeMomentOfInertia(m);\n                I += Icm + m*r2;\n            }\n            this.inertia = I;\n            this.invInertia = I>0 ? 1/I : 0;\n\n        } else {\n            this.inertia = Number.MAX_VALUE;\n            this.invInertia = 0;\n        }\n\n        // Inverse mass properties are easy\n        this.invMass = 1 / this.mass;\n\n        vec2.set(\n            this.massMultiplier,\n            this.fixedX ? 0 : 1,\n            this.fixedY ? 0 : 1\n        );\n    }\n};\n\nvar Body_applyForce_r = vec2.create();\n\n/**\n * Apply force to a point relative to the center of mass of the body. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce. If relativePoint is zero, the force will be applied directly on the center of mass, and the torque produced will be zero.\n * @method applyForce\n * @param {Array} force The force to add.\n * @param {Array} [relativePoint] A world point to apply the force on.\n */\nBody.prototype.applyForce = function(force, relativePoint){\n\n    // Add linear force\n    vec2.add(this.force, this.force, force);\n\n    if(relativePoint){\n\n        // Compute produced rotational force\n        var rotForce = vec2.crossLength(relativePoint,force);\n\n        // Add rotational force\n        this.angularForce += rotForce;\n    }\n};\n\n/**\n * Apply force to a body-local point.\n * @method applyForceLocal\n * @param  {Array} localForce The force vector to add, oriented in local body space.\n * @param  {Array} [localPoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.\n */\nvar Body_applyForce_forceWorld = vec2.create();\nvar Body_applyForce_pointWorld = vec2.create();\nvar Body_applyForce_pointLocal = vec2.create();\nBody.prototype.applyForceLocal = function(localForce, localPoint){\n    localPoint = localPoint || Body_applyForce_pointLocal;\n    var worldForce = Body_applyForce_forceWorld;\n    var worldPoint = Body_applyForce_pointWorld;\n    this.vectorToWorldFrame(worldForce, localForce);\n    this.vectorToWorldFrame(worldPoint, localPoint);\n    this.applyForce(worldForce, worldPoint);\n};\n\n/**\n * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.\n * @method applyImpulse\n * @param  {Array} impulse The impulse vector to add, oriented in world space.\n * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.\n */\nvar Body_applyImpulse_velo = vec2.create();\nBody.prototype.applyImpulse = function(impulseVector, relativePoint){\n    if(this.type !== Body.DYNAMIC){\n        return;\n    }\n\n    // Compute produced central impulse velocity\n    var velo = Body_applyImpulse_velo;\n    vec2.scale(velo, impulseVector, this.invMass);\n    vec2.multiply(velo, this.massMultiplier, velo);\n\n    // Add linear impulse\n    vec2.add(this.velocity, velo, this.velocity);\n\n    if(relativePoint){\n        // Compute produced rotational impulse velocity\n        var rotVelo = vec2.crossLength(relativePoint, impulseVector);\n        rotVelo *= this.invInertia;\n\n        // Add rotational Impulse\n        this.angularVelocity += rotVelo;\n    }\n};\n\n/**\n * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.\n * @method applyImpulseLocal\n * @param  {Array} impulse The impulse vector to add, oriented in world space.\n * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.\n */\nvar Body_applyImpulse_impulseWorld = vec2.create();\nvar Body_applyImpulse_pointWorld = vec2.create();\nvar Body_applyImpulse_pointLocal = vec2.create();\nBody.prototype.applyImpulseLocal = function(localImpulse, localPoint){\n    localPoint = localPoint || Body_applyImpulse_pointLocal;\n    var worldImpulse = Body_applyImpulse_impulseWorld;\n    var worldPoint = Body_applyImpulse_pointWorld;\n    this.vectorToWorldFrame(worldImpulse, localImpulse);\n    this.vectorToWorldFrame(worldPoint, localPoint);\n    this.applyImpulse(worldImpulse, worldPoint);\n};\n\n/**\n * Transform a world point to local body frame.\n * @method toLocalFrame\n * @param  {Array} out          The vector to store the result in\n * @param  {Array} worldPoint   The input world point\n */\nBody.prototype.toLocalFrame = function(out, worldPoint){\n    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);\n};\n\n/**\n * Transform a local point to world frame.\n * @method toWorldFrame\n * @param  {Array} out          The vector to store the result in\n * @param  {Array} localPoint   The input local point\n */\nBody.prototype.toWorldFrame = function(out, localPoint){\n    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);\n};\n\n/**\n * Transform a world point to local body frame.\n * @method vectorToLocalFrame\n * @param  {Array} out          The vector to store the result in\n * @param  {Array} worldVector  The input world vector\n */\nBody.prototype.vectorToLocalFrame = function(out, worldVector){\n    vec2.vectorToLocalFrame(out, worldVector, this.angle);\n};\n\n/**\n * Transform a local point to world frame.\n * @method vectorToWorldFrame\n * @param  {Array} out          The vector to store the result in\n * @param  {Array} localVector  The input local vector\n */\nBody.prototype.vectorToWorldFrame = function(out, localVector){\n    vec2.vectorToGlobalFrame(out, localVector, this.angle);\n};\n\n/**\n * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.\n * @method fromPolygon\n * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.\n * @param {Object} [options]\n * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.\n * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.\n * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.\n * @return {Boolean} True on success, else false.\n */\nBody.prototype.fromPolygon = function(path,options){\n    options = options || {};\n\n    // Remove all shapes\n    for(var i=this.shapes.length; i>=0; --i){\n        this.removeShape(this.shapes[i]);\n    }\n\n    var p = new decomp.Polygon();\n    p.vertices = path;\n\n    // Make it counter-clockwise\n    p.makeCCW();\n\n    if(typeof(options.removeCollinearPoints) === \"number\"){\n        p.removeCollinearPoints(options.removeCollinearPoints);\n    }\n\n    // Check if any line segment intersects the path itself\n    if(typeof(options.skipSimpleCheck) === \"undefined\"){\n        if(!p.isSimple()){\n            return false;\n        }\n    }\n\n    // Save this path for later\n    this.concavePath = p.vertices.slice(0);\n    for(var i=0; i<this.concavePath.length; i++){\n        var v = [0,0];\n        vec2.copy(v,this.concavePath[i]);\n        this.concavePath[i] = v;\n    }\n\n    // Slow or fast decomp?\n    var convexes;\n    if(options.optimalDecomp){\n        convexes = p.decomp();\n    } else {\n        convexes = p.quickDecomp();\n    }\n\n    var cm = vec2.create();\n\n    // Add convexes\n    for(var i=0; i!==convexes.length; i++){\n        // Create convex\n        var c = new Convex({ vertices: convexes[i].vertices });\n\n        // Move all vertices so its center of mass is in the local center of the convex\n        for(var j=0; j!==c.vertices.length; j++){\n            var v = c.vertices[j];\n            vec2.sub(v,v,c.centerOfMass);\n        }\n\n        vec2.scale(cm,c.centerOfMass,1);\n        c.updateTriangles();\n        c.updateCenterOfMass();\n        c.updateBoundingRadius();\n\n        // Add the shape\n        this.addShape(c,cm);\n    }\n\n    this.adjustCenterOfMass();\n\n    this.aabbNeedsUpdate = true;\n\n    return true;\n};\n\nvar adjustCenterOfMass_tmp1 = vec2.fromValues(0,0),\n    adjustCenterOfMass_tmp2 = vec2.fromValues(0,0),\n    adjustCenterOfMass_tmp3 = vec2.fromValues(0,0),\n    adjustCenterOfMass_tmp4 = vec2.fromValues(0,0);\n\n/**\n * Moves the shape offsets so their center of mass becomes the body center of mass.\n * @method adjustCenterOfMass\n */\nBody.prototype.adjustCenterOfMass = function(){\n    var offset_times_area = adjustCenterOfMass_tmp2,\n        sum =               adjustCenterOfMass_tmp3,\n        cm =                adjustCenterOfMass_tmp4,\n        totalArea =         0;\n    vec2.set(sum,0,0);\n\n    for(var i=0; i!==this.shapes.length; i++){\n        var s = this.shapes[i];\n        vec2.scale(offset_times_area, s.position, s.area);\n        vec2.add(sum, sum, offset_times_area);\n        totalArea += s.area;\n    }\n\n    vec2.scale(cm,sum,1/totalArea);\n\n    // Now move all shapes\n    for(var i=0; i!==this.shapes.length; i++){\n        var s = this.shapes[i];\n        vec2.sub(s.position, s.position, cm);\n    }\n\n    // Move the body position too\n    vec2.add(this.position,this.position,cm);\n\n    // And concave path\n    for(var i=0; this.concavePath && i<this.concavePath.length; i++){\n        vec2.sub(this.concavePath[i], this.concavePath[i], cm);\n    }\n\n    this.updateMassProperties();\n    this.updateBoundingRadius();\n};\n\n/**\n * Sets the force on the body to zero.\n * @method setZeroForce\n */\nBody.prototype.setZeroForce = function(){\n    vec2.set(this.force,0.0,0.0);\n    this.angularForce = 0.0;\n};\n\nBody.prototype.resetConstraintVelocity = function(){\n    var b = this,\n        vlambda = b.vlambda;\n    vec2.set(vlambda,0,0);\n    b.wlambda = 0;\n};\n\nBody.prototype.addConstraintVelocity = function(){\n    var b = this,\n        v = b.velocity;\n    vec2.add( v, v, b.vlambda);\n    b.angularVelocity += b.wlambda;\n};\n\n/**\n * Apply damping, see <a href=\"http://code.google.com/p/bullet/issues/detail?id=74\">this</a> for details.\n * @method applyDamping\n * @param  {number} dt Current time step\n */\nBody.prototype.applyDamping = function(dt){\n    if(this.type === Body.DYNAMIC){ // Only for dynamic bodies\n        var v = this.velocity;\n        vec2.scale(v, v, Math.pow(1.0 - this.damping,dt));\n        this.angularVelocity *= Math.pow(1.0 - this.angularDamping,dt);\n    }\n};\n\n/**\n * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.\n * Sets the sleepState to {{#crossLink \"Body/AWAKE:property\"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.\n * @method wakeUp\n */\nBody.prototype.wakeUp = function(){\n    var s = this.sleepState;\n    this.sleepState = Body.AWAKE;\n    this.idleTime = 0;\n    if(s !== Body.AWAKE){\n        this.emit(Body.wakeUpEvent);\n    }\n};\n\n/**\n * Force body sleep\n * @method sleep\n */\nBody.prototype.sleep = function(){\n    this.sleepState = Body.SLEEPING;\n    this.angularVelocity = 0;\n    this.angularForce = 0;\n    vec2.set(this.velocity,0,0);\n    vec2.set(this.force,0,0);\n    this.emit(Body.sleepEvent);\n};\n\n/**\n * Called every timestep to update internal sleep timer and change sleep state if needed.\n * @method sleepTick\n * @param {number} time The world time in seconds\n * @param {boolean} dontSleep\n * @param {number} dt\n */\nBody.prototype.sleepTick = function(time, dontSleep, dt){\n    if(!this.allowSleep || this.type === Body.SLEEPING){\n        return;\n    }\n\n    this.wantsToSleep = false;\n\n    var sleepState = this.sleepState,\n        speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity,2),\n        speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);\n\n    // Add to idle time\n    if(speedSquared >= speedLimitSquared){\n        this.idleTime = 0;\n        this.sleepState = Body.AWAKE;\n    } else {\n        this.idleTime += dt;\n        this.sleepState = Body.SLEEPY;\n    }\n    if(this.idleTime > this.sleepTimeLimit){\n        if(!dontSleep){\n            this.sleep();\n        } else {\n            this.wantsToSleep = true;\n        }\n    }\n};\n\n/**\n * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.\n * @method overlaps\n * @param  {Body} body\n * @return {boolean}\n */\nBody.prototype.overlaps = function(body){\n    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);\n};\n\nvar integrate_fhMinv = vec2.create();\nvar integrate_velodt = vec2.create();\n\n/**\n * Move the body forward in time given its current velocity.\n * @method integrate\n * @param  {Number} dt\n */\nBody.prototype.integrate = function(dt){\n    var minv = this.invMass,\n        f = this.force,\n        pos = this.position,\n        velo = this.velocity;\n\n    // Save old position\n    vec2.copy(this.previousPosition, this.position);\n    this.previousAngle = this.angle;\n\n    // Velocity update\n    if(!this.fixedRotation){\n        this.angularVelocity += this.angularForce * this.invInertia * dt;\n    }\n    vec2.scale(integrate_fhMinv, f, dt * minv);\n    vec2.multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);\n    vec2.add(velo, integrate_fhMinv, velo);\n\n    // CCD\n    if(!this.integrateToTimeOfImpact(dt)){\n\n        // Regular position update\n        vec2.scale(integrate_velodt, velo, dt);\n        vec2.add(pos, pos, integrate_velodt);\n        if(!this.fixedRotation){\n            this.angle += this.angularVelocity * dt;\n        }\n    }\n\n    this.aabbNeedsUpdate = true;\n};\n\nvar result = new RaycastResult();\nvar ray = new Ray({\n    mode: Ray.ALL\n});\nvar direction = vec2.create();\nvar end = vec2.create();\nvar startToEnd = vec2.create();\nvar rememberPosition = vec2.create();\nBody.prototype.integrateToTimeOfImpact = function(dt){\n\n    if(this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)){\n        return false;\n    }\n\n    vec2.normalize(direction, this.velocity);\n\n    vec2.scale(end, this.velocity, dt);\n    vec2.add(end, end, this.position);\n\n    vec2.sub(startToEnd, end, this.position);\n    var startToEndAngle = this.angularVelocity * dt;\n    var len = vec2.length(startToEnd);\n\n    var timeOfImpact = 1;\n\n    var hit;\n    var that = this;\n    result.reset();\n    ray.callback = function (result) {\n        if(result.body === that){\n            return;\n        }\n        hit = result.body;\n        result.getHitPoint(end, ray);\n        vec2.sub(startToEnd, end, that.position);\n        timeOfImpact = vec2.length(startToEnd) / len;\n        result.stop();\n    };\n    vec2.copy(ray.from, this.position);\n    vec2.copy(ray.to, end);\n    ray.update();\n    this.world.raycast(result, ray);\n\n    if(!hit){\n        return false;\n    }\n\n    var rememberAngle = this.angle;\n    vec2.copy(rememberPosition, this.position);\n\n    // Got a start and end point. Approximate time of impact using binary search\n    var iter = 0;\n    var tmin = 0;\n    var tmid = 0;\n    var tmax = timeOfImpact;\n    while (tmax >= tmin && iter < this.ccdIterations) {\n        iter++;\n\n        // calculate the midpoint\n        tmid = (tmax - tmin) / 2;\n\n        // Move the body to that point\n        vec2.scale(integrate_velodt, startToEnd, timeOfImpact);\n        vec2.add(this.position, rememberPosition, integrate_velodt);\n        this.angle = rememberAngle + startToEndAngle * timeOfImpact;\n        this.updateAABB();\n\n        // check overlap\n        var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);\n\n        if (overlaps) {\n            // change min to search upper interval\n            tmin = tmid;\n        } else {\n            // change max to search lower interval\n            tmax = tmid;\n        }\n    }\n\n    timeOfImpact = tmid;\n\n    vec2.copy(this.position, rememberPosition);\n    this.angle = rememberAngle;\n\n    // move to TOI\n    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);\n    vec2.add(this.position, this.position, integrate_velodt);\n    if(!this.fixedRotation){\n        this.angle += startToEndAngle * timeOfImpact;\n    }\n\n    return true;\n};\n\n/**\n * Get velocity of a point in the body.\n * @method getVelocityAtPoint\n * @param  {Array} result A vector to store the result in\n * @param  {Array} relativePoint A world oriented vector, indicating the position of the point to get the velocity from\n * @return {Array} The result vector\n */\nBody.prototype.getVelocityAtPoint = function(result, relativePoint){\n    vec2.crossVZ(result, relativePoint, this.angularVelocity);\n    vec2.subtract(result, this.velocity, result);\n    return result;\n};\n\n/**\n * @event sleepy\n */\nBody.sleepyEvent = {\n    type: \"sleepy\"\n};\n\n/**\n * @event sleep\n */\nBody.sleepEvent = {\n    type: \"sleep\"\n};\n\n/**\n * @event wakeup\n */\nBody.wakeUpEvent = {\n    type: \"wakeup\"\n};\n\n/**\n * Dynamic body.\n * @property DYNAMIC\n * @type {Number}\n * @static\n */\nBody.DYNAMIC = 1;\n\n/**\n * Static body.\n * @property STATIC\n * @type {Number}\n * @static\n */\nBody.STATIC = 2;\n\n/**\n * Kinematic body.\n * @property KINEMATIC\n * @type {Number}\n * @static\n */\nBody.KINEMATIC = 4;\n\n/**\n * @property AWAKE\n * @type {Number}\n * @static\n */\nBody.AWAKE = 0;\n\n/**\n * @property SLEEPY\n * @type {Number}\n * @static\n */\nBody.SLEEPY = 1;\n\n/**\n * @property SLEEPING\n * @type {Number}\n * @static\n */\nBody.SLEEPING = 2;\n\n","var vec2 = require('../math/vec2');\nvar Spring = require('./Spring');\nvar Utils = require('../utils/Utils');\n\nmodule.exports = LinearSpring;\n\n/**\n * A spring, connecting two bodies.\n *\n * The Spring explicitly adds force and angularForce to the bodies.\n *\n * @class LinearSpring\n * @extends Spring\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.\n * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.\n * @param {number} [options.damping=1]      A number >= 0. Default: 1\n * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option \"localAnchorA\" if given.\n * @param {Array}  [options.worldAnchorB]\n * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.\n * @param {Array}  [options.localAnchorB]\n */\nfunction LinearSpring(bodyA,bodyB,options){\n    options = options || {};\n\n    Spring.call(this, bodyA, bodyB, options);\n\n    /**\n     * Anchor for bodyA in local bodyA coordinates.\n     * @property localAnchorA\n     * @type {Array}\n     */\n    this.localAnchorA = vec2.fromValues(0,0);\n\n    /**\n     * Anchor for bodyB in local bodyB coordinates.\n     * @property localAnchorB\n     * @type {Array}\n     */\n    this.localAnchorB = vec2.fromValues(0,0);\n\n    if(options.localAnchorA){ vec2.copy(this.localAnchorA, options.localAnchorA); }\n    if(options.localAnchorB){ vec2.copy(this.localAnchorB, options.localAnchorB); }\n    if(options.worldAnchorA){ this.setWorldAnchorA(options.worldAnchorA); }\n    if(options.worldAnchorB){ this.setWorldAnchorB(options.worldAnchorB); }\n\n    var worldAnchorA = vec2.create();\n    var worldAnchorB = vec2.create();\n    this.getWorldAnchorA(worldAnchorA);\n    this.getWorldAnchorB(worldAnchorB);\n    var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);\n\n    /**\n     * Rest length of the spring.\n     * @property restLength\n     * @type {number}\n     */\n    this.restLength = typeof(options.restLength) === \"number\" ? options.restLength : worldDistance;\n}\nLinearSpring.prototype = new Spring();\nLinearSpring.prototype.constructor = LinearSpring;\n\n/**\n * Set the anchor point on body A, using world coordinates.\n * @method setWorldAnchorA\n * @param {Array} worldAnchorA\n */\nLinearSpring.prototype.setWorldAnchorA = function(worldAnchorA){\n    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);\n};\n\n/**\n * Set the anchor point on body B, using world coordinates.\n * @method setWorldAnchorB\n * @param {Array} worldAnchorB\n */\nLinearSpring.prototype.setWorldAnchorB = function(worldAnchorB){\n    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);\n};\n\n/**\n * Get the anchor point on body A, in world coordinates.\n * @method getWorldAnchorA\n * @param {Array} result The vector to store the result in.\n */\nLinearSpring.prototype.getWorldAnchorA = function(result){\n    this.bodyA.toWorldFrame(result, this.localAnchorA);\n};\n\n/**\n * Get the anchor point on body B, in world coordinates.\n * @method getWorldAnchorB\n * @param {Array} result The vector to store the result in.\n */\nLinearSpring.prototype.getWorldAnchorB = function(result){\n    this.bodyB.toWorldFrame(result, this.localAnchorB);\n};\n\nvar applyForce_r =              vec2.create(),\n    applyForce_r_unit =         vec2.create(),\n    applyForce_u =              vec2.create(),\n    applyForce_f =              vec2.create(),\n    applyForce_worldAnchorA =   vec2.create(),\n    applyForce_worldAnchorB =   vec2.create(),\n    applyForce_ri =             vec2.create(),\n    applyForce_rj =             vec2.create(),\n    applyForce_tmp =            vec2.create();\n\n/**\n * Apply the spring force to the connected bodies.\n * @method applyForce\n */\nLinearSpring.prototype.applyForce = function(){\n    var k = this.stiffness,\n        d = this.damping,\n        l = this.restLength,\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        r = applyForce_r,\n        r_unit = applyForce_r_unit,\n        u = applyForce_u,\n        f = applyForce_f,\n        tmp = applyForce_tmp;\n\n    var worldAnchorA = applyForce_worldAnchorA,\n        worldAnchorB = applyForce_worldAnchorB,\n        ri = applyForce_ri,\n        rj = applyForce_rj;\n\n    // Get world anchors\n    this.getWorldAnchorA(worldAnchorA);\n    this.getWorldAnchorB(worldAnchorB);\n\n    // Get offset points\n    vec2.sub(ri, worldAnchorA, bodyA.position);\n    vec2.sub(rj, worldAnchorB, bodyB.position);\n\n    // Compute distance vector between world anchor points\n    vec2.sub(r, worldAnchorB, worldAnchorA);\n    var rlen = vec2.len(r);\n    vec2.normalize(r_unit,r);\n\n    //console.log(rlen)\n    //console.log(\"A\",vec2.str(worldAnchorA),\"B\",vec2.str(worldAnchorB))\n\n    // Compute relative velocity of the anchor points, u\n    vec2.sub(u, bodyB.velocity, bodyA.velocity);\n    vec2.crossZV(tmp, bodyB.angularVelocity, rj);\n    vec2.add(u, u, tmp);\n    vec2.crossZV(tmp, bodyA.angularVelocity, ri);\n    vec2.sub(u, u, tmp);\n\n    // F = - k * ( x - L ) - D * ( u )\n    vec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));\n\n    // Add forces to bodies\n    vec2.sub( bodyA.force, bodyA.force, f);\n    vec2.add( bodyB.force, bodyB.force, f);\n\n    // Angular force\n    var ri_x_f = vec2.crossLength(ri, f);\n    var rj_x_f = vec2.crossLength(rj, f);\n    bodyA.angularForce -= ri_x_f;\n    bodyB.angularForce += rj_x_f;\n};\n","var vec2 = require('../math/vec2');\nvar Spring = require('./Spring');\n\nmodule.exports = RotationalSpring;\n\n/**\n * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.\n *\n * The spring can be combined with a {{#crossLink \"RevoluteConstraint\"}}{{/crossLink}} to make, for example, a mouse trap.\n *\n * @class RotationalSpring\n * @extends Spring\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.\n * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.\n * @param {number} [options.damping=1] A number >= 0.\n */\nfunction RotationalSpring(bodyA, bodyB, options){\n    options = options || {};\n\n    Spring.call(this, bodyA, bodyB, options);\n\n    /**\n     * Rest angle of the spring.\n     * @property restAngle\n     * @type {number}\n     */\n    this.restAngle = typeof(options.restAngle) === \"number\" ? options.restAngle : bodyB.angle - bodyA.angle;\n}\nRotationalSpring.prototype = new Spring();\nRotationalSpring.prototype.constructor = RotationalSpring;\n\n/**\n * Apply the spring force to the connected bodies.\n * @method applyForce\n */\nRotationalSpring.prototype.applyForce = function(){\n    var k = this.stiffness,\n        d = this.damping,\n        l = this.restAngle,\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        x = bodyB.angle - bodyA.angle,\n        u = bodyB.angularVelocity - bodyA.angularVelocity;\n\n    var torque = - k * (x - l) - d * u * 0;\n\n    bodyA.angularForce -= torque;\n    bodyB.angularForce += torque;\n};\n","var vec2 = require('../math/vec2');\nvar Utils = require('../utils/Utils');\n\nmodule.exports = Spring;\n\n/**\n * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the constraint solver.\n *\n * @class Spring\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.\n * @param {number} [options.damping=1]      A number >= 0. Default: 1\n * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.\n * @param {Array}  [options.localAnchorB]\n * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option \"localAnchorA\" if given.\n * @param {Array}  [options.worldAnchorB]\n */\nfunction Spring(bodyA, bodyB, options){\n    options = Utils.defaults(options,{\n        stiffness: 100,\n        damping: 1,\n    });\n\n    /**\n     * Stiffness of the spring.\n     * @property stiffness\n     * @type {number}\n     */\n    this.stiffness = options.stiffness;\n\n    /**\n     * Damping of the spring.\n     * @property damping\n     * @type {number}\n     */\n    this.damping = options.damping;\n\n    /**\n     * First connected body.\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second connected body.\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n}\n\n/**\n * Apply the spring force to the connected bodies.\n * @method applyForce\n */\nSpring.prototype.applyForce = function(){\n    // To be implemented by subclasses\n};\n","var vec2 = require('../math/vec2');\nvar Utils = require('../utils/Utils');\nvar Constraint = require('../constraints/Constraint');\nvar FrictionEquation = require('../equations/FrictionEquation');\nvar Body = require('../objects/Body');\n\nmodule.exports = TopDownVehicle;\n\n/**\n * @class TopDownVehicle\n * @constructor\n * @param {Body} chassisBody A dynamic body, already added to the world.\n * @param {Object} [options]\n *\n * @example\n *\n *     // Create a dynamic body for the chassis\n *     var chassisBody = new Body({\n *         mass: 1\n *     });\n *     var boxShape = new Box({ width: 0.5, height: 1 });\n *     chassisBody.addShape(boxShape);\n *     world.addBody(chassisBody);\n *\n *     // Create the vehicle\n *     var vehicle = new TopDownVehicle(chassisBody);\n *\n *     // Add one front wheel and one back wheel - we don't actually need four :)\n *     var frontWheel = vehicle.addWheel({\n *         localPosition: [0, 0.5] // front\n *     });\n *     frontWheel.setSideFriction(4);\n *\n *     // Back wheel\n *     var backWheel = vehicle.addWheel({\n *         localPosition: [0, -0.5] // back\n *     });\n *     backWheel.setSideFriction(3); // Less side friction on back wheel makes it easier to drift\n *     vehicle.addToWorld(world);\n *\n *     // Steer value zero means straight forward. Positive is left and negative right.\n *     frontWheel.steerValue = Math.PI / 16;\n *\n *     // Engine force forward\n *     backWheel.engineForce = 10;\n *     backWheel.setBrakeForce(0);\n */\nfunction TopDownVehicle(chassisBody, options){\n    options = options || {};\n\n    /**\n     * @property {Body} chassisBody\n     */\n    this.chassisBody = chassisBody;\n\n    /**\n     * @property {Array} wheels\n     */\n    this.wheels = [];\n\n    // A dummy body to constrain the chassis to\n    this.groundBody = new Body({ mass: 0 });\n\n    this.world = null;\n\n    var that = this;\n    this.preStepCallback = function(){\n        that.update();\n    };\n}\n\n/**\n * @method addToWorld\n * @param {World} world\n */\nTopDownVehicle.prototype.addToWorld = function(world){\n    this.world = world;\n    world.addBody(this.groundBody);\n    world.on('preStep', this.preStepCallback);\n    for (var i = 0; i < this.wheels.length; i++) {\n        var wheel = this.wheels[i];\n        world.addConstraint(wheel);\n    }\n};\n\n/**\n * @method removeFromWorld\n * @param {World} world\n */\nTopDownVehicle.prototype.removeFromWorld = function(){\n    var world = this.world;\n    world.removeBody(this.groundBody);\n    world.off('preStep', this.preStepCallback);\n    for (var i = 0; i < this.wheels.length; i++) {\n        var wheel = this.wheels[i];\n        world.removeConstraint(wheel);\n    }\n    this.world = null;\n};\n\n/**\n * @method addWheel\n * @param {object} [wheelOptions]\n * @return {WheelConstraint}\n */\nTopDownVehicle.prototype.addWheel = function(wheelOptions){\n    var wheel = new WheelConstraint(this,wheelOptions);\n    this.wheels.push(wheel);\n    return wheel;\n};\n\n/**\n * @method update\n */\nTopDownVehicle.prototype.update = function(){\n    for (var i = 0; i < this.wheels.length; i++) {\n        this.wheels[i].update();\n    }\n};\n\n/**\n * @class WheelConstraint\n * @constructor\n * @extends {Constraint}\n * @param {Vehicle} vehicle\n * @param {object} [options]\n * @param {Array} [options.localForwardVector]The local wheel forward vector in local body space. Default is zero.\n * @param {Array} [options.localPosition] The local position of the wheen in the chassis body. Default is zero - the center of the body.\n * @param {Array} [options.sideFriction=5] The max friction force in the sideways direction.\n */\nfunction WheelConstraint(vehicle, options){\n    options = options || {};\n\n    this.vehicle = vehicle;\n\n    this.forwardEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);\n\n    this.sideEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);\n\n    /**\n     * @property {number} steerValue\n     */\n    this.steerValue = 0;\n\n    /**\n     * @property {number} engineForce\n     */\n    this.engineForce = 0;\n\n    this.setSideFriction(options.sideFriction !== undefined ? options.sideFriction : 5);\n\n    /**\n     * @property {Array} localForwardVector\n     */\n    this.localForwardVector = vec2.fromValues(0, 1);\n    if(options.localForwardVector){\n        vec2.copy(this.localForwardVector, options.localForwardVector);\n    }\n\n    /**\n     * @property {Array} localPosition\n     */\n    this.localPosition = vec2.fromValues(0, 0);\n    if(options.localPosition){\n        vec2.copy(this.localPosition, options.localPosition);\n    }\n\n    Constraint.apply(this, vehicle.chassisBody, vehicle.groundBody);\n\n    this.equations.push(\n        this.forwardEquation,\n        this.sideEquation\n    );\n\n    this.setBrakeForce(0);\n}\nWheelConstraint.prototype = new Constraint();\n\n/**\n * @method setForwardFriction\n */\nWheelConstraint.prototype.setBrakeForce = function(force){\n    this.forwardEquation.setSlipForce(force);\n};\n\n/**\n * @method setSideFriction\n */\nWheelConstraint.prototype.setSideFriction = function(force){\n    this.sideEquation.setSlipForce(force);\n};\n\nvar worldVelocity = vec2.create();\nvar relativePoint = vec2.create();\n\n/**\n * @method getSpeed\n */\nWheelConstraint.prototype.getSpeed = function(){\n    this.vehicle.chassisBody.vectorToWorldFrame(relativePoint, this.localForwardVector);\n    this.vehicle.chassisBody.getVelocityAtPoint(worldVelocity, relativePoint);\n    return vec2.dot(worldVelocity, relativePoint);\n};\n\nvar tmpVec = vec2.create();\n\n/**\n * @method update\n */\nWheelConstraint.prototype.update = function(){\n\n    // Directional\n    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector);\n    vec2.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2);\n    this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t);\n\n    vec2.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue);\n    vec2.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue);\n\n    // Attachment point\n    this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition);\n    vec2.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB);\n\n    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition);\n    vec2.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA);\n\n    // Add engine force\n    vec2.normalize(tmpVec, this.forwardEquation.t);\n    vec2.scale(tmpVec, tmpVec, this.engineForce);\n\n    this.vehicle.chassisBody.applyForce(tmpVec, this.forwardEquation.contactPointA);\n};","// Export p2 classes\nvar p2 = module.exports = {\n    AABB :                          require('./collision/AABB'),\n    AngleLockEquation :             require('./equations/AngleLockEquation'),\n    Body :                          require('./objects/Body'),\n    Broadphase :                    require('./collision/Broadphase'),\n    Capsule :                       require('./shapes/Capsule'),\n    Circle :                        require('./shapes/Circle'),\n    Constraint :                    require('./constraints/Constraint'),\n    ContactEquation :               require('./equations/ContactEquation'),\n    ContactEquationPool :           require('./utils/ContactEquationPool'),\n    ContactMaterial :               require('./material/ContactMaterial'),\n    Convex :                        require('./shapes/Convex'),\n    DistanceConstraint :            require('./constraints/DistanceConstraint'),\n    Equation :                      require('./equations/Equation'),\n    EventEmitter :                  require('./events/EventEmitter'),\n    FrictionEquation :              require('./equations/FrictionEquation'),\n    FrictionEquationPool :          require('./utils/FrictionEquationPool'),\n    GearConstraint :                require('./constraints/GearConstraint'),\n    GSSolver :                      require('./solver/GSSolver'),\n    Heightfield :                   require('./shapes/Heightfield'),\n    Line :                          require('./shapes/Line'),\n    LockConstraint :                require('./constraints/LockConstraint'),\n    Material :                      require('./material/Material'),\n    Narrowphase :                   require('./collision/Narrowphase'),\n    NaiveBroadphase :               require('./collision/NaiveBroadphase'),\n    Particle :                      require('./shapes/Particle'),\n    Plane :                         require('./shapes/Plane'),\n    Pool :                          require('./utils/Pool'),\n    RevoluteConstraint :            require('./constraints/RevoluteConstraint'),\n    PrismaticConstraint :           require('./constraints/PrismaticConstraint'),\n    Ray :                           require('./collision/Ray'),\n    RaycastResult :                 require('./collision/RaycastResult'),\n    Box :                           require('./shapes/Box'),\n    RotationalVelocityEquation :    require('./equations/RotationalVelocityEquation'),\n    SAPBroadphase :                 require('./collision/SAPBroadphase'),\n    Shape :                         require('./shapes/Shape'),\n    Solver :                        require('./solver/Solver'),\n    Spring :                        require('./objects/Spring'),\n    TopDownVehicle :                require('./objects/TopDownVehicle'),\n    LinearSpring :                  require('./objects/LinearSpring'),\n    RotationalSpring :              require('./objects/RotationalSpring'),\n    Utils :                         require('./utils/Utils'),\n    World :                         require('./world/World'),\n    vec2 :                          require('./math/vec2'),\n    version :                       require('../package.json').version,\n};\n\nObject.defineProperty(p2, 'Rectangle', {\n    get: function() {\n        console.warn('The Rectangle class has been renamed to Box.');\n        return this.Box;\n    }\n});","var vec2 = require('../math/vec2')\n,   Shape = require('./Shape')\n,   Convex = require('./Convex');\n\nmodule.exports = Box;\n\n/**\n * Box shape class.\n * @class Box\n * @constructor\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {Number} [options.width=1] Total width of the box\n * @param {Number} [options.height=1] Total height of the box\n * @extends Convex\n */\nfunction Box(options){\n    if(typeof(arguments[0]) === 'number' && typeof(arguments[1]) === 'number'){\n        options = {\n            width: arguments[0],\n            height: arguments[1]\n        };\n        console.warn('The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })');\n    }\n    options = options || {};\n\n    /**\n     * Total width of the box\n     * @property width\n     * @type {Number}\n     */\n    var width = this.width = options.width || 1;\n\n    /**\n     * Total height of the box\n     * @property height\n     * @type {Number}\n     */\n    var height = this.height = options.height || 1;\n\n    var verts = [\n        vec2.fromValues(-width/2, -height/2),\n        vec2.fromValues( width/2, -height/2),\n        vec2.fromValues( width/2,  height/2),\n        vec2.fromValues(-width/2,  height/2)\n    ];\n    var axes = [\n        vec2.fromValues(1, 0),\n        vec2.fromValues(0, 1)\n    ];\n\n    options.vertices = verts;\n    options.axes = axes;\n    options.type = Shape.BOX;\n    Convex.call(this, options);\n}\nBox.prototype = new Convex();\nBox.prototype.constructor = Box;\n\n/**\n * Compute moment of inertia\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n */\nBox.prototype.computeMomentOfInertia = function(mass){\n    var w = this.width,\n        h = this.height;\n    return mass * (h*h + w*w) / 12;\n};\n\n/**\n * Update the bounding radius\n * @method updateBoundingRadius\n */\nBox.prototype.updateBoundingRadius = function(){\n    var w = this.width,\n        h = this.height;\n    this.boundingRadius = Math.sqrt(w*w + h*h) / 2;\n};\n\nvar corner1 = vec2.create(),\n    corner2 = vec2.create(),\n    corner3 = vec2.create(),\n    corner4 = vec2.create();\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nBox.prototype.computeAABB = function(out, position, angle){\n    out.setFromPoints(this.vertices,position,angle,0);\n};\n\nBox.prototype.updateArea = function(){\n    this.area = this.width * this.height;\n};\n\n","var Shape = require('./Shape')\n,   vec2 = require('../math/vec2');\n\nmodule.exports = Capsule;\n\n/**\n * Capsule shape class.\n * @class Capsule\n * @constructor\n * @extends Shape\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {Number} [options.length=1] The distance between the end points\n * @param {Number} [options.radius=1] Radius of the capsule\n * @example\n *     var capsuleShape = new Capsule({\n *         length: 1,\n *         radius: 2\n *     });\n *     body.addShape(capsuleShape);\n */\nfunction Capsule(options){\n    if(typeof(arguments[0]) === 'number' && typeof(arguments[1]) === 'number'){\n        options = {\n            length: arguments[0],\n            radius: arguments[1]\n        };\n        console.warn('The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })');\n    }\n    options = options || {};\n\n    /**\n     * The distance between the end points.\n     * @property {Number} length\n     */\n    this.length = options.length || 1;\n\n    /**\n     * The radius of the capsule.\n     * @property {Number} radius\n     */\n    this.radius = options.radius || 1;\n\n    options.type = Shape.CAPSULE;\n    Shape.call(this, options);\n}\nCapsule.prototype = new Shape();\nCapsule.prototype.constructor = Capsule;\n\n/**\n * Compute the mass moment of inertia of the Capsule.\n * @method conputeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n * @todo\n */\nCapsule.prototype.computeMomentOfInertia = function(mass){\n    // Approximate with rectangle\n    var r = this.radius,\n        w = this.length + r, // 2*r is too much, 0 is too little\n        h = r*2;\n    return mass * (h*h + w*w) / 12;\n};\n\n/**\n * @method updateBoundingRadius\n */\nCapsule.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = this.radius + this.length/2;\n};\n\n/**\n * @method updateArea\n */\nCapsule.prototype.updateArea = function(){\n    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;\n};\n\nvar r = vec2.create();\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nCapsule.prototype.computeAABB = function(out, position, angle){\n    var radius = this.radius;\n\n    // Compute center position of one of the the circles, world oriented, but with local offset\n    vec2.set(r,this.length / 2,0);\n    if(angle !== 0){\n        vec2.rotate(r,r,angle);\n    }\n\n    // Get bounds\n    vec2.set(out.upperBound,  Math.max(r[0]+radius, -r[0]+radius),\n                              Math.max(r[1]+radius, -r[1]+radius));\n    vec2.set(out.lowerBound,  Math.min(r[0]-radius, -r[0]-radius),\n                              Math.min(r[1]-radius, -r[1]-radius));\n\n    // Add offset\n    vec2.add(out.lowerBound, out.lowerBound, position);\n    vec2.add(out.upperBound, out.upperBound, position);\n};\n\nvar intersectCapsule_hitPointWorld = vec2.create();\nvar intersectCapsule_normal = vec2.create();\nvar intersectCapsule_l0 = vec2.create();\nvar intersectCapsule_l1 = vec2.create();\nvar intersectCapsule_unit_y = vec2.fromValues(0,1);\n\n/**\n * @method raycast\n * @param  {RaycastResult} result\n * @param  {Ray} ray\n * @param  {array} position\n * @param  {number} angle\n */\nCapsule.prototype.raycast = function(result, ray, position, angle){\n    var from = ray.from;\n    var to = ray.to;\n    var direction = ray.direction;\n\n    var hitPointWorld = intersectCapsule_hitPointWorld;\n    var normal = intersectCapsule_normal;\n    var l0 = intersectCapsule_l0;\n    var l1 = intersectCapsule_l1;\n\n    // The sides\n    var halfLen = this.length / 2;\n    for(var i=0; i<2; i++){\n\n        // get start and end of the line\n        var y = this.radius * (i*2-1);\n        vec2.set(l0, -halfLen, y);\n        vec2.set(l1, halfLen, y);\n        vec2.toGlobalFrame(l0, l0, position, angle);\n        vec2.toGlobalFrame(l1, l1, position, angle);\n\n        var delta = vec2.getLineSegmentsIntersectionFraction(from, to, l0, l1);\n        if(delta >= 0){\n            vec2.rotate(normal, intersectCapsule_unit_y, angle);\n            vec2.scale(normal, normal, (i*2-1));\n            ray.reportIntersection(result, delta, normal, -1);\n            if(result.shouldStop(ray)){\n                return;\n            }\n        }\n    }\n\n    // Circles\n    var diagonalLengthSquared = Math.pow(this.radius, 2) + Math.pow(halfLen, 2);\n    for(var i=0; i<2; i++){\n        vec2.set(l0, halfLen * (i*2-1), 0);\n        vec2.toGlobalFrame(l0, l0, position, angle);\n\n        var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);\n        var b = 2 * ((to[0] - from[0]) * (from[0] - l0[0]) + (to[1] - from[1]) * (from[1] - l0[1]));\n        var c = Math.pow(from[0] - l0[0], 2) + Math.pow(from[1] - l0[1], 2) - Math.pow(this.radius, 2);\n        var delta = Math.pow(b, 2) - 4 * a * c;\n\n        if(delta < 0){\n            // No intersection\n            continue;\n\n        } else if(delta === 0){\n            // single intersection point\n            vec2.lerp(hitPointWorld, from, to, delta);\n\n            if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){\n                vec2.sub(normal, hitPointWorld, l0);\n                vec2.normalize(normal,normal);\n                ray.reportIntersection(result, delta, normal, -1);\n                if(result.shouldStop(ray)){\n                    return;\n                }\n            }\n\n        } else {\n            var sqrtDelta = Math.sqrt(delta);\n            var inv2a = 1 / (2 * a);\n            var d1 = (- b - sqrtDelta) * inv2a;\n            var d2 = (- b + sqrtDelta) * inv2a;\n\n            if(d1 >= 0 && d1 <= 1){\n                vec2.lerp(hitPointWorld, from, to, d1);\n                if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){\n                    vec2.sub(normal, hitPointWorld, l0);\n                    vec2.normalize(normal,normal);\n                    ray.reportIntersection(result, d1, normal, -1);\n                    if(result.shouldStop(ray)){\n                        return;\n                    }\n                }\n            }\n\n            if(d2 >= 0 && d2 <= 1){\n                vec2.lerp(hitPointWorld, from, to, d2);\n                if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){\n                    vec2.sub(normal, hitPointWorld, l0);\n                    vec2.normalize(normal,normal);\n                    ray.reportIntersection(result, d2, normal, -1);\n                    if(result.shouldStop(ray)){\n                        return;\n                    }\n                }\n            }\n        }\n    }\n};","var Shape = require('./Shape')\n,    vec2 = require('../math/vec2');\n\nmodule.exports = Circle;\n\n/**\n * Circle shape class.\n * @class Circle\n * @extends Shape\n * @constructor\n * @param {options} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {number} [options.radius=1] The radius of this circle\n *\n * @example\n *     var circleShape = new Circle({ radius: 1 });\n *     body.addShape(circleShape);\n */\nfunction Circle(options){\n    if(typeof(arguments[0]) === 'number'){\n        options = {\n            radius: arguments[0]\n        };\n        console.warn('The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })');\n    }\n    options = options || {};\n\n    /**\n     * The radius of the circle.\n     * @property radius\n     * @type {number}\n     */\n    this.radius = options.radius || 1;\n\n    options.type = Shape.CIRCLE;\n    Shape.call(this, options);\n}\nCircle.prototype = new Shape();\nCircle.prototype.constructor = Circle;\n\n/**\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n */\nCircle.prototype.computeMomentOfInertia = function(mass){\n    var r = this.radius;\n    return mass * r * r / 2;\n};\n\n/**\n * @method updateBoundingRadius\n * @return {Number}\n */\nCircle.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = this.radius;\n};\n\n/**\n * @method updateArea\n * @return {Number}\n */\nCircle.prototype.updateArea = function(){\n    this.area = Math.PI * this.radius * this.radius;\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nCircle.prototype.computeAABB = function(out, position, angle){\n    var r = this.radius;\n    vec2.set(out.upperBound,  r,  r);\n    vec2.set(out.lowerBound, -r, -r);\n    if(position){\n        vec2.add(out.lowerBound, out.lowerBound, position);\n        vec2.add(out.upperBound, out.upperBound, position);\n    }\n};\n\nvar Ray_intersectSphere_intersectionPoint = vec2.create();\nvar Ray_intersectSphere_normal = vec2.create();\n\n/**\n * @method raycast\n * @param  {RaycastResult} result\n * @param  {Ray} ray\n * @param  {array} position\n * @param  {number} angle\n */\nCircle.prototype.raycast = function(result, ray, position, angle){\n    var from = ray.from,\n        to = ray.to,\n        r = this.radius;\n\n    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);\n    var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));\n    var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);\n    var delta = Math.pow(b, 2) - 4 * a * c;\n\n    var intersectionPoint = Ray_intersectSphere_intersectionPoint;\n    var normal = Ray_intersectSphere_normal;\n\n    if(delta < 0){\n        // No intersection\n        return;\n\n    } else if(delta === 0){\n        // single intersection point\n        vec2.lerp(intersectionPoint, from, to, delta);\n\n        vec2.sub(normal, intersectionPoint, position);\n        vec2.normalize(normal,normal);\n\n        ray.reportIntersection(result, delta, normal, -1);\n\n    } else {\n        var sqrtDelta = Math.sqrt(delta);\n        var inv2a = 1 / (2 * a);\n        var d1 = (- b - sqrtDelta) * inv2a;\n        var d2 = (- b + sqrtDelta) * inv2a;\n\n        if(d1 >= 0 && d1 <= 1){\n            vec2.lerp(intersectionPoint, from, to, d1);\n\n            vec2.sub(normal, intersectionPoint, position);\n            vec2.normalize(normal,normal);\n\n            ray.reportIntersection(result, d1, normal, -1);\n\n            if(result.shouldStop(ray)){\n                return;\n            }\n        }\n\n        if(d2 >= 0 && d2 <= 1){\n            vec2.lerp(intersectionPoint, from, to, d2);\n\n            vec2.sub(normal, intersectionPoint, position);\n            vec2.normalize(normal,normal);\n\n            ray.reportIntersection(result, d2, normal, -1);\n        }\n    }\n};","var Shape = require('./Shape')\n,   vec2 = require('../math/vec2')\n,   polyk = require('../math/polyk')\n,   decomp = require('poly-decomp');\n\nmodule.exports = Convex;\n\n/**\n * Convex shape class.\n * @class Convex\n * @constructor\n * @extends Shape\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {Array} [options.vertices] An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.\n * @param {Array} [options.axes] An array of unit length vectors, representing the symmetry axes in the convex.\n * @example\n *     // Create a box\n *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];\n *     var convexShape = new Convex({ vertices: vertices });\n *     body.addShape(convexShape);\n */\nfunction Convex(options){\n    if(Array.isArray(arguments[0])){\n        options = {\n            vertices: arguments[0],\n            axes: arguments[1]\n        };\n        console.warn('The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })');\n    }\n    options = options || {};\n\n    /**\n     * Vertices defined in the local frame.\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = [];\n\n    // Copy the verts\n    var vertices = options.vertices !== undefined ? options.vertices : [];\n    for(var i=0; i < vertices.length; i++){\n        var v = vec2.create();\n        vec2.copy(v, vertices[i]);\n        this.vertices.push(v);\n    }\n\n    /**\n     * Axes defined in the local frame.\n     * @property axes\n     * @type {Array}\n     */\n    this.axes = [];\n\n    if(options.axes){\n\n        // Copy the axes\n        for(var i=0; i < options.axes.length; i++){\n            var axis = vec2.create();\n            vec2.copy(axis, options.axes[i]);\n            this.axes.push(axis);\n        }\n\n    } else {\n\n        // Construct axes from the vertex data\n        for(var i = 0; i < this.vertices.length; i++){\n            // Get the world edge\n            var worldPoint0 = this.vertices[i];\n            var worldPoint1 = this.vertices[(i+1) % this.vertices.length];\n\n            var normal = vec2.create();\n            vec2.sub(normal, worldPoint1, worldPoint0);\n\n            // Get normal - just rotate 90 degrees since vertices are given in CCW\n            vec2.rotate90cw(normal, normal);\n            vec2.normalize(normal, normal);\n\n            this.axes.push(normal);\n        }\n\n    }\n\n    /**\n     * The center of mass of the Convex\n     * @property centerOfMass\n     * @type {Array}\n     */\n    this.centerOfMass = vec2.fromValues(0,0);\n\n    /**\n     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.\n     * @property triangles\n     * @type {Array}\n     */\n    this.triangles = [];\n\n    if(this.vertices.length){\n        this.updateTriangles();\n        this.updateCenterOfMass();\n    }\n\n    /**\n     * The bounding radius of the convex\n     * @property boundingRadius\n     * @type {Number}\n     */\n    this.boundingRadius = 0;\n\n    options.type = Shape.CONVEX;\n    Shape.call(this, options);\n\n    this.updateBoundingRadius();\n    this.updateArea();\n    if(this.area < 0){\n        throw new Error(\"Convex vertices must be given in conter-clockwise winding.\");\n    }\n}\nConvex.prototype = new Shape();\nConvex.prototype.constructor = Convex;\n\nvar tmpVec1 = vec2.create();\nvar tmpVec2 = vec2.create();\n\n/**\n * Project a Convex onto a world-oriented axis\n * @method projectOntoAxis\n * @static\n * @param  {Array} offset\n * @param  {Array} localAxis\n * @param  {Array} result\n */\nConvex.prototype.projectOntoLocalAxis = function(localAxis, result){\n    var max=null,\n        min=null,\n        v,\n        value,\n        localAxis = tmpVec1;\n\n    // Get projected position of all vertices\n    for(var i=0; i<this.vertices.length; i++){\n        v = this.vertices[i];\n        value = vec2.dot(v, localAxis);\n        if(max === null || value > max){\n            max = value;\n        }\n        if(min === null || value < min){\n            min = value;\n        }\n    }\n\n    if(min > max){\n        var t = min;\n        min = max;\n        max = t;\n    }\n\n    vec2.set(result, min, max);\n};\n\nConvex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result){\n    var worldAxis = tmpVec2;\n\n    this.projectOntoLocalAxis(localAxis, result);\n\n    // Project the position of the body onto the axis - need to add this to the result\n    if(shapeAngle !== 0){\n        vec2.rotate(worldAxis, localAxis, shapeAngle);\n    } else {\n        worldAxis = localAxis;\n    }\n    var offset = vec2.dot(shapeOffset, worldAxis);\n\n    vec2.set(result, result[0] + offset, result[1] + offset);\n};\n\n\n/**\n * Update the .triangles property\n * @method updateTriangles\n */\nConvex.prototype.updateTriangles = function(){\n\n    this.triangles.length = 0;\n\n    // Rewrite on polyk notation, array of numbers\n    var polykVerts = [];\n    for(var i=0; i<this.vertices.length; i++){\n        var v = this.vertices[i];\n        polykVerts.push(v[0],v[1]);\n    }\n\n    // Triangulate\n    var triangles = polyk.Triangulate(polykVerts);\n\n    // Loop over all triangles, add their inertia contributions to I\n    for(var i=0; i<triangles.length; i+=3){\n        var id1 = triangles[i],\n            id2 = triangles[i+1],\n            id3 = triangles[i+2];\n\n        // Add to triangles\n        this.triangles.push([id1,id2,id3]);\n    }\n};\n\nvar updateCenterOfMass_centroid = vec2.create(),\n    updateCenterOfMass_centroid_times_mass = vec2.create(),\n    updateCenterOfMass_a = vec2.create(),\n    updateCenterOfMass_b = vec2.create(),\n    updateCenterOfMass_c = vec2.create(),\n    updateCenterOfMass_ac = vec2.create(),\n    updateCenterOfMass_ca = vec2.create(),\n    updateCenterOfMass_cb = vec2.create(),\n    updateCenterOfMass_n = vec2.create();\n\n/**\n * Update the .centerOfMass property.\n * @method updateCenterOfMass\n */\nConvex.prototype.updateCenterOfMass = function(){\n    var triangles = this.triangles,\n        verts = this.vertices,\n        cm = this.centerOfMass,\n        centroid = updateCenterOfMass_centroid,\n        n = updateCenterOfMass_n,\n        a = updateCenterOfMass_a,\n        b = updateCenterOfMass_b,\n        c = updateCenterOfMass_c,\n        ac = updateCenterOfMass_ac,\n        ca = updateCenterOfMass_ca,\n        cb = updateCenterOfMass_cb,\n        centroid_times_mass = updateCenterOfMass_centroid_times_mass;\n\n    vec2.set(cm,0,0);\n    var totalArea = 0;\n\n    for(var i=0; i!==triangles.length; i++){\n        var t = triangles[i],\n            a = verts[t[0]],\n            b = verts[t[1]],\n            c = verts[t[2]];\n\n        vec2.centroid(centroid,a,b,c);\n\n        // Get mass for the triangle (density=1 in this case)\n        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors\n        var m = Convex.triangleArea(a,b,c);\n        totalArea += m;\n\n        // Add to center of mass\n        vec2.scale(centroid_times_mass, centroid, m);\n        vec2.add(cm, cm, centroid_times_mass);\n    }\n\n    vec2.scale(cm,cm,1/totalArea);\n};\n\n/**\n * Compute the mass moment of inertia of the Convex.\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/\n */\nConvex.prototype.computeMomentOfInertia = function(mass){\n    var denom = 0.0,\n        numer = 0.0,\n        N = this.vertices.length;\n    for(var j = N-1, i = 0; i < N; j = i, i ++){\n        var p0 = this.vertices[j];\n        var p1 = this.vertices[i];\n        var a = Math.abs(vec2.crossLength(p0,p1));\n        var b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);\n        denom += a * b;\n        numer += a;\n    }\n    return (mass / 6.0) * (denom / numer);\n};\n\n/**\n * Updates the .boundingRadius property\n * @method updateBoundingRadius\n */\nConvex.prototype.updateBoundingRadius = function(){\n    var verts = this.vertices,\n        r2 = 0;\n\n    for(var i=0; i!==verts.length; i++){\n        var l2 = vec2.squaredLength(verts[i]);\n        if(l2 > r2){\n            r2 = l2;\n        }\n    }\n\n    this.boundingRadius = Math.sqrt(r2);\n};\n\n/**\n * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.\n * @static\n * @method triangleArea\n * @param {Array} a\n * @param {Array} b\n * @param {Array} c\n * @return {Number}\n */\nConvex.triangleArea = function(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;\n};\n\n/**\n * Update the .area\n * @method updateArea\n */\nConvex.prototype.updateArea = function(){\n    this.updateTriangles();\n    this.area = 0;\n\n    var triangles = this.triangles,\n        verts = this.vertices;\n    for(var i=0; i!==triangles.length; i++){\n        var t = triangles[i],\n            a = verts[t[0]],\n            b = verts[t[1]],\n            c = verts[t[2]];\n\n        // Get mass for the triangle (density=1 in this case)\n        var m = Convex.triangleArea(a,b,c);\n        this.area += m;\n    }\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out\n * @param  {Array}  position\n * @param  {Number} angle\n */\nConvex.prototype.computeAABB = function(out, position, angle){\n    out.setFromPoints(this.vertices, position, angle, 0);\n};\n\nvar intersectConvex_rayStart = vec2.create();\nvar intersectConvex_rayEnd = vec2.create();\nvar intersectConvex_normal = vec2.create();\n\n/**\n * @method raycast\n * @param  {RaycastResult} result\n * @param  {Ray} ray\n * @param  {array} position\n * @param  {number} angle\n */\nConvex.prototype.raycast = function(result, ray, position, angle){\n    var rayStart = intersectConvex_rayStart;\n    var rayEnd = intersectConvex_rayEnd;\n    var normal = intersectConvex_normal;\n    var vertices = this.vertices;\n\n    // Transform to local shape space\n    vec2.toLocalFrame(rayStart, ray.from, position, angle);\n    vec2.toLocalFrame(rayEnd, ray.to, position, angle);\n\n    var n = vertices.length;\n\n    for (var i = 0; i < n && !result.shouldStop(ray); i++) {\n        var q1 = vertices[i];\n        var q2 = vertices[(i+1) % n];\n        var delta = vec2.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);\n\n        if(delta >= 0){\n            vec2.sub(normal, q2, q1);\n            vec2.rotate(normal, normal, -Math.PI / 2 + angle);\n            vec2.normalize(normal, normal);\n            ray.reportIntersection(result, delta, normal, i);\n        }\n    }\n};\n","var Shape = require('./Shape')\n,    vec2 = require('../math/vec2')\n,    Utils = require('../utils/Utils');\n\nmodule.exports = Heightfield;\n\n/**\n * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance \"elementWidth\".\n * @class Heightfield\n * @extends Shape\n * @constructor\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {array} [options.heights] An array of Y values that will be used to construct the terrain.\n * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.\n * @param {Number} [options.maxValue] Maximum value.\n * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.\n *\n * @example\n *     // Generate some height data (y-values).\n *     var heights = [];\n *     for(var i = 0; i < 1000; i++){\n *         var y = 0.5 * Math.cos(0.2 * i);\n *         heights.push(y);\n *     }\n *\n *     // Create the heightfield shape\n *     var heightfieldShape = new Heightfield({\n *         heights: heights,\n *         elementWidth: 1 // Distance between the data points in X direction\n *     });\n *     var heightfieldBody = new Body();\n *     heightfieldBody.addShape(heightfieldShape);\n *     world.addBody(heightfieldBody);\n *\n * @todo Should use a scale property with X and Y direction instead of just elementWidth\n */\nfunction Heightfield(options){\n    if(Array.isArray(arguments[0])){\n        options = {\n            heights: arguments[0]\n        };\n\n        if(typeof(arguments[1]) === 'object'){\n            for(var key in arguments[1]){\n                options[key] = arguments[1][key];\n            }\n        }\n\n        console.warn('The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })');\n    }\n    options = options || {};\n\n    /**\n     * An array of numbers, or height values, that are spread out along the x axis.\n     * @property {array} heights\n     */\n    this.heights = options.heights ? options.heights.slice(0) : [];\n\n    /**\n     * Max value of the heights\n     * @property {number} maxValue\n     */\n    this.maxValue = options.maxValue || null;\n\n    /**\n     * Max value of the heights\n     * @property {number} minValue\n     */\n    this.minValue = options.minValue || null;\n\n    /**\n     * The width of each element\n     * @property {number} elementWidth\n     */\n    this.elementWidth = options.elementWidth || 0.1;\n\n    if(options.maxValue === undefined || options.minValue === undefined){\n        this.updateMaxMinValues();\n    }\n\n    options.type = Shape.HEIGHTFIELD;\n    Shape.call(this, options);\n}\nHeightfield.prototype = new Shape();\nHeightfield.prototype.constructor = Heightfield;\n\n/**\n * Update the .minValue and the .maxValue\n * @method updateMaxMinValues\n */\nHeightfield.prototype.updateMaxMinValues = function(){\n    var data = this.heights;\n    var maxValue = data[0];\n    var minValue = data[0];\n    for(var i=0; i !== data.length; i++){\n        var v = data[i];\n        if(v > maxValue){\n            maxValue = v;\n        }\n        if(v < minValue){\n            minValue = v;\n        }\n    }\n    this.maxValue = maxValue;\n    this.minValue = minValue;\n};\n\n/**\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n */\nHeightfield.prototype.computeMomentOfInertia = function(mass){\n    return Number.MAX_VALUE;\n};\n\nHeightfield.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = Number.MAX_VALUE;\n};\n\nHeightfield.prototype.updateArea = function(){\n    var data = this.heights,\n        area = 0;\n    for(var i=0; i<data.length-1; i++){\n        area += (data[i]+data[i+1]) / 2 * this.elementWidth;\n    }\n    this.area = area;\n};\n\nvar points = [\n    vec2.create(),\n    vec2.create(),\n    vec2.create(),\n    vec2.create()\n];\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nHeightfield.prototype.computeAABB = function(out, position, angle){\n    vec2.set(points[0], 0, this.maxValue);\n    vec2.set(points[1], this.elementWidth * this.heights.length, this.maxValue);\n    vec2.set(points[2], this.elementWidth * this.heights.length, this.minValue);\n    vec2.set(points[3], 0, this.minValue);\n    out.setFromPoints(points, position, angle);\n};\n\n/**\n * Get a line segment in the heightfield\n * @method getLineSegment\n * @param  {array} start Where to store the resulting start point\n * @param  {array} end Where to store the resulting end point\n * @param  {number} i\n */\nHeightfield.prototype.getLineSegment = function(start, end, i){\n    var data = this.heights;\n    var width = this.elementWidth;\n    vec2.set(start, i * width, data[i]);\n    vec2.set(end, (i + 1) * width, data[i + 1]);\n};\n\nHeightfield.prototype.getSegmentIndex = function(position){\n    return Math.floor(position[0] / this.elementWidth);\n};\n\nHeightfield.prototype.getClampedSegmentIndex = function(position){\n    var i = this.getSegmentIndex(position);\n    i = Math.min(this.heights.length, Math.max(i, 0)); // clamp\n    return i;\n};\n\nvar intersectHeightfield_hitPointWorld = vec2.create();\nvar intersectHeightfield_worldNormal = vec2.create();\nvar intersectHeightfield_l0 = vec2.create();\nvar intersectHeightfield_l1 = vec2.create();\nvar intersectHeightfield_localFrom = vec2.create();\nvar intersectHeightfield_localTo = vec2.create();\nvar intersectHeightfield_unit_y = vec2.fromValues(0,1);\n\n// Returns 1 if the lines intersect, otherwise 0.\nfunction getLineSegmentsIntersection (out, p0, p1, p2, p3) {\n\n    var s1_x, s1_y, s2_x, s2_y;\n    s1_x = p1[0] - p0[0];\n    s1_y = p1[1] - p0[1];\n    s2_x = p3[0] - p2[0];\n    s2_y = p3[1] - p2[1];\n\n    var s, t;\n    s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected\n        var intX = p0[0] + (t * s1_x);\n        var intY = p0[1] + (t * s1_y);\n        out[0] = intX;\n        out[1] = intY;\n        return t;\n    }\n    return -1; // No collision\n}\n\n/**\n * @method raycast\n * @param  {RayResult} result\n * @param  {Ray} ray\n * @param  {array} position\n * @param  {number} angle\n */\nHeightfield.prototype.raycast = function(result, ray, position, angle){\n    var from = ray.from;\n    var to = ray.to;\n    var direction = ray.direction;\n\n    var hitPointWorld = intersectHeightfield_hitPointWorld;\n    var worldNormal = intersectHeightfield_worldNormal;\n    var l0 = intersectHeightfield_l0;\n    var l1 = intersectHeightfield_l1;\n    var localFrom = intersectHeightfield_localFrom;\n    var localTo = intersectHeightfield_localTo;\n\n    // get local ray start and end\n    vec2.toLocalFrame(localFrom, from, position, angle);\n    vec2.toLocalFrame(localTo, to, position, angle);\n\n    // Get the segment range\n    var i0 = this.getClampedSegmentIndex(localFrom);\n    var i1 = this.getClampedSegmentIndex(localTo);\n    if(i0 > i1){\n        var tmp = i0;\n        i0 = i1;\n        i1 = tmp;\n    }\n\n    // The segments\n    for(var i=0; i<this.heights.length - 1; i++){\n        this.getLineSegment(l0, l1, i);\n        var t = vec2.getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);\n        if(t >= 0){\n            vec2.sub(worldNormal, l1, l0);\n            vec2.rotate(worldNormal, worldNormal, angle + Math.PI / 2);\n            vec2.normalize(worldNormal, worldNormal);\n            ray.reportIntersection(result, t, worldNormal, -1);\n            if(result.shouldStop(ray)){\n                return;\n            }\n        }\n    }\n};","var Shape = require('./Shape')\n,   vec2 = require('../math/vec2');\n\nmodule.exports = Line;\n\n/**\n * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].\n * @class Line\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {Number} [options.length=1] The total length of the line\n * @extends Shape\n * @constructor\n */\nfunction Line(options){\n    if(typeof(arguments[0]) === 'number'){\n        options = {\n            length: arguments[0]\n        };\n        console.warn('The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })');\n    }\n    options = options || {};\n\n    /**\n     * Length of this line\n     * @property {Number} length\n     * @default 1\n     */\n    this.length = options.length || 1;\n\n    options.type = Shape.LINE;\n    Shape.call(this, options);\n}\nLine.prototype = new Shape();\nLine.prototype.constructor = Line;\n\nLine.prototype.computeMomentOfInertia = function(mass){\n    return mass * Math.pow(this.length,2) / 12;\n};\n\nLine.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = this.length/2;\n};\n\nvar points = [vec2.create(),vec2.create()];\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nLine.prototype.computeAABB = function(out, position, angle){\n    var l2 = this.length / 2;\n    vec2.set(points[0], -l2,  0);\n    vec2.set(points[1],  l2,  0);\n    out.setFromPoints(points,position,angle,0);\n};\n\nvar raycast_hitPoint = vec2.create();\nvar raycast_normal = vec2.create();\nvar raycast_l0 = vec2.create();\nvar raycast_l1 = vec2.create();\nvar raycast_unit_y = vec2.fromValues(0,1);\n\n/**\n * @method raycast\n * @param  {RaycastResult} result\n * @param  {Ray} ray\n * @param  {number} angle\n * @param  {array} position\n */\nLine.prototype.raycast = function(result, ray, position, angle){\n    var from = ray.from;\n    var to = ray.to;\n\n    var l0 = raycast_l0;\n    var l1 = raycast_l1;\n\n    // get start and end of the line\n    var halfLen = this.length / 2;\n    vec2.set(l0, -halfLen, 0);\n    vec2.set(l1, halfLen, 0);\n    vec2.toGlobalFrame(l0, l0, position, angle);\n    vec2.toGlobalFrame(l1, l1, position, angle);\n\n    var fraction = vec2.getLineSegmentsIntersectionFraction(l0, l1, from, to);\n    if(fraction >= 0){\n        var normal = raycast_normal;\n        vec2.rotate(normal, raycast_unit_y, angle); // todo: this should depend on which side the ray comes from\n        ray.reportIntersection(result, fraction, normal, -1);\n    }\n};","var Shape = require('./Shape')\n,   vec2 = require('../math/vec2');\n\nmodule.exports = Particle;\n\n/**\n * Particle shape class.\n * @class Particle\n * @constructor\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @extends Shape\n */\nfunction Particle(options){\n    options = options || {};\n\toptions.type = Shape.PARTICLE;\n    Shape.call(this, options);\n}\nParticle.prototype = new Shape();\nParticle.prototype.constructor = Particle;\n\nParticle.prototype.computeMomentOfInertia = function(mass){\n    return 0; // Can't rotate a particle\n};\n\nParticle.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = 0;\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out\n * @param  {Array}  position\n * @param  {Number} angle\n */\nParticle.prototype.computeAABB = function(out, position, angle){\n    vec2.copy(out.lowerBound, position);\n    vec2.copy(out.upperBound, position);\n};\n","var Shape =  require('./Shape')\n,    vec2 =  require('../math/vec2')\n,    Utils = require('../utils/Utils');\n\nmodule.exports = Plane;\n\n/**\n * Plane shape class. The plane is facing in the Y direction.\n * @class Plane\n * @extends Shape\n * @constructor\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n */\nfunction Plane(options){\n    options = options || {};\n    options.type = Shape.PLANE;\n    Shape.call(this, options);\n}\nPlane.prototype = new Shape();\nPlane.prototype.constructor = Plane;\n\n/**\n * Compute moment of inertia\n * @method computeMomentOfInertia\n */\nPlane.prototype.computeMomentOfInertia = function(mass){\n    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here\n};\n\n/**\n * Update the bounding radius\n * @method updateBoundingRadius\n */\nPlane.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = Number.MAX_VALUE;\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out\n * @param  {Array}  position\n * @param  {Number} angle\n */\nPlane.prototype.computeAABB = function(out, position, angle){\n    var a = angle % (2 * Math.PI);\n    var set = vec2.set;\n    var max = 1e7;\n    var lowerBound = out.lowerBound;\n    var upperBound = out.upperBound;\n\n    // Set max bounds\n    set(lowerBound, -max, -max);\n    set(upperBound,  max,  max);\n\n    if(a === 0){\n        // y goes from -inf to 0\n        upperBound[1] = 0;\n        // set(lowerBound, -max, -max);\n        // set(upperBound,  max,  0);\n\n    } else if(a === Math.PI / 2){\n\n        // x goes from 0 to inf\n        lowerBound[0] = 0;\n        // set(lowerBound, 0, -max);\n        // set(upperBound,      max,  max);\n\n    } else if(a === Math.PI){\n\n        // y goes from 0 to inf\n        lowerBound[1] = 0;\n        // set(lowerBound, -max, 0);\n        // set(upperBound,  max, max);\n\n    } else if(a === 3*Math.PI/2){\n\n        // x goes from -inf to 0\n        upperBound[0] = 0;\n        // set(lowerBound, -max,     -max);\n        // set(upperBound,  0,  max);\n\n    }\n};\n\nPlane.prototype.updateArea = function(){\n    this.area = Number.MAX_VALUE;\n};\n\nvar intersectPlane_planePointToFrom = vec2.create();\nvar intersectPlane_dir_scaled_with_t = vec2.create();\nvar intersectPlane_hitPoint = vec2.create();\nvar intersectPlane_normal = vec2.create();\nvar intersectPlane_len = vec2.create();\n\n/**\n * @method raycast\n * @param  {RayResult} result\n * @param  {Ray} ray\n * @param  {array} position\n * @param  {number} angle\n */\nPlane.prototype.raycast = function(result, ray, position, angle){\n    var from = ray.from;\n    var to = ray.to;\n    var direction = ray.direction;\n    var planePointToFrom = intersectPlane_planePointToFrom;\n    var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;\n    var hitPoint = intersectPlane_hitPoint;\n    var normal = intersectPlane_normal;\n    var len = intersectPlane_len;\n\n    // Get plane normal\n    vec2.set(normal, 0, 1);\n    vec2.rotate(normal, normal, angle);\n\n    vec2.sub(len, from, position);\n    var planeToFrom = vec2.dot(len, normal);\n    vec2.sub(len, to, position);\n    var planeToTo = vec2.dot(len, normal);\n\n    if(planeToFrom * planeToTo > 0){\n        // \"from\" and \"to\" are on the same side of the plane... bail out\n        return;\n    }\n\n    if(vec2.squaredDistance(from, to) < planeToFrom * planeToFrom){\n        return;\n    }\n\n    var n_dot_dir = vec2.dot(normal, direction);\n\n    vec2.sub(planePointToFrom, from, position);\n    var t = -vec2.dot(normal, planePointToFrom) / n_dot_dir / ray.length;\n\n    ray.reportIntersection(result, t, normal, -1);\n};","module.exports = Shape;\n\nvar vec2 = require('../math/vec2');\n\n/**\n * Base class for shapes.\n * @class Shape\n * @constructor\n * @param {object} [options]\n * @param {array} [options.position]\n * @param {number} [options.angle=0]\n * @param {number} [options.collisionGroup=1]\n * @param {number} [options.collisionMask=1]\n * @param {boolean} [options.sensor=false]\n * @param {boolean} [options.collisionResponse=true]\n * @param {object} [options.type=0]\n */\nfunction Shape(options){\n    options = options || {};\n\n    /**\n     * The body this shape is attached to. A shape can only be attached to a single body.\n     * @property {Body} body\n     */\n    this.body = null;\n\n    /**\n     * Body-local position of the shape.\n     * @property {Array} position\n     */\n    this.position = vec2.fromValues(0,0);\n    if(options.position){\n        vec2.copy(this.position, options.position);\n    }\n\n    /**\n     * Body-local angle of the shape.\n     * @property {number} angle\n     */\n    this.angle = options.angle || 0;\n\n    /**\n     * The type of the shape. One of:\n     *\n     * * {{#crossLink \"Shape/CIRCLE:property\"}}Shape.CIRCLE{{/crossLink}}\n     * * {{#crossLink \"Shape/PARTICLE:property\"}}Shape.PARTICLE{{/crossLink}}\n     * * {{#crossLink \"Shape/PLANE:property\"}}Shape.PLANE{{/crossLink}}\n     * * {{#crossLink \"Shape/CONVEX:property\"}}Shape.CONVEX{{/crossLink}}\n     * * {{#crossLink \"Shape/LINE:property\"}}Shape.LINE{{/crossLink}}\n     * * {{#crossLink \"Shape/BOX:property\"}}Shape.BOX{{/crossLink}}\n     * * {{#crossLink \"Shape/CAPSULE:property\"}}Shape.CAPSULE{{/crossLink}}\n     * * {{#crossLink \"Shape/HEIGHTFIELD:property\"}}Shape.HEIGHTFIELD{{/crossLink}}\n     *\n     * @property {number} type\n     */\n    this.type = options.type || 0;\n\n    /**\n     * Shape object identifier.\n     * @type {Number}\n     * @property id\n     */\n    this.id = Shape.idCounter++;\n\n    /**\n     * Bounding circle radius of this shape\n     * @property boundingRadius\n     * @type {Number}\n     */\n    this.boundingRadius = 0;\n\n    /**\n     * Collision group that this shape belongs to (bit mask). See <a href=\"http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/\">this tutorial</a>.\n     * @property collisionGroup\n     * @type {Number}\n     * @example\n     *     // Setup bits for each available group\n     *     var PLAYER = Math.pow(2,0),\n     *         ENEMY =  Math.pow(2,1),\n     *         GROUND = Math.pow(2,2)\n     *\n     *     // Put shapes into their groups\n     *     player1Shape.collisionGroup = PLAYER;\n     *     player2Shape.collisionGroup = PLAYER;\n     *     enemyShape  .collisionGroup = ENEMY;\n     *     groundShape .collisionGroup = GROUND;\n     *\n     *     // Assign groups that each shape collide with.\n     *     // Note that the players can collide with ground and enemies, but not with other players.\n     *     player1Shape.collisionMask = ENEMY | GROUND;\n     *     player2Shape.collisionMask = ENEMY | GROUND;\n     *     enemyShape  .collisionMask = PLAYER | GROUND;\n     *     groundShape .collisionMask = PLAYER | ENEMY;\n     *\n     * @example\n     *     // How collision check is done\n     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){\n     *         // The shapes will collide\n     *     }\n     */\n    this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : 1;\n\n    /**\n     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.\n     * @property {Boolean} collisionResponse\n     */\n    this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;\n\n    /**\n     * Collision mask of this shape. See .collisionGroup.\n     * @property collisionMask\n     * @type {Number}\n     */\n    this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : 1;\n\n    /**\n     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.\n     * @property material\n     * @type {Material}\n     */\n    this.material = options.material || null;\n\n    /**\n     * Area of this shape.\n     * @property area\n     * @type {Number}\n     */\n    this.area = 0;\n\n    /**\n     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.\n     * @property {Boolean} sensor\n     */\n    this.sensor = options.sensor !== undefined ? options.sensor : false;\n\n    if(this.type){\n        this.updateBoundingRadius();\n    }\n\n    this.updateArea();\n}\n\nShape.idCounter = 0;\n\n/**\n * @static\n * @property {Number} CIRCLE\n */\nShape.CIRCLE =      1;\n\n/**\n * @static\n * @property {Number} PARTICLE\n */\nShape.PARTICLE =    2;\n\n/**\n * @static\n * @property {Number} PLANE\n */\nShape.PLANE =       4;\n\n/**\n * @static\n * @property {Number} CONVEX\n */\nShape.CONVEX =      8;\n\n/**\n * @static\n * @property {Number} LINE\n */\nShape.LINE =        16;\n\n/**\n * @static\n * @property {Number} BOX\n */\nShape.BOX =   32;\n\nObject.defineProperty(Shape, 'RECTANGLE', {\n    get: function() {\n        console.warn('Shape.RECTANGLE is deprecated, use Shape.BOX instead.');\n        return Shape.BOX;\n    }\n});\n\n/**\n * @static\n * @property {Number} CAPSULE\n */\nShape.CAPSULE =     64;\n\n/**\n * @static\n * @property {Number} HEIGHTFIELD\n */\nShape.HEIGHTFIELD = 128;\n\n/**\n * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href=\"http://en.wikipedia.org/wiki/List_of_moments_of_inertia\">Wikipedia's list of moments of inertia</a>.\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.\n */\nShape.prototype.computeMomentOfInertia = function(mass){};\n\n/**\n * Returns the bounding circle radius of this shape.\n * @method updateBoundingRadius\n * @return {Number}\n */\nShape.prototype.updateBoundingRadius = function(){};\n\n/**\n * Update the .area property of the shape.\n * @method updateArea\n */\nShape.prototype.updateArea = function(){\n    // To be implemented in all subclasses\n};\n\n/**\n * Compute the world axis-aligned bounding box (AABB) of this shape.\n * @method computeAABB\n * @param  {AABB} out The resulting AABB.\n * @param  {Array} position World position of the shape.\n * @param  {Number} angle World angle of the shape.\n */\nShape.prototype.computeAABB = function(out, position, angle){\n    // To be implemented in each subclass\n};\n\n/**\n * Perform raycasting on this shape.\n * @method raycast\n * @param  {RayResult} result Where to store the resulting data.\n * @param  {Ray} ray The Ray that you want to use for raycasting.\n * @param  {array} position World position of the shape (the .position property will be ignored).\n * @param  {number} angle World angle of the shape (the .angle property will be ignored).\n */\nShape.prototype.raycast = function(result, ray, position, angle){\n    // To be implemented in each subclass\n};","var vec2 = require('../math/vec2')\n,   Solver = require('./Solver')\n,   Utils = require('../utils/Utils')\n,   FrictionEquation = require('../equations/FrictionEquation');\n\nmodule.exports = GSSolver;\n\n/**\n * Iterative Gauss-Seidel constraint equation solver.\n *\n * @class GSSolver\n * @constructor\n * @extends Solver\n * @param {Object} [options]\n * @param {Number} [options.iterations=10]\n * @param {Number} [options.tolerance=0]\n */\nfunction GSSolver(options){\n    Solver.call(this,options,Solver.GS);\n    options = options || {};\n\n    /**\n     * The max number of iterations to do when solving. More gives better results, but is more expensive.\n     * @property iterations\n     * @type {Number}\n     */\n    this.iterations = options.iterations || 10;\n\n    /**\n     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.\n     * @property tolerance\n     * @type {Number}\n     * @default 1e-7\n     */\n    this.tolerance = options.tolerance || 1e-7;\n\n    this.arrayStep = 30;\n    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);\n    this.Bs =     new Utils.ARRAY_TYPE(this.arrayStep);\n    this.invCs =  new Utils.ARRAY_TYPE(this.arrayStep);\n\n    /**\n     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.\n     * @property useZeroRHS\n     * @type {Boolean}\n     * @todo Remove, not used\n     */\n    this.useZeroRHS = false;\n\n    /**\n     * Number of solver iterations that are used to approximate normal forces used for friction (F_friction = mu * F_normal). These friction forces will override any other friction forces that are set. If you set frictionIterations = 0, then this feature will be disabled.\n     *\n     * Use only frictionIterations > 0 if the approximated normal force (F_normal = mass * gravity) is not good enough. Examples of where it can happen is in space games where gravity is zero, or in tall stacks where the normal force is large at bottom but small at top.\n     *\n     * @property frictionIterations\n     * @type {Number}\n     * @default 0\n     */\n    this.frictionIterations = options.frictionIterations !== undefined ? 0 : options.frictionIterations;\n\n    /**\n     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.\n     * @property {Number} usedIterations\n     */\n    this.usedIterations = 0;\n}\nGSSolver.prototype = new Solver();\nGSSolver.prototype.constructor = GSSolver;\n\nfunction setArrayZero(array){\n    var l = array.length;\n    while(l--){\n        array[l] = +0.0;\n    }\n}\n\n/**\n * Solve the system of equations\n * @method solve\n * @param  {Number}  h       Time step\n * @param  {World}   world    World to solve\n */\nGSSolver.prototype.solve = function(h, world){\n\n    this.sortEquations();\n\n    var iter = 0,\n        maxIter = this.iterations,\n        maxFrictionIter = this.frictionIterations,\n        equations = this.equations,\n        Neq = equations.length,\n        tolSquared = Math.pow(this.tolerance*Neq, 2),\n        bodies = world.bodies,\n        Nbodies = world.bodies.length,\n        add = vec2.add,\n        set = vec2.set,\n        useZeroRHS = this.useZeroRHS,\n        lambda = this.lambda;\n\n    this.usedIterations = 0;\n\n    if(Neq){\n        for(var i=0; i!==Nbodies; i++){\n            var b = bodies[i];\n\n            // Update solve mass\n            b.updateSolveMassProperties();\n        }\n    }\n\n    // Things that does not change during iteration can be computed once\n    if(lambda.length < Neq){\n        lambda = this.lambda =  new Utils.ARRAY_TYPE(Neq + this.arrayStep);\n        this.Bs =               new Utils.ARRAY_TYPE(Neq + this.arrayStep);\n        this.invCs =            new Utils.ARRAY_TYPE(Neq + this.arrayStep);\n    }\n    setArrayZero(lambda);\n    var invCs = this.invCs,\n        Bs = this.Bs,\n        lambda = this.lambda;\n\n    for(var i=0; i!==equations.length; i++){\n        var c = equations[i];\n        if(c.timeStep !== h || c.needsUpdate){\n            c.timeStep = h;\n            c.update();\n        }\n        Bs[i] =     c.computeB(c.a,c.b,h);\n        invCs[i] =  c.computeInvC(c.epsilon);\n    }\n\n    var q, B, c, deltalambdaTot,i,j;\n\n    if(Neq !== 0){\n\n        for(i=0; i!==Nbodies; i++){\n            var b = bodies[i];\n\n            // Reset vlambda\n            b.resetConstraintVelocity();\n        }\n\n        if(maxFrictionIter){\n            // Iterate over contact equations to get normal forces\n            for(iter=0; iter!==maxFrictionIter; iter++){\n\n                // Accumulate the total error for each iteration.\n                deltalambdaTot = 0.0;\n\n                for(j=0; j!==Neq; j++){\n                    c = equations[j];\n\n                    var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);\n                    deltalambdaTot += Math.abs(deltalambda);\n                }\n\n                this.usedIterations++;\n\n                // If the total error is small enough - stop iterate\n                if(deltalambdaTot*deltalambdaTot <= tolSquared){\n                    break;\n                }\n            }\n\n            GSSolver.updateMultipliers(equations, lambda, 1/h);\n\n            // Set computed friction force\n            for(j=0; j!==Neq; j++){\n                var eq = equations[j];\n                if(eq instanceof FrictionEquation){\n                    var f = 0.0;\n                    for(var k=0; k!==eq.contactEquations.length; k++){\n                        f += eq.contactEquations[k].multiplier;\n                    }\n                    f *= eq.frictionCoefficient / eq.contactEquations.length;\n                    eq.maxForce =  f;\n                    eq.minForce = -f;\n                }\n            }\n        }\n\n        // Iterate over all equations\n        for(iter=0; iter!==maxIter; iter++){\n\n            // Accumulate the total error for each iteration.\n            deltalambdaTot = 0.0;\n\n            for(j=0; j!==Neq; j++){\n                c = equations[j];\n\n                var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);\n                deltalambdaTot += Math.abs(deltalambda);\n            }\n\n            this.usedIterations++;\n\n            // If the total error is small enough - stop iterate\n            if(deltalambdaTot*deltalambdaTot <= tolSquared){\n                break;\n            }\n        }\n\n        // Add result to velocity\n        for(i=0; i!==Nbodies; i++){\n            bodies[i].addConstraintVelocity();\n        }\n\n        GSSolver.updateMultipliers(equations, lambda, 1/h);\n    }\n};\n\n// Sets the .multiplier property of each equation\nGSSolver.updateMultipliers = function(equations, lambda, invDt){\n    // Set the .multiplier property of each equation\n    var l = equations.length;\n    while(l--){\n        equations[l].multiplier = lambda[l] * invDt;\n    }\n};\n\nGSSolver.iterateEquation = function(j,eq,eps,Bs,invCs,lambda,useZeroRHS,dt,iter){\n    // Compute iteration\n    var B = Bs[j],\n        invC = invCs[j],\n        lambdaj = lambda[j],\n        GWlambda = eq.computeGWlambda();\n\n    var maxForce = eq.maxForce,\n        minForce = eq.minForce;\n\n    if(useZeroRHS){\n        B = 0;\n    }\n\n    var deltalambda = invC * ( B - GWlambda - eps * lambdaj );\n\n    // Clamp if we are not within the min/max interval\n    var lambdaj_plus_deltalambda = lambdaj + deltalambda;\n    if(lambdaj_plus_deltalambda < minForce*dt){\n        deltalambda = minForce*dt - lambdaj;\n    } else if(lambdaj_plus_deltalambda > maxForce*dt){\n        deltalambda = maxForce*dt - lambdaj;\n    }\n    lambda[j] += deltalambda;\n    eq.addToWlambda(deltalambda);\n\n    return deltalambda;\n};\n","var Utils = require('../utils/Utils')\n,   EventEmitter = require('../events/EventEmitter');\n\nmodule.exports = Solver;\n\n/**\n * Base class for constraint solvers.\n * @class Solver\n * @constructor\n * @extends EventEmitter\n */\nfunction Solver(options,type){\n    options = options || {};\n\n    EventEmitter.call(this);\n\n    this.type = type;\n\n    /**\n     * Current equations in the solver.\n     *\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * Function that is used to sort all equations before each solve.\n     * @property equationSortFunction\n     * @type {function|boolean}\n     */\n    this.equationSortFunction = options.equationSortFunction || false;\n}\nSolver.prototype = new EventEmitter();\nSolver.prototype.constructor = Solver;\n\n/**\n * Method to be implemented in each subclass\n * @method solve\n * @param  {Number} dt\n * @param  {World} world\n */\nSolver.prototype.solve = function(dt,world){\n    throw new Error(\"Solver.solve should be implemented by subclasses!\");\n};\n\nvar mockWorld = {bodies:[]};\n\n/**\n * Solves all constraints in an island.\n * @method solveIsland\n * @param  {Number} dt\n * @param  {Island} island\n */\nSolver.prototype.solveIsland = function(dt,island){\n\n    this.removeAllEquations();\n\n    if(island.equations.length){\n        // Add equations to solver\n        this.addEquations(island.equations);\n        mockWorld.bodies.length = 0;\n        island.getBodies(mockWorld.bodies);\n\n        // Solve\n        if(mockWorld.bodies.length){\n            this.solve(dt,mockWorld);\n        }\n    }\n};\n\n/**\n * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.\n * @method sortEquations\n */\nSolver.prototype.sortEquations = function(){\n    if(this.equationSortFunction){\n        this.equations.sort(this.equationSortFunction);\n    }\n};\n\n/**\n * Add an equation to be solved.\n *\n * @method addEquation\n * @param {Equation} eq\n */\nSolver.prototype.addEquation = function(eq){\n    if(eq.enabled){\n        this.equations.push(eq);\n    }\n};\n\n/**\n * Add equations. Same as .addEquation, but this time the argument is an array of Equations\n *\n * @method addEquations\n * @param {Array} eqs\n */\nSolver.prototype.addEquations = function(eqs){\n    //Utils.appendArray(this.equations,eqs);\n    for(var i=0, N=eqs.length; i!==N; i++){\n        var eq = eqs[i];\n        if(eq.enabled){\n            this.equations.push(eq);\n        }\n    }\n};\n\n/**\n * Remove an equation.\n *\n * @method removeEquation\n * @param {Equation} eq\n */\nSolver.prototype.removeEquation = function(eq){\n    var i = this.equations.indexOf(eq);\n    if(i !== -1){\n        this.equations.splice(i,1);\n    }\n};\n\n/**\n * Remove all currently added equations.\n *\n * @method removeAllEquations\n */\nSolver.prototype.removeAllEquations = function(){\n    this.equations.length=0;\n};\n\nSolver.GS = 1;\nSolver.ISLAND = 2;\n","var ContactEquation = require('../equations/ContactEquation');\nvar Pool = require('./Pool');\n\nmodule.exports = ContactEquationPool;\n\n/**\n * @class\n */\nfunction ContactEquationPool() {\n\tPool.apply(this, arguments);\n}\nContactEquationPool.prototype = new Pool();\nContactEquationPool.prototype.constructor = ContactEquationPool;\n\n/**\n * @method create\n * @return {ContactEquation}\n */\nContactEquationPool.prototype.create = function () {\n\treturn new ContactEquation();\n};\n\n/**\n * @method destroy\n * @param {ContactEquation} equation\n * @return {ContactEquationPool}\n */\nContactEquationPool.prototype.destroy = function (equation) {\n\tequation.bodyA = equation.bodyB = null;\n\treturn this;\n};\n","var FrictionEquation = require('../equations/FrictionEquation');\nvar Pool = require('./Pool');\n\nmodule.exports = FrictionEquationPool;\n\n/**\n * @class\n */\nfunction FrictionEquationPool() {\n\tPool.apply(this, arguments);\n}\nFrictionEquationPool.prototype = new Pool();\nFrictionEquationPool.prototype.constructor = FrictionEquationPool;\n\n/**\n * @method create\n * @return {FrictionEquation}\n */\nFrictionEquationPool.prototype.create = function () {\n\treturn new FrictionEquation();\n};\n\n/**\n * @method destroy\n * @param {FrictionEquation} equation\n * @return {FrictionEquationPool}\n */\nFrictionEquationPool.prototype.destroy = function (equation) {\n\tequation.bodyA = equation.bodyB = null;\n\treturn this;\n};\n","var IslandNode = require('../world/IslandNode');\nvar Pool = require('./Pool');\n\nmodule.exports = IslandNodePool;\n\n/**\n * @class\n */\nfunction IslandNodePool() {\n\tPool.apply(this, arguments);\n}\nIslandNodePool.prototype = new Pool();\nIslandNodePool.prototype.constructor = IslandNodePool;\n\n/**\n * @method create\n * @return {IslandNode}\n */\nIslandNodePool.prototype.create = function () {\n\treturn new IslandNode();\n};\n\n/**\n * @method destroy\n * @param {IslandNode} node\n * @return {IslandNodePool}\n */\nIslandNodePool.prototype.destroy = function (node) {\n\tnode.reset();\n\treturn this;\n};\n","var Island = require('../world/Island');\nvar Pool = require('./Pool');\n\nmodule.exports = IslandPool;\n\n/**\n * @class\n */\nfunction IslandPool() {\n\tPool.apply(this, arguments);\n}\nIslandPool.prototype = new Pool();\nIslandPool.prototype.constructor = IslandPool;\n\n/**\n * @method create\n * @return {Island}\n */\nIslandPool.prototype.create = function () {\n\treturn new Island();\n};\n\n/**\n * @method destroy\n * @param {Island} island\n * @return {IslandPool}\n */\nIslandPool.prototype.destroy = function (island) {\n\tisland.reset();\n\treturn this;\n};\n","var TupleDictionary = require('./TupleDictionary');\nvar OverlapKeeperRecord = require('./OverlapKeeperRecord');\nvar OverlapKeeperRecordPool = require('./OverlapKeeperRecordPool');\nvar Utils = require('./Utils');\n\nmodule.exports = OverlapKeeper;\n\n/**\n * Keeps track of overlaps in the current state and the last step state.\n * @class OverlapKeeper\n * @constructor\n */\nfunction OverlapKeeper() {\n    this.overlappingShapesLastState = new TupleDictionary();\n    this.overlappingShapesCurrentState = new TupleDictionary();\n    this.recordPool = new OverlapKeeperRecordPool({ size: 16 });\n    this.tmpDict = new TupleDictionary();\n    this.tmpArray1 = [];\n}\n\n/**\n * Ticks one step forward in time. This will move the current overlap state to the \"old\" overlap state, and create a new one as current.\n * @method tick\n */\nOverlapKeeper.prototype.tick = function() {\n    var last = this.overlappingShapesLastState;\n    var current = this.overlappingShapesCurrentState;\n\n    // Save old objects into pool\n    var l = last.keys.length;\n    while(l--){\n        var key = last.keys[l];\n        var lastObject = last.getByKey(key);\n        var currentObject = current.getByKey(key);\n        if(lastObject){\n            // The record is only used in the \"last\" dict, and will be removed. We might as well pool it.\n            this.recordPool.release(lastObject);\n        }\n    }\n\n    // Clear last object\n    last.reset();\n\n    // Transfer from new object to old\n    last.copy(current);\n\n    // Clear current object\n    current.reset();\n};\n\n/**\n * @method setOverlapping\n * @param {Body} bodyA\n * @param {Body} shapeA\n * @param {Body} bodyB\n * @param {Body} shapeB\n */\nOverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {\n    var last = this.overlappingShapesLastState;\n    var current = this.overlappingShapesCurrentState;\n\n    // Store current contact state\n    if(!current.get(shapeA.id, shapeB.id)){\n        var data = this.recordPool.get();\n        data.set(bodyA, shapeA, bodyB, shapeB);\n        current.set(shapeA.id, shapeB.id, data);\n    }\n};\n\nOverlapKeeper.prototype.getNewOverlaps = function(result){\n    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);\n};\n\nOverlapKeeper.prototype.getEndOverlaps = function(result){\n    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);\n};\n\n/**\n * Checks if two bodies are currently overlapping.\n * @method bodiesAreOverlapping\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {boolean}\n */\nOverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB){\n    var current = this.overlappingShapesCurrentState;\n    var l = current.keys.length;\n    while(l--){\n        var key = current.keys[l];\n        var data = current.data[key];\n        if((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA){\n            return true;\n        }\n    }\n    return false;\n};\n\nOverlapKeeper.prototype.getDiff = function(dictA, dictB, result){\n    var result = result || [];\n    var last = dictA;\n    var current = dictB;\n\n    result.length = 0;\n\n    var l = current.keys.length;\n    while(l--){\n        var key = current.keys[l];\n        var data = current.data[key];\n\n        if(!data){\n            throw new Error('Key '+key+' had no data!');\n        }\n\n        var lastData = last.data[key];\n        if(!lastData){\n            // Not overlapping in last state, but in current.\n            result.push(data);\n        }\n    }\n\n    return result;\n};\n\nOverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB){\n    var idA = shapeA.id|0,\n        idB = shapeB.id|0;\n    var last = this.overlappingShapesLastState;\n    var current = this.overlappingShapesCurrentState;\n    // Not in last but in new\n    return !!!last.get(idA, idB) && !!current.get(idA, idB);\n};\n\nOverlapKeeper.prototype.getNewBodyOverlaps = function(result){\n    this.tmpArray1.length = 0;\n    var overlaps = this.getNewOverlaps(this.tmpArray1);\n    return this.getBodyDiff(overlaps, result);\n};\n\nOverlapKeeper.prototype.getEndBodyOverlaps = function(result){\n    this.tmpArray1.length = 0;\n    var overlaps = this.getEndOverlaps(this.tmpArray1);\n    return this.getBodyDiff(overlaps, result);\n};\n\nOverlapKeeper.prototype.getBodyDiff = function(overlaps, result){\n    result = result || [];\n    var accumulator = this.tmpDict;\n\n    var l = overlaps.length;\n\n    while(l--){\n        var data = overlaps[l];\n\n        // Since we use body id's for the accumulator, these will be a subset of the original one\n        accumulator.set(data.bodyA.id|0, data.bodyB.id|0, data);\n    }\n\n    l = accumulator.keys.length;\n    while(l--){\n        var data = accumulator.getByKey(accumulator.keys[l]);\n        if(data){\n            result.push(data.bodyA, data.bodyB);\n        }\n    }\n\n    accumulator.reset();\n\n    return result;\n};\n","module.exports = OverlapKeeperRecord;\n\n/**\n * Overlap data container for the OverlapKeeper\n * @class OverlapKeeperRecord\n * @constructor\n * @param {Body} bodyA\n * @param {Shape} shapeA\n * @param {Body} bodyB\n * @param {Shape} shapeB\n */\nfunction OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB){\n    /**\n     * @property {Shape} shapeA\n     */\n    this.shapeA = shapeA;\n    /**\n     * @property {Shape} shapeB\n     */\n    this.shapeB = shapeB;\n    /**\n     * @property {Body} bodyA\n     */\n    this.bodyA = bodyA;\n    /**\n     * @property {Body} bodyB\n     */\n    this.bodyB = bodyB;\n}\n\n/**\n * Set the data for the record\n * @method set\n * @param {Body} bodyA\n * @param {Shape} shapeA\n * @param {Body} bodyB\n * @param {Shape} shapeB\n */\nOverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB){\n    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);\n};\n","var OverlapKeeperRecord = require('./OverlapKeeperRecord');\nvar Pool = require('./Pool');\n\nmodule.exports = OverlapKeeperRecordPool;\n\n/**\n * @class\n */\nfunction OverlapKeeperRecordPool() {\n\tPool.apply(this, arguments);\n}\nOverlapKeeperRecordPool.prototype = new Pool();\nOverlapKeeperRecordPool.prototype.constructor = OverlapKeeperRecordPool;\n\n/**\n * @method create\n * @return {OverlapKeeperRecord}\n */\nOverlapKeeperRecordPool.prototype.create = function () {\n\treturn new OverlapKeeperRecord();\n};\n\n/**\n * @method destroy\n * @param {OverlapKeeperRecord} record\n * @return {OverlapKeeperRecordPool}\n */\nOverlapKeeperRecordPool.prototype.destroy = function (record) {\n\trecord.bodyA = record.bodyB = record.shapeA = record.shapeB = null;\n\treturn this;\n};\n","module.exports = Pool;\n\n/**\n * @class Object pooling utility.\n */\nfunction Pool(options) {\n\toptions = options || {};\n\n\t/**\n\t * @property {Array} objects\n\t * @type {Array}\n\t */\n\tthis.objects = [];\n\n\tif(options.size !== undefined){\n\t\tthis.resize(options.size);\n\t}\n}\n\n/**\n * @method resize\n * @param {number} size\n * @return {Pool} Self, for chaining\n */\nPool.prototype.resize = function (size) {\n\tvar objects = this.objects;\n\n\twhile (objects.length > size) {\n\t\tobjects.pop();\n\t}\n\n\twhile (objects.length < size) {\n\t\tobjects.push(this.create());\n\t}\n\n\treturn this;\n};\n\n/**\n * Get an object from the pool or create a new instance.\n * @method get\n * @return {Object}\n */\nPool.prototype.get = function () {\n\tvar objects = this.objects;\n\treturn objects.length ? objects.pop() : this.create();\n};\n\n/**\n * Clean up and put the object back into the pool for later use.\n * @method release\n * @param {Object} object\n * @return {Pool} Self for chaining\n */\nPool.prototype.release = function (object) {\n\tthis.destroy(object);\n\tthis.objects.push(object);\n\treturn this;\n};\n","var Utils = require('./Utils');\n\nmodule.exports = TupleDictionary;\n\n/**\n * @class TupleDictionary\n * @constructor\n */\nfunction TupleDictionary() {\n\n    /**\n     * The data storage\n     * @property data\n     * @type {Object}\n     */\n    this.data = {};\n\n    /**\n     * Keys that are currently used.\n     * @property {Array} keys\n     */\n    this.keys = [];\n}\n\n/**\n * Generate a key given two integers\n * @method getKey\n * @param  {number} i\n * @param  {number} j\n * @return {string}\n */\nTupleDictionary.prototype.getKey = function(id1, id2) {\n    id1 = id1|0;\n    id2 = id2|0;\n\n    if ( (id1|0) === (id2|0) ){\n        return -1;\n    }\n\n    // valid for values < 2^16\n    return ((id1|0) > (id2|0) ?\n        (id1 << 16) | (id2 & 0xFFFF) :\n        (id2 << 16) | (id1 & 0xFFFF))|0\n        ;\n};\n\n/**\n * @method getByKey\n * @param  {Number} key\n * @return {Object}\n */\nTupleDictionary.prototype.getByKey = function(key) {\n    key = key|0;\n    return this.data[key];\n};\n\n/**\n * @method get\n * @param  {Number} i\n * @param  {Number} j\n * @return {Number}\n */\nTupleDictionary.prototype.get = function(i, j) {\n    return this.data[this.getKey(i, j)];\n};\n\n/**\n * Set a value.\n * @method set\n * @param  {Number} i\n * @param  {Number} j\n * @param {Number} value\n */\nTupleDictionary.prototype.set = function(i, j, value) {\n    if(!value){\n        throw new Error(\"No data!\");\n    }\n\n    var key = this.getKey(i, j);\n\n    // Check if key already exists\n    if(!this.data[key]){\n        this.keys.push(key);\n    }\n\n    this.data[key] = value;\n\n    return key;\n};\n\n/**\n * Remove all data.\n * @method reset\n */\nTupleDictionary.prototype.reset = function() {\n    var data = this.data,\n        keys = this.keys;\n\n    var l = keys.length;\n    while(l--) {\n        delete data[keys[l]];\n    }\n\n    keys.length = 0;\n};\n\n/**\n * Copy another TupleDictionary. Note that all data in this dictionary will be removed.\n * @method copy\n * @param {TupleDictionary} dict The TupleDictionary to copy into this one.\n */\nTupleDictionary.prototype.copy = function(dict) {\n    this.reset();\n    Utils.appendArray(this.keys, dict.keys);\n    var l = dict.keys.length;\n    while(l--){\n        var key = dict.keys[l];\n        this.data[key] = dict.data[key];\n    }\n};\n","/* global P2_ARRAY_TYPE */\n\nmodule.exports = Utils;\n\n/**\n * Misc utility functions\n * @class Utils\n * @constructor\n */\nfunction Utils(){}\n\n/**\n * Append the values in array b to the array a. See <a href=\"http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131\">this</a> for an explanation.\n * @method appendArray\n * @static\n * @param  {Array} a\n * @param  {Array} b\n */\nUtils.appendArray = function(a,b){\n    if (b.length < 150000) {\n        a.push.apply(a, b);\n    } else {\n        for (var i = 0, len = b.length; i !== len; ++i) {\n            a.push(b[i]);\n        }\n    }\n};\n\n/**\n * Garbage free Array.splice(). Does not allocate a new array.\n * @method splice\n * @static\n * @param  {Array} array\n * @param  {Number} index\n * @param  {Number} howmany\n */\nUtils.splice = function(array,index,howmany){\n    howmany = howmany || 1;\n    for (var i=index, len=array.length-howmany; i < len; i++){\n        array[i] = array[i + howmany];\n    }\n    array.length = len;\n};\n\n/**\n * The array type to use for internal numeric computations throughout the library. Float32Array is used if it is available, but falls back on Array. If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE. See example below.\n * @static\n * @property {function} ARRAY_TYPE\n * @example\n *     <script>\n *         <!-- Inject your preferred array type before loading p2.js -->\n *         P2_ARRAY_TYPE = Array;\n *     </script>\n *     <script src=\"p2.js\"></script>\n */\nif(typeof P2_ARRAY_TYPE !== 'undefined') {\n    Utils.ARRAY_TYPE = P2_ARRAY_TYPE;\n} else if (typeof Float32Array !== 'undefined'){\n    Utils.ARRAY_TYPE = Float32Array;\n} else {\n    Utils.ARRAY_TYPE = Array;\n}\n\n/**\n * Extend an object with the properties of another\n * @static\n * @method extend\n * @param  {object} a\n * @param  {object} b\n */\nUtils.extend = function(a,b){\n    for(var key in b){\n        a[key] = b[key];\n    }\n};\n\n/**\n * Extend an options object with default values.\n * @static\n * @method defaults\n * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.\n * @param  {object} defaults An object containing default values.\n * @return {object} The modified options object.\n */\nUtils.defaults = function(options, defaults){\n    options = options || {};\n    for(var key in defaults){\n        if(!(key in options)){\n            options[key] = defaults[key];\n        }\n    }\n    return options;\n};\n","var Body = require('../objects/Body');\n\nmodule.exports = Island;\n\n/**\n * An island of bodies connected with equations.\n * @class Island\n * @constructor\n */\nfunction Island(){\n\n    /**\n     * Current equations in this island.\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * Current bodies in this island.\n     * @property bodies\n     * @type {Array}\n     */\n    this.bodies = [];\n}\n\n/**\n * Clean this island from bodies and equations.\n * @method reset\n */\nIsland.prototype.reset = function(){\n    this.equations.length = this.bodies.length = 0;\n};\n\nvar bodyIds = [];\n\n/**\n * Get all unique bodies in this island.\n * @method getBodies\n * @return {Array} An array of Body\n */\nIsland.prototype.getBodies = function(result){\n    var bodies = result || [],\n        eqs = this.equations;\n    bodyIds.length = 0;\n    for(var i=0; i!==eqs.length; i++){\n        var eq = eqs[i];\n        if(bodyIds.indexOf(eq.bodyA.id)===-1){\n            bodies.push(eq.bodyA);\n            bodyIds.push(eq.bodyA.id);\n        }\n        if(bodyIds.indexOf(eq.bodyB.id)===-1){\n            bodies.push(eq.bodyB);\n            bodyIds.push(eq.bodyB.id);\n        }\n    }\n    return bodies;\n};\n\n/**\n * Check if the entire island wants to sleep.\n * @method wantsToSleep\n * @return {Boolean}\n */\nIsland.prototype.wantsToSleep = function(){\n    for(var i=0; i<this.bodies.length; i++){\n        var b = this.bodies[i];\n        if(b.type === Body.DYNAMIC && !b.wantsToSleep){\n            return false;\n        }\n    }\n    return true;\n};\n\n/**\n * Make all bodies in the island sleep.\n * @method sleep\n */\nIsland.prototype.sleep = function(){\n    for(var i=0; i<this.bodies.length; i++){\n        var b = this.bodies[i];\n        b.sleep();\n    }\n    return true;\n};\n","var vec2 = require('../math/vec2')\n,   Island = require('./Island')\n,   IslandNode = require('./IslandNode')\n,   IslandNodePool = require('./../utils/IslandNodePool')\n,   IslandPool = require('./../utils/IslandPool')\n,   Body = require('../objects/Body');\n\nmodule.exports = IslandManager;\n\n/**\n * Splits the system of bodies and equations into independent islands\n *\n * @class IslandManager\n * @constructor\n * @param {Object} [options]\n * @extends Solver\n */\nfunction IslandManager(options){\n\n    /**\n     * @property nodePool\n     * @type {IslandNodePool}\n     */\n    this.nodePool = new IslandNodePool({ size: 16 });\n\n    /**\n     * @property islandPool\n     * @type {IslandPool}\n     */\n    this.islandPool = new IslandPool({ size: 8 });\n\n    /**\n     * The equations to split. Manually fill this array before running .split().\n     * @property {Array} equations\n     */\n    this.equations = [];\n\n    /**\n     * The resulting {{#crossLink \"Island\"}}{{/crossLink}}s.\n     * @property {Array} islands\n     */\n    this.islands = [];\n\n    /**\n     * The resulting graph nodes.\n     * @property {Array} nodes\n     */\n    this.nodes = [];\n\n    /**\n     * The node queue, used when traversing the graph of nodes.\n     * @private\n     * @property {Array} queue\n     */\n    this.queue = [];\n}\n\n/**\n * Get an unvisited node from a list of nodes.\n * @static\n * @method getUnvisitedNode\n * @param  {Array} nodes\n * @return {IslandNode|boolean} The node if found, else false.\n */\nIslandManager.getUnvisitedNode = function(nodes){\n    var Nnodes = nodes.length;\n    for(var i=0; i!==Nnodes; i++){\n        var node = nodes[i];\n        if(!node.visited && node.body.type === Body.DYNAMIC){\n            return node;\n        }\n    }\n    return false;\n};\n\n/**\n * Visit a node.\n * @method visit\n * @param  {IslandNode} node\n * @param  {Array} bds\n * @param  {Array} eqs\n */\nIslandManager.prototype.visit = function (node,bds,eqs){\n    bds.push(node.body);\n    var Neqs = node.equations.length;\n    for(var i=0; i!==Neqs; i++){\n        var eq = node.equations[i];\n        if(eqs.indexOf(eq) === -1){ // Already added?\n            eqs.push(eq);\n        }\n    }\n};\n\n/**\n * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.\n * @method bfs\n * @param  {IslandNode} root The node to start from\n * @param  {Array} bds  An array to append resulting Bodies to.\n * @param  {Array} eqs  An array to append resulting Equations to.\n */\nIslandManager.prototype.bfs = function(root,bds,eqs){\n\n    // Reset the visit queue\n    var queue = this.queue;\n    queue.length = 0;\n\n    // Add root node to queue\n    queue.push(root);\n    root.visited = true;\n    this.visit(root,bds,eqs);\n\n    // Process all queued nodes\n    while(queue.length) {\n\n        // Get next node in the queue\n        var node = queue.pop();\n\n        // Visit unvisited neighboring nodes\n        var child;\n        while((child = IslandManager.getUnvisitedNode(node.neighbors))) {\n            child.visited = true;\n            this.visit(child,bds,eqs);\n\n            // Only visit the children of this node if it's dynamic\n            if(child.body.type === Body.DYNAMIC){\n                queue.push(child);\n            }\n        }\n    }\n};\n\n/**\n * Split the world into independent islands. The result is stored in .islands.\n * @method split\n * @param  {World} world\n * @return {Array} The generated islands\n */\nIslandManager.prototype.split = function(world){\n    var bodies = world.bodies,\n        nodes = this.nodes,\n        equations = this.equations;\n\n    // Move old nodes to the node pool\n    while(nodes.length){\n        this.nodePool.release(nodes.pop());\n    }\n\n    // Create needed nodes, reuse if possible\n    for(var i=0; i!==bodies.length; i++){\n        var node = this.nodePool.get();\n        node.body = bodies[i];\n        nodes.push(node);\n        // if(this.nodePool.length){\n        //     var node = this.nodePool.pop();\n        //     node.reset();\n        //     node.body = bodies[i];\n        //     nodes.push(node);\n        // } else {\n        //     nodes.push(new IslandNode(bodies[i]));\n        // }\n    }\n\n    // Add connectivity data. Each equation connects 2 bodies.\n    for(var k=0; k!==equations.length; k++){\n        var eq=equations[k],\n            i=bodies.indexOf(eq.bodyA),\n            j=bodies.indexOf(eq.bodyB),\n            ni=nodes[i],\n            nj=nodes[j];\n        ni.neighbors.push(nj);\n        nj.neighbors.push(ni);\n        ni.equations.push(eq);\n        nj.equations.push(eq);\n    }\n\n    // Move old islands to the island pool\n    var islands = this.islands;\n    for(var i=0; i<islands.length; i++){\n        this.islandPool.release(islands[i]);\n    }\n    islands.length = 0;\n\n    // Get islands\n    var child;\n    while((child = IslandManager.getUnvisitedNode(nodes))){\n\n        // Create new island\n        var island = this.islandPool.get();\n\n        // Get all equations and bodies in this island\n        this.bfs(child, island.bodies, island.equations);\n\n        islands.push(island);\n    }\n\n    return islands;\n};\n","module.exports = IslandNode;\n\n/**\n * Holds a body and keeps track of some additional properties needed for graph traversal.\n * @class IslandNode\n * @constructor\n * @param {Body} body\n */\nfunction IslandNode(body){\n\n\t/**\n\t * The body that is contained in this node.\n\t * @property {Body} body\n\t */\n    this.body = body;\n\n    /**\n     * Neighboring IslandNodes\n     * @property {Array} neighbors\n     */\n    this.neighbors = [];\n\n    /**\n     * Equations connected to this node.\n     * @property {Array} equations\n     */\n    this.equations = [];\n\n    /**\n     * If this node was visiting during the graph traversal.\n     * @property visited\n     * @type {Boolean}\n     */\n    this.visited = false;\n}\n\n/**\n * Clean this node from bodies and equations.\n * @method reset\n */\nIslandNode.prototype.reset = function(){\n    this.equations.length = 0;\n    this.neighbors.length = 0;\n    this.visited = false;\n    this.body = null;\n};\n","var  GSSolver = require('../solver/GSSolver')\n,    Solver = require('../solver/Solver')\n,    Ray = require('../collision/Ray')\n,    vec2 = require('../math/vec2')\n,    Circle = require('../shapes/Circle')\n,    Convex = require('../shapes/Convex')\n,    Line = require('../shapes/Line')\n,    Plane = require('../shapes/Plane')\n,    Capsule = require('../shapes/Capsule')\n,    Particle = require('../shapes/Particle')\n,    EventEmitter = require('../events/EventEmitter')\n,    Body = require('../objects/Body')\n,    Shape = require('../shapes/Shape')\n,    LinearSpring = require('../objects/LinearSpring')\n,    Material = require('../material/Material')\n,    ContactMaterial = require('../material/ContactMaterial')\n,    DistanceConstraint = require('../constraints/DistanceConstraint')\n,    Constraint = require('../constraints/Constraint')\n,    LockConstraint = require('../constraints/LockConstraint')\n,    RevoluteConstraint = require('../constraints/RevoluteConstraint')\n,    PrismaticConstraint = require('../constraints/PrismaticConstraint')\n,    GearConstraint = require('../constraints/GearConstraint')\n,    pkg = require('../../package.json')\n,    Broadphase = require('../collision/Broadphase')\n,    AABB = require('../collision/AABB')\n,    SAPBroadphase = require('../collision/SAPBroadphase')\n,    Narrowphase = require('../collision/Narrowphase')\n,    Utils = require('../utils/Utils')\n,    OverlapKeeper = require('../utils/OverlapKeeper')\n,    IslandManager = require('./IslandManager')\n,    RotationalSpring = require('../objects/RotationalSpring');\n\nmodule.exports = World;\n\n/**\n * The dynamics world, where all bodies and constraints live.\n *\n * @class World\n * @constructor\n * @param {Object} [options]\n * @param {Solver} [options.solver] Defaults to GSSolver.\n * @param {Array} [options.gravity] Defaults to y=-9.78.\n * @param {Broadphase} [options.broadphase] Defaults to SAPBroadphase\n * @param {Boolean} [options.islandSplit=true]\n * @extends EventEmitter\n *\n * @example\n *     var world = new World({\n *         gravity: [0, -10],\n *         broadphase: new SAPBroadphase()\n *     });\n *     world.addBody(new Body());\n */\nfunction World(options){\n    EventEmitter.apply(this);\n\n    options = options || {};\n\n    /**\n     * All springs in the world. To add a spring to the world, use {{#crossLink \"World/addSpring:method\"}}{{/crossLink}}.\n     *\n     * @property springs\n     * @type {Array}\n     */\n    this.springs = [];\n\n    /**\n     * All bodies in the world. To add a body to the world, use {{#crossLink \"World/addBody:method\"}}{{/crossLink}}.\n     * @property {Array} bodies\n     */\n    this.bodies = [];\n\n    /**\n     * Disabled body collision pairs. See {{#crossLink \"World/disableBodyCollision:method\"}}.\n     * @private\n     * @property {Array} disabledBodyCollisionPairs\n     */\n    this.disabledBodyCollisionPairs = [];\n\n    /**\n     * The solver used to satisfy constraints and contacts. Default is {{#crossLink \"GSSolver\"}}{{/crossLink}}.\n     * @property {Solver} solver\n     */\n    this.solver = options.solver || new GSSolver();\n\n    /**\n     * The narrowphase to use to generate contacts.\n     *\n     * @property narrowphase\n     * @type {Narrowphase}\n     */\n    this.narrowphase = new Narrowphase(this);\n\n    /**\n     * The island manager of this world.\n     * @property {IslandManager} islandManager\n     */\n    this.islandManager = new IslandManager();\n\n    /**\n     * Gravity in the world. This is applied on all bodies in the beginning of each step().\n     *\n     * @property gravity\n     * @type {Array}\n     */\n    this.gravity = vec2.fromValues(0, -9.78);\n    if(options.gravity){\n        vec2.copy(this.gravity, options.gravity);\n    }\n\n    /**\n     * Gravity to use when approximating the friction max force (mu*mass*gravity).\n     * @property {Number} frictionGravity\n     */\n    this.frictionGravity = vec2.length(this.gravity) || 10;\n\n    /**\n     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.\n     * @property {Boolean} useWorldGravityAsFrictionGravity\n     * @default true\n     */\n    this.useWorldGravityAsFrictionGravity = true;\n\n    /**\n     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.\n     * @property {Boolean} useFrictionGravityOnZeroGravity\n     * @default true\n     */\n    this.useFrictionGravityOnZeroGravity = true;\n\n    /**\n     * The broadphase algorithm to use.\n     *\n     * @property broadphase\n     * @type {Broadphase}\n     */\n    this.broadphase = options.broadphase || new SAPBroadphase();\n    this.broadphase.setWorld(this);\n\n    /**\n     * User-added constraints.\n     *\n     * @property constraints\n     * @type {Array}\n     */\n    this.constraints = [];\n\n    /**\n     * Dummy default material in the world, used in .defaultContactMaterial\n     * @property {Material} defaultMaterial\n     */\n    this.defaultMaterial = new Material();\n\n    /**\n     * The default contact material to use, if no contact material was set for the colliding materials.\n     * @property {ContactMaterial} defaultContactMaterial\n     */\n    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial);\n\n    /**\n     * For keeping track of what time step size we used last step\n     * @property lastTimeStep\n     * @type {Number}\n     */\n    this.lastTimeStep = 1/60;\n\n    /**\n     * Enable to automatically apply spring forces each step.\n     * @property applySpringForces\n     * @type {Boolean}\n     * @default true\n     */\n    this.applySpringForces = true;\n\n    /**\n     * Enable to automatically apply body damping each step.\n     * @property applyDamping\n     * @type {Boolean}\n     * @default true\n     */\n    this.applyDamping = true;\n\n    /**\n     * Enable to automatically apply gravity each step.\n     * @property applyGravity\n     * @type {Boolean}\n     * @default true\n     */\n    this.applyGravity = true;\n\n    /**\n     * Enable/disable constraint solving in each step.\n     * @property solveConstraints\n     * @type {Boolean}\n     * @default true\n     */\n    this.solveConstraints = true;\n\n    /**\n     * The ContactMaterials added to the World.\n     * @property contactMaterials\n     * @type {Array}\n     */\n    this.contactMaterials = [];\n\n    /**\n     * World time.\n     * @property time\n     * @type {Number}\n     */\n    this.time = 0.0;\n    this.accumulator = 0;\n\n    /**\n     * Is true during step().\n     * @property {Boolean} stepping\n     */\n    this.stepping = false;\n\n    /**\n     * Bodies that are scheduled to be removed at the end of the step.\n     * @property {Array} bodiesToBeRemoved\n     * @private\n     */\n    this.bodiesToBeRemoved = [];\n\n    /**\n     * Whether to enable island splitting. Island splitting can be an advantage for both precision and performance. See {{#crossLink \"IslandManager\"}}{{/crossLink}}.\n     * @property {Boolean} islandSplit\n     * @default true\n     */\n    this.islandSplit = typeof(options.islandSplit)!==\"undefined\" ? !!options.islandSplit : true;\n\n    /**\n     * Set to true if you want to the world to emit the \"impact\" event. Turning this off could improve performance.\n     * @property emitImpactEvent\n     * @type {Boolean}\n     * @default true\n     */\n    this.emitImpactEvent = true;\n\n    // Id counters\n    this._constraintIdCounter = 0;\n    this._bodyIdCounter = 0;\n\n    /**\n     * Fired after the step().\n     * @event postStep\n     */\n    this.postStepEvent = {\n        type : \"postStep\"\n    };\n\n    /**\n     * Fired when a body is added to the world.\n     * @event addBody\n     * @param {Body} body\n     */\n    this.addBodyEvent = {\n        type : \"addBody\",\n        body : null\n    };\n\n    /**\n     * Fired when a body is removed from the world.\n     * @event removeBody\n     * @param {Body} body\n     */\n    this.removeBodyEvent = {\n        type : \"removeBody\",\n        body : null\n    };\n\n    /**\n     * Fired when a spring is added to the world.\n     * @event addSpring\n     * @param {Spring} spring\n     */\n    this.addSpringEvent = {\n        type : \"addSpring\",\n        spring : null\n    };\n\n    /**\n     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.\n     * @event impact\n     * @param {Body} bodyA\n     * @param {Body} bodyB\n     */\n    this.impactEvent = {\n        type: \"impact\",\n        bodyA : null,\n        bodyB : null,\n        shapeA : null,\n        shapeB : null,\n        contactEquation : null\n    };\n\n    /**\n     * Fired after the Broadphase has collected collision pairs in the world.\n     * Inside the event handler, you can modify the pairs array as you like, to\n     * prevent collisions between objects that you don't want.\n     * @event postBroadphase\n     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.\n     */\n    this.postBroadphaseEvent = {\n        type: \"postBroadphase\",\n        pairs: null\n    };\n\n    /**\n     * How to deactivate bodies during simulation. Possible modes are: {{#crossLink \"World/NO_SLEEPING:property\"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink \"World/BODY_SLEEPING:property\"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink \"World/ISLAND_SLEEPING:property\"}}World.ISLAND_SLEEPING{{/crossLink}}.\n     * If sleeping is enabled, you might need to {{#crossLink \"Body/wakeUp:method\"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink \"Body/allowSleep:property\"}}Body.allowSleep{{/crossLink}}.\n     * @property sleepMode\n     * @type {number}\n     * @default World.NO_SLEEPING\n     */\n    this.sleepMode = World.NO_SLEEPING;\n\n    /**\n     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.\n     * @event beginContact\n     * @param {Shape} shapeA\n     * @param {Shape} shapeB\n     * @param {Body}  bodyA\n     * @param {Body}  bodyB\n     * @param {Array} contactEquations\n     */\n    this.beginContactEvent = {\n        type: \"beginContact\",\n        shapeA: null,\n        shapeB: null,\n        bodyA: null,\n        bodyB: null,\n        contactEquations: []\n    };\n\n    /**\n     * Fired when two shapes stop overlapping, after the narrowphase (during step).\n     * @event endContact\n     * @param {Shape} shapeA\n     * @param {Shape} shapeB\n     * @param {Body}  bodyA\n     * @param {Body}  bodyB\n     */\n    this.endContactEvent = {\n        type: \"endContact\",\n        shapeA: null,\n        shapeB: null,\n        bodyA: null,\n        bodyB: null\n    };\n\n    /**\n     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.\n     * @event preSolve\n     * @param {Array} contactEquations  An array of contacts to be solved.\n     * @param {Array} frictionEquations An array of friction equations to be solved.\n     */\n    this.preSolveEvent = {\n        type: \"preSolve\",\n        contactEquations: null,\n        frictionEquations: null\n    };\n\n    // For keeping track of overlapping shapes\n    this.overlappingShapesLastState = { keys:[] };\n    this.overlappingShapesCurrentState = { keys:[] };\n\n    /**\n     * @property {OverlapKeeper} overlapKeeper\n     */\n    this.overlapKeeper = new OverlapKeeper();\n}\nWorld.prototype = new Object(EventEmitter.prototype);\nWorld.prototype.constructor = World;\n\n/**\n * Never deactivate bodies.\n * @static\n * @property {number} NO_SLEEPING\n */\nWorld.NO_SLEEPING = 1;\n\n/**\n * Deactivate individual bodies if they are sleepy.\n * @static\n * @property {number} BODY_SLEEPING\n */\nWorld.BODY_SLEEPING = 2;\n\n/**\n * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink \"World/islandSplit:property\"}}.islandSplit{{/crossLink}} for this to work.\n * @static\n * @property {number} ISLAND_SLEEPING\n */\nWorld.ISLAND_SLEEPING = 4;\n\n/**\n * Add a constraint to the simulation.\n *\n * @method addConstraint\n * @param {Constraint} constraint\n * @example\n *     var constraint = new LockConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n */\nWorld.prototype.addConstraint = function(constraint){\n    this.constraints.push(constraint);\n};\n\n/**\n * Add a ContactMaterial to the simulation.\n * @method addContactMaterial\n * @param {ContactMaterial} contactMaterial\n */\nWorld.prototype.addContactMaterial = function(contactMaterial){\n    this.contactMaterials.push(contactMaterial);\n};\n\n/**\n * Removes a contact material\n *\n * @method removeContactMaterial\n * @param {ContactMaterial} cm\n */\nWorld.prototype.removeContactMaterial = function(cm){\n    var idx = this.contactMaterials.indexOf(cm);\n    if(idx!==-1){\n        Utils.splice(this.contactMaterials,idx,1);\n    }\n};\n\n/**\n * Get a contact material given two materials\n * @method getContactMaterial\n * @param {Material} materialA\n * @param {Material} materialB\n * @return {ContactMaterial} The matching ContactMaterial, or false on fail.\n * @todo Use faster hash map to lookup from material id's\n */\nWorld.prototype.getContactMaterial = function(materialA,materialB){\n    var cmats = this.contactMaterials;\n    for(var i=0, N=cmats.length; i!==N; i++){\n        var cm = cmats[i];\n        if( (cm.materialA.id === materialA.id) && (cm.materialB.id === materialB.id) ||\n            (cm.materialA.id === materialB.id) && (cm.materialB.id === materialA.id) ){\n            return cm;\n        }\n    }\n    return false;\n};\n\n/**\n * Removes a constraint\n *\n * @method removeConstraint\n * @param {Constraint} constraint\n */\nWorld.prototype.removeConstraint = function(constraint){\n    var idx = this.constraints.indexOf(constraint);\n    if(idx!==-1){\n        Utils.splice(this.constraints,idx,1);\n    }\n};\n\nvar step_r = vec2.create(),\n    step_runit = vec2.create(),\n    step_u = vec2.create(),\n    step_f = vec2.create(),\n    step_fhMinv = vec2.create(),\n    step_velodt = vec2.create(),\n    step_mg = vec2.create(),\n    xiw = vec2.fromValues(0,0),\n    xjw = vec2.fromValues(0,0),\n    zero = vec2.fromValues(0,0),\n    interpvelo = vec2.fromValues(0,0);\n\n/**\n * Step the physics world forward in time.\n *\n * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.\n *\n * @method step\n * @param {Number} dt                       The fixed time step size to use.\n * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.\n * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.\n *\n * @example\n *     // Simple fixed timestepping without interpolation\n *     var fixedTimeStep = 1 / 60;\n *     var world = new World();\n *     var body = new Body({ mass: 1 });\n *     world.addBody(body);\n *\n *     function animate(){\n *         requestAnimationFrame(animate);\n *         world.step(fixedTimeStep);\n *         renderBody(body.position, body.angle);\n *     }\n *\n *     // Start animation loop\n *     requestAnimationFrame(animate);\n *\n * @example\n *     // Fixed timestepping with interpolation\n *     var maxSubSteps = 10;\n *     var lastTimeSeconds;\n *\n *     function animate(t){\n *         requestAnimationFrame(animate);\n *         timeSeconds = t / 1000;\n *         lastTimeSeconds = lastTimeSeconds || timeSeconds;\n *\n *         deltaTime = timeSeconds - lastTimeSeconds;\n *         world.step(fixedTimeStep, deltaTime, maxSubSteps);\n *\n *         renderBody(body.interpolatedPosition, body.interpolatedAngle);\n *     }\n *\n *     // Start animation loop\n *     requestAnimationFrame(animate);\n *\n * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n */\nWorld.prototype.step = function(dt,timeSinceLastCalled,maxSubSteps){\n    maxSubSteps = maxSubSteps || 10;\n    timeSinceLastCalled = timeSinceLastCalled || 0;\n\n    if(timeSinceLastCalled === 0){ // Fixed, simple stepping\n\n        this.internalStep(dt);\n\n        // Increment time\n        this.time += dt;\n\n    } else {\n\n        this.accumulator += timeSinceLastCalled;\n        var substeps = 0;\n        while (this.accumulator >= dt && substeps < maxSubSteps) {\n            // Do fixed steps to catch up\n            this.internalStep(dt);\n            this.time += dt;\n            this.accumulator -= dt;\n            substeps++;\n        }\n\n        var t = (this.accumulator % dt) / dt;\n        for(var j=0; j!==this.bodies.length; j++){\n            var b = this.bodies[j];\n            vec2.lerp(b.interpolatedPosition, b.previousPosition, b.position, t);\n            b.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);\n        }\n    }\n};\n\nvar endOverlaps = [];\n\n/**\n * Make a fixed step.\n * @method internalStep\n * @param  {number} dt\n * @private\n */\nWorld.prototype.internalStep = function(dt){\n    this.stepping = true;\n\n    var that = this,\n        Nsprings = this.springs.length,\n        springs = this.springs,\n        bodies = this.bodies,\n        g = this.gravity,\n        solver = this.solver,\n        Nbodies = this.bodies.length,\n        broadphase = this.broadphase,\n        np = this.narrowphase,\n        constraints = this.constraints,\n        t0, t1,\n        fhMinv = step_fhMinv,\n        velodt = step_velodt,\n        mg = step_mg,\n        scale = vec2.scale,\n        add = vec2.add,\n        rotate = vec2.rotate,\n        islandManager = this.islandManager;\n\n    this.overlapKeeper.tick();\n\n    this.lastTimeStep = dt;\n\n    // Update approximate friction gravity.\n    if(this.useWorldGravityAsFrictionGravity){\n        var gravityLen = vec2.length(this.gravity);\n        if(!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)){\n            // Nonzero gravity. Use it.\n            this.frictionGravity = gravityLen;\n        }\n    }\n\n    // Add gravity to bodies\n    if(this.applyGravity){\n        for(var i=0; i!==Nbodies; i++){\n            var b = bodies[i],\n                fi = b.force;\n            if(b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){\n                continue;\n            }\n            vec2.scale(mg,g,b.mass*b.gravityScale); // F=m*g\n            add(fi,fi,mg);\n        }\n    }\n\n    // Add spring forces\n    if(this.applySpringForces){\n        for(var i=0; i!==Nsprings; i++){\n            var s = springs[i];\n            s.applyForce();\n        }\n    }\n\n    if(this.applyDamping){\n        for(var i=0; i!==Nbodies; i++){\n            var b = bodies[i];\n            if(b.type === Body.DYNAMIC){\n                b.applyDamping(dt);\n            }\n        }\n    }\n\n    // Broadphase\n    var result = broadphase.getCollisionPairs(this);\n\n    // Remove ignored collision pairs\n    var ignoredPairs = this.disabledBodyCollisionPairs;\n    for(var i=ignoredPairs.length-2; i>=0; i-=2){\n        for(var j=result.length-2; j>=0; j-=2){\n            if( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||\n                (ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){\n                result.splice(j,2);\n            }\n        }\n    }\n\n    // Remove constrained pairs with collideConnected == false\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        var c = constraints[i];\n        if(!c.collideConnected){\n            for(var j=result.length-2; j>=0; j-=2){\n                if( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||\n                    (c.bodyB === result[j] && c.bodyA === result[j+1])){\n                    result.splice(j,2);\n                }\n            }\n        }\n    }\n\n    // postBroadphase event\n    this.postBroadphaseEvent.pairs = result;\n    this.emit(this.postBroadphaseEvent);\n    this.postBroadphaseEvent.pairs = null;\n\n    // Narrowphase\n    np.reset(this);\n    for(var i=0, Nresults=result.length; i!==Nresults; i+=2){\n        var bi = result[i],\n            bj = result[i+1];\n\n        // Loop over all shapes of body i\n        for(var k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){\n            var si = bi.shapes[k],\n                xi = si.position,\n                ai = si.angle;\n\n            // All shapes of body j\n            for(var l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){\n                var sj = bj.shapes[l],\n                    xj = sj.position,\n                    aj = sj.angle;\n\n                var cm = this.defaultContactMaterial;\n                if(si.material && sj.material){\n                    var tmp = this.getContactMaterial(si.material,sj.material);\n                    if(tmp){\n                        cm = tmp;\n                    }\n                }\n\n                this.runNarrowphase(np,bi,si,xi,ai,bj,sj,xj,aj,cm,this.frictionGravity);\n            }\n        }\n    }\n\n    // Wake up bodies\n    for(var i=0; i!==Nbodies; i++){\n        var body = bodies[i];\n        if(body._wakeUpAfterNarrowphase){\n            body.wakeUp();\n            body._wakeUpAfterNarrowphase = false;\n        }\n    }\n\n    // Emit end overlap events\n    if(this.has('endContact')){\n        this.overlapKeeper.getEndOverlaps(endOverlaps);\n        var e = this.endContactEvent;\n        var l = endOverlaps.length;\n        while(l--){\n            var data = endOverlaps[l];\n            e.shapeA = data.shapeA;\n            e.shapeB = data.shapeB;\n            e.bodyA = data.bodyA;\n            e.bodyB = data.bodyB;\n            this.emit(e);\n        }\n        endOverlaps.length = 0;\n    }\n\n    var preSolveEvent = this.preSolveEvent;\n    preSolveEvent.contactEquations = np.contactEquations;\n    preSolveEvent.frictionEquations = np.frictionEquations;\n    this.emit(preSolveEvent);\n    preSolveEvent.contactEquations = preSolveEvent.frictionEquations = null;\n\n    // update constraint equations\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        constraints[i].update();\n    }\n\n    if(np.contactEquations.length || np.frictionEquations.length || Nconstraints){\n        if(this.islandSplit){\n            // Split into islands\n            islandManager.equations.length = 0;\n            Utils.appendArray(islandManager.equations, np.contactEquations);\n            Utils.appendArray(islandManager.equations, np.frictionEquations);\n            for(i=0; i!==Nconstraints; i++){\n                Utils.appendArray(islandManager.equations, constraints[i].equations);\n            }\n            islandManager.split(this);\n\n            for(var i=0; i!==islandManager.islands.length; i++){\n                var island = islandManager.islands[i];\n                if(island.equations.length){\n                    solver.solveIsland(dt,island);\n                }\n            }\n\n        } else {\n\n            // Add contact equations to solver\n            solver.addEquations(np.contactEquations);\n            solver.addEquations(np.frictionEquations);\n\n            // Add user-defined constraint equations\n            for(i=0; i!==Nconstraints; i++){\n                solver.addEquations(constraints[i].equations);\n            }\n\n            if(this.solveConstraints){\n                solver.solve(dt,this);\n            }\n\n            solver.removeAllEquations();\n        }\n    }\n\n    // Step forward\n    for(var i=0; i!==Nbodies; i++){\n        var body = bodies[i];\n\n        // if(body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC){\n        body.integrate(dt);\n        // }\n    }\n\n    // Reset force\n    for(var i=0; i!==Nbodies; i++){\n        bodies[i].setZeroForce();\n    }\n\n    // Emit impact event\n    if(this.emitImpactEvent && this.has('impact')){\n        var ev = this.impactEvent;\n        for(var i=0; i!==np.contactEquations.length; i++){\n            var eq = np.contactEquations[i];\n            if(eq.firstImpact){\n                ev.bodyA = eq.bodyA;\n                ev.bodyB = eq.bodyB;\n                ev.shapeA = eq.shapeA;\n                ev.shapeB = eq.shapeB;\n                ev.contactEquation = eq;\n                this.emit(ev);\n            }\n        }\n    }\n\n    // Sleeping update\n    if(this.sleepMode === World.BODY_SLEEPING){\n        for(i=0; i!==Nbodies; i++){\n            bodies[i].sleepTick(this.time, false, dt);\n        }\n    } else if(this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit){\n\n        // Tell all bodies to sleep tick but dont sleep yet\n        for(i=0; i!==Nbodies; i++){\n            bodies[i].sleepTick(this.time, true, dt);\n        }\n\n        // Sleep islands\n        for(var i=0; i<this.islandManager.islands.length; i++){\n            var island = this.islandManager.islands[i];\n            if(island.wantsToSleep()){\n                island.sleep();\n            }\n        }\n    }\n\n    this.stepping = false;\n\n    // Remove bodies that are scheduled for removal\n    var bodiesToBeRemoved = this.bodiesToBeRemoved;\n    for(var i=0; i!==bodiesToBeRemoved.length; i++){\n        this.removeBody(bodiesToBeRemoved[i]);\n    }\n    bodiesToBeRemoved.length = 0;\n\n    this.emit(this.postStepEvent);\n};\n\n/**\n * Runs narrowphase for the shape pair i and j.\n * @method runNarrowphase\n * @param  {Narrowphase} np\n * @param  {Body} bi\n * @param  {Shape} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Shape} sj\n * @param  {Array} xj\n * @param  {Number} aj\n * @param  {Number} mu\n */\nWorld.prototype.runNarrowphase = function(np,bi,si,xi,ai,bj,sj,xj,aj,cm,glen){\n\n    // Check collision groups and masks\n    if(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){\n        return;\n    }\n\n    // Get world position and angle of each shape\n    vec2.rotate(xiw, xi, bi.angle);\n    vec2.rotate(xjw, xj, bj.angle);\n    vec2.add(xiw, xiw, bi.position);\n    vec2.add(xjw, xjw, bj.position);\n    var aiw = ai + bi.angle;\n    var ajw = aj + bj.angle;\n\n    np.enableFriction = cm.friction > 0;\n    np.frictionCoefficient = cm.friction;\n    var reducedMass;\n    if(bi.type === Body.STATIC || bi.type === Body.KINEMATIC){\n        reducedMass = bj.mass;\n    } else if(bj.type === Body.STATIC || bj.type === Body.KINEMATIC){\n        reducedMass = bi.mass;\n    } else {\n        reducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);\n    }\n    np.slipForce = cm.friction*glen*reducedMass;\n    np.restitution = cm.restitution;\n    np.surfaceVelocity = cm.surfaceVelocity;\n    np.frictionStiffness = cm.frictionStiffness;\n    np.frictionRelaxation = cm.frictionRelaxation;\n    np.stiffness = cm.stiffness;\n    np.relaxation = cm.relaxation;\n    np.contactSkinSize = cm.contactSkinSize;\n    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n\n    var resolver = np[si.type | sj.type],\n        numContacts = 0;\n    if (resolver) {\n        var sensor = si.sensor || sj.sensor;\n        var numFrictionBefore = np.frictionEquations.length;\n        if (si.type < sj.type) {\n            numContacts = resolver.call(np, bi,si,xiw,aiw, bj,sj,xjw,ajw, sensor);\n        } else {\n            numContacts = resolver.call(np, bj,sj,xjw,ajw, bi,si,xiw,aiw, sensor);\n        }\n        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;\n\n        if(numContacts){\n\n            if( bi.allowSleep &&\n                bi.type === Body.DYNAMIC &&\n                bi.sleepState  === Body.SLEEPING &&\n                bj.sleepState  === Body.AWAKE &&\n                bj.type !== Body.STATIC\n            ){\n                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity,2);\n                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);\n                if(speedSquaredB >= speedLimitSquaredB*2){\n                    bi._wakeUpAfterNarrowphase = true;\n                }\n            }\n\n            if( bj.allowSleep &&\n                bj.type === Body.DYNAMIC &&\n                bj.sleepState  === Body.SLEEPING &&\n                bi.sleepState  === Body.AWAKE &&\n                bi.type !== Body.STATIC\n            ){\n                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity,2);\n                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);\n                if(speedSquaredA >= speedLimitSquaredA*2){\n                    bj._wakeUpAfterNarrowphase = true;\n                }\n            }\n\n            this.overlapKeeper.setOverlapping(bi, si, bj, sj);\n            if(this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)){\n\n                // Report new shape overlap\n                var e = this.beginContactEvent;\n                e.shapeA = si;\n                e.shapeB = sj;\n                e.bodyA = bi;\n                e.bodyB = bj;\n\n                // Reset contact equations\n                e.contactEquations.length = 0;\n\n                if(typeof(numContacts)===\"number\"){\n                    for(var i=np.contactEquations.length-numContacts; i<np.contactEquations.length; i++){\n                        e.contactEquations.push(np.contactEquations[i]);\n                    }\n                }\n\n                this.emit(e);\n            }\n\n            // divide the max friction force by the number of contacts\n            if(typeof(numContacts)===\"number\" && numFrictionEquations > 1){ // Why divide by 1?\n                for(var i=np.frictionEquations.length-numFrictionEquations; i<np.frictionEquations.length; i++){\n                    var f = np.frictionEquations[i];\n                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);\n                }\n            }\n        }\n    }\n\n};\n\n/**\n * Add a spring to the simulation\n *\n * @method addSpring\n * @param {Spring} spring\n */\nWorld.prototype.addSpring = function(spring){\n    this.springs.push(spring);\n    var evt = this.addSpringEvent;\n    evt.spring = spring;\n    this.emit(evt);\n    evt.spring = null;\n};\n\n/**\n * Remove a spring\n *\n * @method removeSpring\n * @param {Spring} spring\n */\nWorld.prototype.removeSpring = function(spring){\n    var idx = this.springs.indexOf(spring);\n    if(idx !== -1){\n        Utils.splice(this.springs,idx,1);\n    }\n};\n\n/**\n * Add a body to the simulation\n *\n * @method addBody\n * @param {Body} body\n *\n * @example\n *     var world = new World(),\n *         body = new Body();\n *     world.addBody(body);\n * @todo What if this is done during step?\n */\nWorld.prototype.addBody = function(body){\n    if(this.bodies.indexOf(body) === -1){\n        this.bodies.push(body);\n        body.world = this;\n        var evt = this.addBodyEvent;\n        evt.body = body;\n        this.emit(evt);\n        evt.body = null;\n    }\n};\n\n/**\n * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.\n *\n * @method removeBody\n * @param {Body} body\n */\nWorld.prototype.removeBody = function(body){\n    if(this.stepping){\n        this.bodiesToBeRemoved.push(body);\n    } else {\n        body.world = null;\n        var idx = this.bodies.indexOf(body);\n        if(idx!==-1){\n            Utils.splice(this.bodies,idx,1);\n            this.removeBodyEvent.body = body;\n            body.resetConstraintVelocity();\n            this.emit(this.removeBodyEvent);\n            this.removeBodyEvent.body = null;\n        }\n    }\n};\n\n/**\n * Get a body by its id.\n * @method getBodyById\n * @param {number} id\n * @return {Body} The body, or false if it was not found.\n */\nWorld.prototype.getBodyById = function(id){\n    var bodies = this.bodies;\n    for(var i=0; i<bodies.length; i++){\n        var b = bodies[i];\n        if(b.id === id){\n            return b;\n        }\n    }\n    return false;\n};\n\n/**\n * Disable collision between two bodies\n * @method disableBodyCollision\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nWorld.prototype.disableBodyCollision = function(bodyA,bodyB){\n    this.disabledBodyCollisionPairs.push(bodyA,bodyB);\n};\n\n/**\n * Enable collisions between the given two bodies\n * @method enableBodyCollision\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nWorld.prototype.enableBodyCollision = function(bodyA,bodyB){\n    var pairs = this.disabledBodyCollisionPairs;\n    for(var i=0; i<pairs.length; i+=2){\n        if((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){\n            pairs.splice(i,2);\n            return;\n        }\n    }\n};\n\n/**\n * Resets the World, removes all bodies, constraints and springs.\n *\n * @method clear\n */\nWorld.prototype.clear = function(){\n\n    this.time = 0;\n\n    // Remove all solver equations\n    if(this.solver && this.solver.equations.length){\n        this.solver.removeAllEquations();\n    }\n\n    // Remove all constraints\n    var cs = this.constraints;\n    for(var i=cs.length-1; i>=0; i--){\n        this.removeConstraint(cs[i]);\n    }\n\n    // Remove all bodies\n    var bodies = this.bodies;\n    for(var i=bodies.length-1; i>=0; i--){\n        this.removeBody(bodies[i]);\n    }\n\n    // Remove all springs\n    var springs = this.springs;\n    for(var i=springs.length-1; i>=0; i--){\n        this.removeSpring(springs[i]);\n    }\n\n    // Remove all contact materials\n    var cms = this.contactMaterials;\n    for(var i=cms.length-1; i>=0; i--){\n        this.removeContactMaterial(cms[i]);\n    }\n\n    World.apply(this);\n};\n\nvar hitTest_tmp1 = vec2.create(),\n    hitTest_zero = vec2.fromValues(0,0),\n    hitTest_tmp2 = vec2.fromValues(0,0);\n\n/**\n * Test if a world point overlaps bodies\n * @method hitTest\n * @param  {Array}  worldPoint  Point to use for intersection tests\n * @param  {Array}  bodies      A list of objects to check for intersection\n * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.\n * @return {Array}              Array of bodies that overlap the point\n * @todo Should use an api similar to the raycast function\n * @todo Should probably implement a .containsPoint method for all shapes. Would be more efficient\n * @todo Should use the broadphase\n */\nWorld.prototype.hitTest = function(worldPoint,bodies,precision){\n    precision = precision || 0;\n\n    // Create a dummy particle body with a particle shape to test against the bodies\n    var pb = new Body({ position:worldPoint }),\n        ps = new Particle(),\n        px = worldPoint,\n        pa = 0,\n        x = hitTest_tmp1,\n        zero = hitTest_zero,\n        tmp = hitTest_tmp2;\n    pb.addShape(ps);\n\n    var n = this.narrowphase,\n        result = [];\n\n    // Check bodies\n    for(var i=0, N=bodies.length; i!==N; i++){\n        var b = bodies[i];\n\n        for(var j=0, NS=b.shapes.length; j!==NS; j++){\n            var s = b.shapes[j];\n\n            // Get shape world position + angle\n            vec2.rotate(x, s.position, b.angle);\n            vec2.add(x, x, b.position);\n            var a = s.angle + b.angle;\n\n            if( (s instanceof Circle    && n.circleParticle  (b,s,x,a,     pb,ps,px,pa, true)) ||\n                (s instanceof Convex    && n.particleConvex  (pb,ps,px,pa, b,s,x,a,     true)) ||\n                (s instanceof Plane     && n.particlePlane   (pb,ps,px,pa, b,s,x,a,     true)) ||\n                (s instanceof Capsule   && n.particleCapsule (pb,ps,px,pa, b,s,x,a,     true)) ||\n                (s instanceof Particle  && vec2.squaredLength(vec2.sub(tmp,x,worldPoint)) < precision*precision)\n                ){\n                result.push(b);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Set the stiffness for all equations and contact materials.\n * @method setGlobalStiffness\n * @param {Number} stiffness\n */\nWorld.prototype.setGlobalStiffness = function(stiffness){\n\n    // Set for all constraints\n    var constraints = this.constraints;\n    for(var i=0; i !== constraints.length; i++){\n        var c = constraints[i];\n        for(var j=0; j !== c.equations.length; j++){\n            var eq = c.equations[j];\n            eq.stiffness = stiffness;\n            eq.needsUpdate = true;\n        }\n    }\n\n    // Set for all contact materials\n    var contactMaterials = this.contactMaterials;\n    for(var i=0; i !== contactMaterials.length; i++){\n        var c = contactMaterials[i];\n        c.stiffness = c.frictionStiffness = stiffness;\n    }\n\n    // Set for default contact material\n    var c = this.defaultContactMaterial;\n    c.stiffness = c.frictionStiffness = stiffness;\n};\n\n/**\n * Set the relaxation for all equations and contact materials.\n * @method setGlobalRelaxation\n * @param {Number} relaxation\n */\nWorld.prototype.setGlobalRelaxation = function(relaxation){\n\n    // Set for all constraints\n    for(var i=0; i !== this.constraints.length; i++){\n        var c = this.constraints[i];\n        for(var j=0; j !== c.equations.length; j++){\n            var eq = c.equations[j];\n            eq.relaxation = relaxation;\n            eq.needsUpdate = true;\n        }\n    }\n\n    // Set for all contact materials\n    for(var i=0; i !== this.contactMaterials.length; i++){\n        var c = this.contactMaterials[i];\n        c.relaxation = c.frictionRelaxation = relaxation;\n    }\n\n    // Set for default contact material\n    var c = this.defaultContactMaterial;\n    c.relaxation = c.frictionRelaxation = relaxation;\n};\n\nvar tmpAABB = new AABB();\nvar tmpArray = [];\n\n/**\n * Ray cast against all bodies in the world.\n * @method raycast\n * @param  {RaycastResult} result\n * @param  {Ray} ray\n * @return {boolean} True if any body was hit.\n *\n * @example\n *     var ray = new Ray({\n *         mode: Ray.CLOSEST, // or ANY\n *         from: [0, 0],\n *         to: [10, 0],\n *     });\n *     var result = new RaycastResult();\n *     world.raycast(result, ray);\n *\n *     // Get the hit point\n *     var hitPoint = vec2.create();\n *     result.getHitPoint(hitPoint, ray);\n *     console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));\n *\n * @example\n *     var ray = new Ray({\n *         mode: Ray.ALL,\n *         from: [0, 0],\n *         to: [10, 0],\n *         callback: function(result){\n *\n *             // Print some info about the hit\n *             console.log('Hit body and shape: ', result.body, result.shape);\n *\n *             // Get the hit point\n *             var hitPoint = vec2.create();\n *             result.getHitPoint(hitPoint, ray);\n *             console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));\n *\n *             // If you are happy with the hits you got this far, you can stop the traversal here:\n *             result.stop();\n *         }\n *     });\n *     var result = new RaycastResult();\n *     world.raycast(result, ray);\n */\nWorld.prototype.raycast = function(result, ray){\n\n    // Get all bodies within the ray AABB\n    ray.getAABB(tmpAABB);\n    this.broadphase.aabbQuery(this, tmpAABB, tmpArray);\n    ray.intersectBodies(result, tmpArray);\n    tmpArray.length = 0;\n\n    return result.hasHit();\n};\n","var Scalar = require('./Scalar');\n\nmodule.exports = Line;\n\n/**\n * Container for line-related functions\n * @class Line\n */\nfunction Line(){};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nLine.lineInt = function(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!Scalar.eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n};\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nLine.segmentsIntersect = function(p1, p2, q1, q2){\n   var dx = p2[0] - p1[0];\n   var dy = p2[1] - p1[1];\n   var da = q2[0] - q1[0];\n   var db = q2[1] - q1[1];\n\n   // segments are parallel\n   if(da*dy - db*dx == 0)\n      return false;\n\n   var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx)\n   var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy)\n\n   return (s>=0 && s<=1 && t>=0 && t<=1);\n};\n\n","module.exports = Point;\n\n/**\n * Point related functions\n * @class Point\n */\nfunction Point(){};\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nPoint.area = function(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n};\n\nPoint.left = function(a,b,c){\n    return Point.area(a,b,c) > 0;\n};\n\nPoint.leftOn = function(a,b,c) {\n    return Point.area(a, b, c) >= 0;\n};\n\nPoint.right = function(a,b,c) {\n    return Point.area(a, b, c) < 0;\n};\n\nPoint.rightOn = function(a,b,c) {\n    return Point.area(a, b, c) <= 0;\n};\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nPoint.collinear = function(a,b,c,thresholdAngle) {\n    if(!thresholdAngle)\n        return Point.area(a, b, c) == 0;\n    else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n};\n\nPoint.sqdist = function(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n};\n","var Line = require(\"./Line\")\n,   Point = require(\"./Point\")\n,   Scalar = require(\"./Scalar\")\n\nmodule.exports = Polygon;\n\n/**\n * Polygon class.\n * @class Polygon\n * @constructor\n */\nfunction Polygon(){\n\n    /**\n     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = [];\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nPolygon.prototype.at = function(i){\n    var v = this.vertices,\n        s = v.length;\n    return v[i < 0 ? i % s + s : i % s];\n};\n\n/**\n * Get first vertex\n * @method first\n * @return {Array}\n */\nPolygon.prototype.first = function(){\n    return this.vertices[0];\n};\n\n/**\n * Get last vertex\n * @method last\n * @return {Array}\n */\nPolygon.prototype.last = function(){\n    return this.vertices[this.vertices.length-1];\n};\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nPolygon.prototype.clear = function(){\n    this.vertices.length = 0;\n};\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nPolygon.prototype.append = function(poly,from,to){\n    if(typeof(from) == \"undefined\") throw new Error(\"From is not given!\");\n    if(typeof(to) == \"undefined\")   throw new Error(\"To is not given!\");\n\n    if(to-1 < from)                 throw new Error(\"lol1\");\n    if(to > poly.vertices.length)   throw new Error(\"lol2\");\n    if(from < 0)                    throw new Error(\"lol3\");\n\n    for(var i=from; i<to; i++){\n        this.vertices.push(poly.vertices[i]);\n    }\n};\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nPolygon.prototype.makeCCW = function(){\n    var br = 0,\n        v = this.vertices;\n\n    // find bottom right point\n    for (var i = 1; i < this.vertices.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] == v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {\n        this.reverse();\n    }\n};\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nPolygon.prototype.reverse = function(){\n    var tmp = [];\n    for(var i=0, N=this.vertices.length; i!==N; i++){\n        tmp.push(this.vertices.pop());\n    }\n    this.vertices = tmp;\n};\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nPolygon.prototype.isReflex = function(i){\n    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));\n};\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nPolygon.prototype.canSee = function(a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {\n        return false;\n    }\n    dist = Point.sqdist(this.at(a), this.at(b));\n    for (var i = 0; i !== this.vertices.length; ++i) { // for each edge\n        if ((i + 1) % this.vertices.length === a || i === a) // ignore incident edges\n            continue;\n        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) { // if diag intersects an edge\n            l1[0] = this.at(a);\n            l1[1] = this.at(b);\n            l2[0] = this.at(i);\n            l2[1] = this.at(i + 1);\n            p = Line.lineInt(l1,l2);\n            if (Point.sqdist(this.at(a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n};\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nPolygon.prototype.copy = function(i,j,targetPoly){\n    var p = targetPoly || new Polygon();\n    p.clear();\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++)\n            p.vertices.push(this.vertices[k]);\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++)\n            p.vertices.push(this.vertices[k]);\n\n        // Insert vertices i to end\n        for(var k=i; k<this.vertices.length; k++)\n            p.vertices.push(this.vertices[k]);\n    }\n\n    return p;\n};\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nPolygon.prototype.getCutEdges = function() {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = new Polygon();\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < this.vertices.length; ++i) {\n        if (this.isReflex(i)) {\n            for (var j = 0; j < this.vertices.length; ++j) {\n                if (this.canSee(i, j)) {\n                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();\n                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();\n\n                    for(var k=0; k<tmp2.length; k++)\n                        tmp1.push(tmp2[k]);\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([this.at(i), this.at(j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n};\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nPolygon.prototype.decomp = function(){\n    var edges = this.getCutEdges();\n    if(edges.length > 0)\n        return this.slice(edges);\n    else\n        return [this];\n};\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nPolygon.prototype.slice = function(cutEdges){\n    if(cutEdges.length == 0) return [this];\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length==2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [this];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = poly.slice(cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = this.vertices.indexOf(cutEdge[0]);\n        var j = this.vertices.indexOf(cutEdge[1]);\n\n        if(i != -1 && j != -1){\n            return [this.copy(i,j),\n                    this.copy(j,i)];\n        } else {\n            return false;\n        }\n    }\n};\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nPolygon.prototype.isSimple = function(){\n    var path = this.vertices;\n    // Check\n    for(var i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(Line.segmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(var i=1; i<path.length-2; i++){\n        if(Line.segmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n};\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n    delta = delta || 0;\n   var a1 = p2[1] - p1[1];\n   var b1 = p1[0] - p2[0];\n   var c1 = (a1 * p1[0]) + (b1 * p1[1]);\n   var a2 = q2[1] - q1[1];\n   var b2 = q1[0] - q2[0];\n   var c2 = (a2 * q1[0]) + (b2 * q1[1]);\n   var det = (a1 * b2) - (a2 * b1);\n\n   if(!Scalar.eq(det,0,delta))\n      return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det]\n   else\n      return [0,0]\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nPolygon.prototype.quickDecomp = function(result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!=\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=new Polygon(), upperPoly=new Polygon(); // polygons\n    var poly = this,\n        v = this.vertices;\n\n    if(v.length < 3) return result;\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < this.vertices.length; ++i) {\n        if (poly.isReflex(i)) {\n            reflexVertices.push(poly.vertices[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < this.vertices.length; ++j) {\n                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j))\n                        && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection\n                    if (Point.right(poly.at(i + 1), poly.at(i), p)) { // make sure it's inside the poly\n                        d = Point.sqdist(poly.vertices[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1))\n                        && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {\n                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));\n                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {\n                        d = Point.sqdist(poly.vertices[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+this.vertices.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    lowerPoly.append(poly, i, upperIndex+1);\n                    lowerPoly.vertices.push(p);\n                    upperPoly.vertices.push(p);\n                    if (lowerIndex != 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        upperPoly.append(poly,lowerIndex,poly.vertices.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    upperPoly.append(poly,0,i+1);\n                } else {\n                    if (i != 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        lowerPoly.append(poly,i,poly.vertices.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    lowerPoly.append(poly,0,upperIndex+1);\n                    lowerPoly.vertices.push(p);\n                    upperPoly.vertices.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    upperPoly.append(poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+this.vertices.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += this.vertices.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j))\n                            && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {\n                        d = Point.sqdist(poly.at(i), poly.at(j));\n                        if (d < closestDist) {\n                            closestDist = d;\n                            closestIndex = j % this.vertices.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    lowerPoly.append(poly,i,closestIndex+1);\n                    if (closestIndex != 0){\n                        upperPoly.append(poly,closestIndex,v.length);\n                    }\n                    upperPoly.append(poly,0,i+1);\n                } else {\n                    if (i != 0){\n                        lowerPoly.append(poly,i,v.length);\n                    }\n                    lowerPoly.append(poly,0,closestIndex+1);\n                    upperPoly.append(poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.vertices.length < upperPoly.vertices.length) {\n                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(this);\n\n    return result;\n};\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nPolygon.prototype.removeCollinearPoints = function(precision){\n    var num = 0;\n    for(var i=this.vertices.length-1; this.vertices.length>3 && i>=0; --i){\n        if(Point.collinear(this.at(i-1),this.at(i),this.at(i+1),precision)){\n            // Remove the middle point\n            this.vertices.splice(i%this.vertices.length,1);\n            i--; // Jump one point forward. Otherwise we may get a chain removal\n            num++;\n        }\n    }\n    return num;\n};\n","module.exports = Scalar;\n\n/**\n * Scalar functions\n * @class Scalar\n */\nfunction Scalar(){}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nScalar.eq = function(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) < precision;\n};\n","module.exports = {\n    Polygon : require(\"./Polygon\"),\n    Point : require(\"./Point\"),\n};\n","import { Application } from './Polar/Core/Application';\n\nlet application: Application;\n\n/**\n * Begin running the polar engine.\n * \n * @remarks There can only be one application running at one time.\n * \n * @param app Subclass of a Polar Application.\n */\nexport function begin(app: Application) {\n\tconsole.assert(application == null, 'Application has already been created!');\n\tapplication = app;\n\tapplication.start();\n}\n\n/** Stop the engine. */\nexport function stop() {\n\tconsole.assert(application != null, 'Application has not been created yet!');\n\tapplication.stop();\n\tapplication = null;\n}\n\nimport * as glm from 'gl-matrix';\nimport * as p2 from 'p2';\nimport * as TextureShaderSource from './Polar/Renderer/ShaderSource/TextureShaderSource';\nimport * as ColorShaderSource from './Polar/Renderer/ShaderSource/ColorShaderSource';\nimport * as InvertShaderSource from './Polar/Renderer/ShaderSource/InvertShaderSource';\nimport * as GrayscaleShaderSource from './Polar/Renderer/ShaderSource/GrayscaleShaderSource';\nimport * as VignetteShaderSource from './Polar/Renderer/ShaderSource/VignetteShaderSource';\nimport * as GaussianBlurShaderSource from './Polar/Renderer/ShaderSource/GaussianBlurShaderSource';\n\nexport { Application, glm, p2, TextureShaderSource, ColorShaderSource, InvertShaderSource, GrayscaleShaderSource, VignetteShaderSource, GaussianBlurShaderSource };\n\nexport * from './Polar/Core/Layer';\nexport * from './Polar/Core/Input';\nexport * from './Polar/Core/LayerStack';\nexport * from './Polar/Core/ApplicationSettings';\nexport * from './Polar/Renderer/Buffer';\nexport * from './Polar/Renderer/FrameBuffer';\nexport * from './Polar/Renderer/ImageLibrary';\nexport * from './Polar/Renderer/InstancedRenderer';\nexport * from './Polar/Renderer/LightRenderer';\nexport * from './Polar/Renderer/OrthographicCamera';\nexport * from './Polar/Renderer/ParticleEmitter';\nexport * from './Polar/Renderer/ParticleRenderer';\nexport * from './Polar/Renderer/PostprocessingStage';\nexport * from './Polar/Renderer/RenderBuffer';\nexport * from './Polar/Renderer/Renderer';\nexport * from './Polar/Renderer/Shader';\nexport * from './Polar/Renderer/ShaderLibrary';\nexport * from './Polar/Renderer/Sprite';\nexport * from './Polar/Renderer/Surface';\nexport * from './Polar/Renderer/Texture';\nexport * from './Polar/Renderer/TextureAtlas';\nexport * from './Polar/Renderer/TextureLibrary';\nexport * from './Polar/Renderer/VertexArray';\nexport * from './Polar/ECS/Component';\nexport * from './Polar/ECS/Components';\nexport * from './Polar/ECS/Entity';\nexport * from './Polar/ECS/System';\nexport * from './Polar/ECS/WorldManager';\nexport * from './Polar/ECS/ECSState';\nexport * from './Polar/ECS/Systems/CameraControllerSystem';\nexport * from './Polar/ECS/Systems/LightRenderSystem';\nexport * from './Polar/ECS/Systems/ParticleSystem';\nexport * from './Polar/ECS/Systems/Physics';\nexport * from './Polar/ECS/Systems/RenderSystem';\nexport * from './Polar/ECS/Systems/TransformSystem';\nexport * from './Polar/ECS/Systems/TextureLoad';\nexport * from './Polar/Events/ApplicationEvent';\nexport * from './Polar/Events/Event';\nexport * from './Polar/Events/KeyEvent';\nexport * from './Polar/Events/MouseEvent';\nexport * from './Polar/Util/Timer';\nexport * from './Polar/Util/OrthographicCameraController';\nexport * from './Polar/Util/Math';\nexport * from './Polar/ECS/Systems/FPSDebugSystem';\n","import { Layer } from './Layer';\nimport { LayerStack } from './LayerStack';\nimport { Renderer } from '../Renderer/Renderer';\nimport { Surface } from '../Renderer/Surface';\nimport { Input } from './Input';\nimport { ApplicationSettings } from './ApplicationSettings';\nimport { Event } from '../Events/Event';\n\n/** Represents a Polar Application to be attached to the engine. */\nexport abstract class Application {\n\tprivate lastFrameTime: number = 0;\n\tprivate layerStack: LayerStack;\n\tprivate frameID: number;\n\n\t/**\n\t * Create a new application.\n\t * @param {ApplicationSettings} settings The settings.\n\t */\n\tpublic constructor(settings: ApplicationSettings) {\n\t\tthis.layerStack = new LayerStack();\n\n\t\tSurface.setEventCallback(this.onEvent.bind(this));\n\n\t\tSurface.init(settings);\n\t\tInput.init(this.onEvent.bind(this));\n\t\tRenderer.init();\n\t}\n\n\t/** Starts the update loop of the application. */\n\tpublic start() {\n\t\t// Start the update loop.\n\t\tconst update = (_: DOMHighResTimeStamp) => {\n\t\t\tconst time = performance.now();\n\t\t\tconst deltaTime = (time - this.lastFrameTime) / 1000;\n\t\t\tthis.lastFrameTime = time;\n\n\t\t\tSurface.onUpdate(deltaTime);\n\t\t\tSurface.font.clearRect(0, 0, Surface.getWidth(), Surface.getHeight());\n\t\t\tthis.layerStack.onUpdate(deltaTime);\n\t\t\tthis.frameID = window.requestAnimationFrame(update);\n\t\t};\n\n\t\tupdate(null);\n\t}\n\n\t/** Stops the update loop of the application. */\n\tpublic stop() {\n\t\tconsole.assert(this.frameID != null, 'Application has not begun!');\n\t\twindow.cancelAnimationFrame(this.frameID);\n\t}\n\n\t/** Add a new layer to the top of the current layers (Below overlays).\n\t * @param {Layer} layer The layer.\n\t */\n\tpublic pushLayer(layer: Layer) {\n\t\tthis.layerStack.pushLayer(layer);\n\t\tvar app = this;\n\t\tlayer.eventCallbackFn = this.onEvent.bind(this);\n\t\tlayer.onAttach();\n\t}\n\n\t/** Add a new overlay layer to the top of the current overlays (Above everything).\n\t * @param {Layer} layer The overlay layer.\n\t */\n\tpublic pushOverlay(layer: Layer) {\n\t\tthis.layerStack.pushOverlay(layer);\n\t\tlayer.onAttach();\n\t}\n\n\tpublic onEvent(event: Event) {\n\t\tif (!this.layerStack || !this.layerStack.layers) return;\n\n\t\tRenderer.onEvent(event);\n\n\t\tfor (const layer of this.layerStack.layers) {\n\t\t\tlayer.onEvent(event);\n\n\t\t\t// Allow layers to block events from passing to the next layer.\n\t\t\tif (event.handled === true) break;\n\t\t}\n\t}\n}","import * as glm from 'gl-matrix';\n\n/** Settings for creating a new application. */\nexport class ApplicationSettings {\n\t/** The ID of the HTMLCanvasElement. */\n\tpublic canvasID: string;\n\t/** The display mode of the game engine.\n\t * \n\t * Can be 'fixed' or 'fill'.\n\t */\n\tpublic displayMode: string;\n\t/** The width of the display surface. */\n\tpublic width: number;\n\t/** The height of the display surface. */\n\tpublic height: number;\n\t/** The background color of the surface. */\n\tpublic clearColor: glm.vec3 = glm.vec3.fromValues(0.1, 0.1, 0.1);\n\t/** Whether the context menu appears when the user right clicks on the canvas. */\n\tpublic allowContextMenu: boolean = false;\n}","import * as glm from 'gl-matrix';\nimport { Event } from '../Events/Event';\nimport { KeyDownEvent, KeyUpEvent } from '../Events/KeyEvent';\nimport { MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseWheelEvent } from '../Events/MouseEvent';\n\nexport class Input {\n\tprivate static keyStates: {[id: string]: boolean};\n\tprivate static mouseButtonStates: {[id: number]: boolean};\n\tprivate static mousePosition: glm.vec2;\n\t\n\t/** Initialize the input system of Polar. Not to be called by the user.\n\t * @internal\n\t */\n\tpublic static init(eventCallbackFn: (event: Event) => void) {\n\t\tthis.keyStates = {};\n\t\tthis.mouseButtonStates = {};\n\t\tthis.mousePosition = glm.vec2.create();\n\t\t\n\t\twindow.addEventListener('keydown', (ev: KeyboardEvent) => {\n\t\t\tthis.keyStates[ev.key] = true;\n\t\t\teventCallbackFn(new KeyDownEvent(ev.key));\n\t\t});\n\n\t\twindow.addEventListener('keyup', (ev: KeyboardEvent) => {\n\t\t\tthis.keyStates[ev.key] = false;\n\t\t\teventCallbackFn(new KeyUpEvent(ev.key));\n\t\t});\n\n\t\twindow.addEventListener('mousedown', (ev: MouseEvent) => {\n\t\t\tthis.mouseButtonStates[ev.button] = true;\n\t\t\teventCallbackFn(new MouseDownEvent(ev.pageX, ev.pageY, ev.button));\n\t\t});\n\n\t\twindow.addEventListener('mouseup', (ev: MouseEvent) => {\n\t\t\tthis.mouseButtonStates[ev.button] = false;\n\t\t\teventCallbackFn(new MouseUpEvent(ev.pageX, ev.pageY, ev.button));\n\t\t});\n\n\t\twindow.addEventListener('mousemove', (ev: MouseEvent) => {\n\t\t\tthis.mousePosition[0] = ev.pageX;\n\t\t\tthis.mousePosition[1] = ev.pageY;\n\t\t\teventCallbackFn(new MouseMoveEvent(ev.pageX, ev.pageY));\n\t\t});\n\n\t\twindow.addEventListener('wheel', ev => {\n\t\t\teventCallbackFn(new MouseWheelEvent(ev.pageX, ev.pageY, ev.deltaX, ev.deltaY));\n\t\t});\n\t}\n\n\t/**\n\t * Get the state of a key.\n\t * @param {string} key The name of the key.\n\t * @returns {boolean} The state of the key. DOWN = true, UP = false.\n\t */\n\tpublic static isKeyPressed(key: string): boolean {\n\t\treturn this.keyStates[key] == null ? false : this.keyStates[key];\n\t}\n\n\t/**\n\t * Get the state of a mouse button.\n\t * @param {number} button The index of the mouse button\n\t * @returns {boolean} The state of the mouse button. DOWN = true, UP = false.\n\t */\n\tpublic static isMouseButtonPressed(button: number): boolean {\n\t\treturn this.mouseButtonStates[button] == null ? false : this.mouseButtonStates[button];\n\t}\n\n\t/**\n\t * Get the mouse position within the page.\n\t * @returns {glm.vec2} The position of the mouse within the page.\n\t */\n\tpublic static getMousePosition(): glm.vec2 {\n\t\treturn this.mousePosition;\n\t}\n}","import { Event, EventHandler, EventCreator } from '../Events/Event';\n\n/** Represents a layer to be rendered to. */\nexport abstract class Layer implements EventHandler, EventCreator {\n\tprivate debugName: string;\n\n\tpublic eventCallbackFn: (event: Event) => void;\n\t\n\t/** Create a new layer. */\n\tpublic constructor(name: string) {\n\t\tthis.debugName = name;\n\t}\n\n\t/** Called when the layer is attached to the application. */\n\tpublic onAttach() {};\n\t/** Called when the layer is detached from the application. */\n\tpublic onDetach() {};\n\t/** Called every update cycle. */\n\tpublic onUpdate(deltaTime: number) {};\n\t\n\t/**\n\t * Called whenever an event is raised by the application.\n\t * @param {Event} event The event.\n\t */\n\tpublic onEvent(event: Event) {};\n\n\t/**\n\t * Get the debug name of the layer.\n\t * @returns {string} The debug name.\n\t */\n\tpublic getName(): string {\n\t\treturn this.debugName;\n\t}\n}","import { Layer } from './Layer';\n\nexport class LayerStack {\n\t\n\tpublic layers: Layer[];\n\tprivate layerInsertIndex = 0;\n\n\t/** Create a new layer stack. */\n\tpublic constructor() {\n\t\tthis.layers = [];\n\t}\n\n\t/**\n\t * Push a layer onto the top of the other layers.\n\t * @param {type} Layer The layer.\n\t */\n\tpublic pushLayer(layer: Layer) {\n\t\tthis.layers.splice(this.layerInsertIndex, 0, layer);\n\t\tthis.layerInsertIndex++;\n\t}\n\n\t/**\n\t * Push an overlay layer on top of all other overlay layers.\n\t * @param {type} Layer The overlay layer.\n\t */\n\tpublic pushOverlay(overlay: Layer) {\n\t\tthis.layers.push(overlay);\n\t}\n\n\t/**\n\t * Remove a layer from the layer stack.\n\t * @param {type} Layer The layer.\n\t */\n\tpublic popLayer(layer: Layer) {\n\t\tthis.layers = this.layers.filter(item => item != layer);\n\t\tthis.layerInsertIndex--;\n\t}\n\n\t/**\n\t * Remove an overlay layer from the layer stack.\n\t * @param {type} Layer The overlay layer.\n\t */\n\tpublic popOverlay(overlay: Layer) {\n\t\tthis.layers = this.layers.filter(item => item != overlay);\n\t}\n\n\t/** Called every update cycle. Updates the layer stack. */\n\tpublic onUpdate(deltaTime: number) {\n\t\tfor (const layer of this.layers) {\n\t\t\tlayer.onUpdate(deltaTime);\n\t\t}\n\t}\n}","/**\n * Represents a collection of information about an entity used to define behavior.\n * Should contain no behavior or functionality, only data in the form of properties.\n * @abstract\n */\nexport abstract class Component {\n\t/**\n\t * Get the type of the component.\n\t * To be overridden in every component subclass to return a string unique to the component type.\n\t * Recommended format: '<Namespace>:<ComponentClassName>'.\n\t * Example: 'Sandbox:Goal'.\n\t * @returns {string} A unique identifier for the component type.\n\t */\n\tpublic readonly type: string = 'error';\n}","import * as glm from 'gl-matrix';\nimport { Component } from './Component';\nimport { Texture2D } from '../Renderer/Texture';\nimport { OrthographicCamera } from '../Renderer/OrthographicCamera';\nimport { createTransform } from '../Util/Math';\n\n/** Polar component which stores information about an entity's transform (position, rotation, scale).\n * \n * @component 'Polar:Transform'\n*/\nexport class TransformCP extends Component {\n\n\tpublic readonly type = 'Polar:Transform';\n\tpublic x: number = 0;\n\tpublic y: number = 0;\n\tpublic rotation: number = 0;\n\tpublic scaleX: number = 1;\n\tpublic scaleY: number = 1;\n\tpublic modified: boolean = true;\n\n\tpublic transform: glm.mat4;\n\n\t/** Create a new transform component. */\n\tpublic constructor(x: number = 0, y: number = 0, rotation: number = 0, scaleX: number = 1, scaleY: number = 1) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.rotation = rotation;\n\t\tthis.scaleX = scaleX;\n\t\tthis.scaleY = scaleY;\n\n\t\tthis.transform = createTransform(x, y, rotation, scaleX, scaleY, 0);\n\t\tthis.modified = false;\n\t}\n}\n\n/** A component which stores data about a 2D texture. \n * \n * @component 'Polar:Texture2D'\n*/\nexport class Texture2DCP extends Component {\n\n\tpublic readonly type = 'Polar:Texture2D';\n\t/** The texture. */\n\tpublic texture: Texture2D;\n\n\t/**\n\t * Create a new texture 2D component.\n\t * @param {Texture2D} texture THe texture.\n\t */\n\tpublic constructor(texture: Texture2D) {\n\t\tsuper();\n\t\tthis.texture = texture;\n\t}\n}\n\n/** A component which stores a camera.\n * \n * @component 'Polar:Camera'\n */\nexport class CameraCP extends Component {\n\n\tpublic readonly type = 'Polar:Camera';\n\tpublic camera: OrthographicCamera;\n}","import { Component } from './Component';\nimport { System } from './System';\n\nexport class ECSState {\n\tpublic systemNames: string[];\n\tpublic entities: EntityTemplate[];\n\tpublic singletons: EntityTemplate;\n\n\tpublic constructor(systemNames: string[], entities: EntityTemplate[], singletons: EntityTemplate) {\n\t\tthis.systemNames = systemNames;\n\t\tthis.entities = entities;\n\t\tthis.singletons = singletons;\n\t}\n}\n\nexport class ECSLoader {\n\tprivate static registeredSystems: Map<string, System>;\n\tpublic static getSystems(state: ECSState): System[] {\n\t\tlet systems: System[] = [];\n\t\tfor (let system of this.registeredSystems.values()) {\n\t\t\tif (state.systemNames.includes(system.getName())) {\n\t\t\t\tsystems.push(system);\n\t\t\t}\n\t\t}\n\t\treturn systems;\n\t}\n\n\tpublic static init() {\n\t\tthis.registeredSystems = new Map<string, System>();\n\t}\n\n\tpublic static registerSystem(system: System) {\n\t\tif (this.registeredSystems) {\n\t\t\tthis.registeredSystems.set(system.getName(), system);\n\t\t}\n\t\telse {\n\t\t\tconsole.error('this.registeredSystems is undefined. Remember to call Polar.ECSState.init().');\n\t\t}\n\t}\n}\n\nexport class EntityTemplate {\n\t/** The entity's ID. */\n\tpublic id: number;\n\t/** The entity's components. */\n\tpublic components: Component[];\n\n\t/**\n\t * Create a new EntityTemplate.\n\t * @param {number} id The entity's ID.\n\t * @param {Component[]} components The entity's components.\n\t */\n\tconstructor(id: number, components: Component[]) {\n\t\tthis.id = id;\n\t\tthis.components = components;\n\t}\n}","import { Component } from './Component';\n\n/** Represents a collection of components relating to a single entity in the world. */\nexport class Entity {\n\t/** The entity's ID.*/\n\tpublic id: number;\n\t\n\t/** The entity's components.*/\n\tpublic readonly components: Map<string, Component>;\n\n\t/** Create a new entity.\n\t * @param {number} id The entity's ID.\n\t */\n\tpublic constructor(id: number) {\n\t\tthis.id = id;\n\t\tthis.components = new Map<string, Component>();\n\t}\n\n\t/**\n\t * Test if an entity has a component.\n\t * Note: Often it is better to use the 'subIndex' parameter within system.onEntityUpdate( ... ) { ... }.\n\t * @param {string} type The component type.\n\t * @returns {boolean} Whether the entity has the component.\n\t */\n\tpublic hasComponent(type: string): boolean {\n\t\treturn this.components.has(type);\n\t}\n\n\t/**\n\t * Get a component from an entity.\n\t * @param {string} type The component type.\n\t * @returns {Component} The component.\n\t */\n\tpublic getComponent(type: string): Component {\n\t\treturn this.components.get(type);\n\t}\n\n\t/**\n\t * Add a component to an entity.\n\t * @param {Component} component The component to add.\n\t */\n\tpublic addComponent(component: Component) {\n\t\tthis.components.set(component.type, component);\n\t}\n\n\t/**\n\t * Remove a component from an entity.\n\t * @param {string} type The component type to remove.\n\t */\n\tpublic removeComponent(type: string) {\n\t\tthis.components.delete(type);\n\t}\n}","import { WorldManager } from './WorldManager';\nimport { Entity } from './Entity';\nimport { Event, EventHandler, EventCreator } from '../Events/Event';\n\n/**\n * Represents a behavior which is applied to entities' components.\n * Should contain no state / data.\n * @abstract\n */\nexport abstract class System implements EventHandler, EventCreator {\n\t/** The system's subscribed entities. Format: [Entity ID: string, Subscriber Index: string] */\n\tpublic subscribers: Map<number, number>;\n\n\t/** Create a new system. */\n\tpublic constructor() {\n\t\tthis.subscribers = new Map<number, number>();\n\t}\n\t\n\t/** Called after the system is added to the world manager. */\n\tpublic abstract onAttach(): void;\n\t\n\t/** Called before the system is removed from the world manager. */\n\tpublic onDetach(): void { /*this.manager = null;*/ };\n\t\n\t/**\n\t * Called every update for each entity subscribed to system.\n\t * @param {number} dt The elapsed time since the last frame in seconds.\n\t * @param {Array<Entity>} entity The entity to be updated.\n\t * @param {number} subIndex The index of the tuple which the entity subscribed to in System.getComponentTuples();\n\t */\n\tpublic abstract onEntityUpdate(dt: number, entity: Entity, subIndex: number): void;\n\t\n\t/**\n\t * Called by the world manager at the start of an update cycle.\n\t * @param dt Time elapsed since last update in seconds.\n\t */\n\tpublic abstract beginUpdate(dt: number): void;\n\t\n\t/**\n\t * Called by the world manager at the end of an update cycle.\n\t * @param {number} dt Time elapsed since last update in seconds.\n\t */\n\tpublic abstract endUpdate(dt: number): void;\n\t\n\tpublic abstract onEvent(event: Event): void;\n\t\n\t/**\n\t * Returns the component tuples for a system.\n\t * @returns {string[][]} An array of tuples which contain the types of components which are to be updated.\n\t */\n\tpublic abstract getComponentTuples(): string[][];\n\t\n\t/**\n\t * Returns the name of the system, unique to each system type.\n\t * @remarks\n\t * Recommended format: '<Namespace>:<SystemClassName>'.\n\t * @example 'Sandbox:GoalSystem'.\n\t * @returns {string} The name of the system.\n\t */\n\tpublic abstract getName(): string;\n\n\t/**\n\t * Callback function set by the world manager which allows a system to access its world manager.\n\t */\n\tpublic getManager: () => WorldManager;\n\n\tpublic eventCallbackFn: (event: Event) => void;\n}","import * as glm from 'gl-matrix';\nimport { System } from '../System';\nimport { Component} from '../Component';\nimport { Entity } from '../Entity';\nimport { CameraCP } from '../Components';\nimport { OrthographicCamera } from '../../Renderer/OrthographicCamera';\nimport { Surface } from '../../Renderer/Surface';\nimport { Input } from '../../Core/Input';\nimport { Event, EventDispatcher } from '../../Events/Event';\nimport { CanvasResizeEvent } from '../../Events/ApplicationEvent';\nimport { MouseWheelEvent } from '../../Events/MouseEvent';\n\n/** A simple camera movement controller. */\nexport class CameraControllerSystem extends System {\n\n\tpublic onAttach(): void {\n\t\tconst controllerData = <CameraControllerCP>this.getManager().getSingleton('Polar:CameraController');\n\n\t\tlet aspectRatio = !controllerData.aspectRatio ? Surface.getWidth() / Surface.getHeight() : controllerData.aspectRatio;\n\n\t\t(<CameraCP>this.getManager().getSingleton('Polar:Camera')).camera = new OrthographicCamera(-aspectRatio * controllerData.zoomLevel, \n\t\t\taspectRatio * controllerData.zoomLevel, -controllerData.zoomLevel, controllerData.zoomLevel);\n\n\t\tlet camera = (<CameraCP>this.getManager().getSingleton('Polar:Camera')).camera;\n\n\t\tcamera.setPosition(controllerData.cameraPosition);\n\t\tcamera.setRotation(controllerData.cameraRotation);\n\t}\n\n\tpublic onEntityUpdate(dt: number, entity: Entity, subIndex: number): void {}\n\n\tpublic beginUpdate(deltaTime: number): void {\n\t\tconst controllerData: CameraControllerCP = <CameraControllerCP>this.getManager().getSingleton('Polar:CameraController');\n\t\tlet camera = (<CameraCP>this.getManager().getSingleton('Polar:Camera')).camera;\n\n\t\tlet doPosition = false;\n\t\tif (Input.isKeyPressed('a')) {\n\t\t\tcontrollerData.cameraPosition[0] -=  this.cameraTranslationSpeed(controllerData.zoomLevel) * deltaTime;\n\t\t\tdoPosition = true;\n\t\t}\n\t\tif (Input.isKeyPressed('d')) {\n\t\t\tcontrollerData.cameraPosition[0] += this.cameraTranslationSpeed(controllerData.zoomLevel) * deltaTime;\n\t\t\tdoPosition = true;\n\t\t}\n\t\tif (Input.isKeyPressed('s')) {\n\t\t\tcontrollerData.cameraPosition[1] -= this.cameraTranslationSpeed(controllerData.zoomLevel) * deltaTime;\n\t\t\tdoPosition = true;\n\t\t}\n\t\tif (Input.isKeyPressed('w')) {\n\t\t\tcontrollerData.cameraPosition[1] += this.cameraTranslationSpeed(controllerData.zoomLevel) * deltaTime;\n\t\t\tdoPosition = true;\n\t\t}\n\n\t\tif (controllerData.doRotation) {\n\t\t\tlet doRotation = false;\n\t\t\tif (Input.isKeyPressed('q')) {\n\t\t\t\tcontrollerData.cameraRotation += controllerData.cameraRotationSpeed * deltaTime;\n\t\t\t\tdoRotation = true;\n\t\t\t}\n\t\t\tif (Input.isKeyPressed('e')) {\n\t\t\t\tcontrollerData.cameraRotation -= controllerData.cameraRotationSpeed * deltaTime;\n\t\t\t\tdoRotation = true;\n\t\t\t}\n\t\t\tif (doRotation) {\n\t\t\t\tcamera.setRotation(controllerData.cameraRotation);\n\t\t\t\tthis.eventCallbackFn(new CameraTransformEvent());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Only recalculate if the position has changed.\n\t\tif (doPosition) {\n\t\t\tcamera.setPosition(controllerData.cameraPosition);\n\t\t\tthis.eventCallbackFn(new CameraTransformEvent());\n\t\t}\n\t}\n\n\tpublic endUpdate(dt: number): void {}\n\n\tpublic onEvent(event: Event): void {\n\t\tconst dispatcher = new EventDispatcher(event);\n\t\t\n\t\t// onCanvasResize\n\t\tdispatcher.dispatch(CanvasResizeEvent, canvasEvent => {\n\t\t\tconst controllerData = <CameraControllerCP>this.getManager().getSingleton('Polar:CameraController');\n\t\t\tconst camera = (<CameraCP>this.getManager().getSingleton('Polar:Camera')).camera;\n\n\t\t\tlet aspectRatio = canvasEvent.width / canvasEvent.height;\n\t\t\tcamera.setProjection(-aspectRatio * controllerData.zoomLevel, aspectRatio * controllerData.zoomLevel, -controllerData.zoomLevel, controllerData.zoomLevel);\n\t\t\tthis.eventCallbackFn(new CameraTransformEvent());\n\t\t\treturn false;\n\t\t});\n\n\t\t// onMouseScroll\n\t\tdispatcher.dispatch(MouseWheelEvent, mouseEvent => {\n\t\t\tconst controllerData = <CameraControllerCP>this.getManager().getSingleton('Polar:CameraController');\n\t\t\tconst camera = (<CameraCP>this.getManager().getSingleton('Polar:Camera')).camera;\n\n\t\t\tlet aspectRatio = !controllerData.aspectRatio ? Surface.getWidth() / Surface.getHeight() : controllerData.aspectRatio;\n\n\t\t\tcontrollerData.zoomLevel += mouseEvent.deltaY / 1000 * controllerData.zoomLevel;\n\t\t\tcontrollerData.zoomLevel = controllerData.zoomLevel > 0.1 ? controllerData.zoomLevel : 0.1;\n\t\t\tcamera.setProjection(-aspectRatio * controllerData.zoomLevel, aspectRatio * controllerData.zoomLevel, -controllerData.zoomLevel, controllerData.zoomLevel);\n\t\t\tthis.eventCallbackFn(new CameraTransformEvent());\n\t\t\treturn false;\n\t\t});\n\t}\n\n\tpublic getComponentTuples(): string[][] {\n\t\treturn [];\n\t}\n\n\tpublic getName(): string {\n\t\treturn 'Polar:CameraControllerSystem';\n\t}\n\n\t/**\n\t * A sigmoid function to calculate The speed of the camera at the specified zoom.\n\t * @param {number} zoom The current zoom of the camera.\n\t * @returns {Camera} The speed of the camera in world units / second.\n\t */\n\tprivate cameraTranslationSpeed(zoom: number): number {\n\t\treturn 20 / (1 + 30 * Math.pow(Math.E, -0.4 * zoom));\n\t}\n}\n\nexport class CameraControllerCP extends Component {\n\n\tpublic readonly type = 'Polar:CameraController';\n\t/** The camera's aspect ratio. */\n\tpublic aspectRatio: number = 0;\n\t/** The camera's zoom. */\n\tpublic zoomLevel: number = 1;\n\t/** Whether the camera will rotate using Q and E. */\n\tpublic doRotation: boolean = false;\n\t/** The camera's position in world space. */\n\tpublic cameraPosition: glm.vec3 = glm.vec3.create();\n\t/** The camera's current rotation. */\n\tpublic cameraRotation: number = 0.0;\n\t/** How fast the camera rotates in radians per second. */\n\tpublic cameraRotationSpeed: number = Math.PI/2;\n\n\t/**\n\t * Create a new camera controller component.\n\t * @param {number} [aspectRatio=0] The aspect ratio of the camera. If 0, will use the canvas' aspect ratio.\n\t * @param {number} [zoomLevel=1] The initial zoom of the camera.\n\t * @param {boolean} [doRotation=false] Allows the camera to be rotated using the Q and E keys.\n\t * @param {glm.vec3} [cameraPosition=vec3.create()] The initial position of the camera.\n\t * @param {number} [cameraRotation=0.0] The initial rotation of the camera.\n\t * @param {number} [cameraRotationSpeed=Math.PI/2] The rotation speed of the camera in radians per second.\n\t */\n\tpublic constructor(aspectRatio: number = 0, zoomLevel: number = 1, doRotation: boolean = false, cameraPosition: glm.vec3 = glm.vec3.create(), cameraRotation: number = 0.0, cameraRotationSpeed: number = Math.PI/2) {\n\t\tsuper();\n\t\tthis.aspectRatio = aspectRatio;\n\t\tthis.zoomLevel = zoomLevel;\n\t\tthis.doRotation = doRotation;\n\t\tthis.cameraPosition = cameraPosition;\n\t\tthis.cameraRotation = cameraRotation;\n\t\tthis.cameraRotationSpeed = cameraRotationSpeed;\n\t}\n}\n\nexport class CameraTransformEvent extends Event {\n\n\tpublic constructor() {\n\t\tsuper();\n\t}\n\n\tpublic getEventType(): string {\n\t\treturn 'Polar:CameraTransformEvent';\n\t}\n\t\n\tpublic toString(): string {\n\t\treturn 'Polar:CameraTransformEvent';\n\t}\n}","import * as glm from 'gl-matrix';\nimport { System } from '../System';\nimport { Component} from '../Component';\nimport { Entity } from '../Entity';\nimport { Timer } from '../../Util/Timer';\nimport { Surface } from '../../Renderer/Surface';\nimport { Event } from '../../Events/Event';\n\nexport class FPSDebugSystem extends System {\n\n\tpublic onAttach(): void {\n\t\t// Setup FPS timer.\n\t\tconst systemData = <FPSDebugCP>this.getManager().getSingleton('Polar:FPSDebug');\n\t\tif (!systemData) {\n\t\t\tconsole.error('FPS Debug System requires FPSDebugCP singleton to store data.');\n\t\t}\n\t\tsystemData.timer = new Timer(1, false, true);\n\t\tsystemData.fps = 0;\n\t\tsystemData.numUpdates = 0;\n\t}\n\n\tpublic beginUpdate(dt: number): void {\n\t\t// Check FPS timer.\n\t\tconst systemData = <FPSDebugCP>this.getManager().getSingleton('Polar:FPSDebug');\n\t\tsystemData.numUpdates++;\n\t\tif (systemData.timer.update(dt)) {\n\t\t\tsystemData.fps = Math.round(systemData.numUpdates);\n\t\t\tsystemData.numUpdates = 0;\n\t\t}\n\t\t\n\t\t// Render current FPS.\n\t\tSurface.font.font = systemData.font;\n\t\tSurface.font.fillStyle = systemData.fillStyle;\n\t\tSurface.font.fillText(`FPS: ${systemData.fps}`, systemData.position[0], systemData.position[1]);\n\t}\n\t\n\tpublic onEntityUpdate(dt: number, entity: Entity, subIndex: number): void {}\n\tpublic endUpdate(dt: number): void {}\n\tpublic onEvent(event: Event): void {}\n\tpublic getComponentTuples(): string[][] { return []; }\n\tpublic getName(): string { return 'Polar:FPSDebugSystem'; }\n}\n\n/** Singleton component class used to store data about an FPS debug system. */\nexport class FPSDebugCP extends Component {\n\n\tpublic position: glm.vec2;\n\tpublic font: string;\n\tpublic fillStyle: string;\n\n\tpublic timer: Timer;\n\tpublic fps: number;\n\tpublic numUpdates: number;\n\n\t/**\n\t * Create a new FPS debug component.\n\t * @param {glm.vec2} [position=[10, 30]] The position which the FPS text will be rendered.\n\t * @param {string} [font='20px Arial'] The font.\n\t * @param {string} [fillStyle='red'] The fill style.\n\t */\n\tpublic constructor(position: glm.vec2 = glm.vec2.fromValues(10, 30), font: string = '20px Arial', fillStyle: string = 'red') {\n\t\tsuper();\n\t\tthis.position = position;\n\t\tthis.font = font;\n\t\tthis.fillStyle = fillStyle;\n\t}\n\n\tpublic readonly type = 'Polar:FPSDebug';\n}","import * as glm from 'gl-matrix';\nimport { System } from '../System';\nimport { Entity } from '../Entity';\nimport { Event } from '../../Events/Event';\nimport { LightRenderer } from '../../Renderer/LightRenderer';\nimport { Renderer } from '../../Renderer/Renderer';\nimport { TransformCP } from '../Components';\n\n/**\n * A system which renders lights in a scene.\n * \n * @system 'Polar:LightRenderSystem'\n * @tuples ['Polar:Transform', 'Polar:PointLight']\n */\nexport class LightRenderSystem extends System {\n\n\tpublic onAttach(): void {\n\t\tRenderer.enableLighting();\n\t}\n\t\n\tpublic onEntityUpdate(dt: number, entity: Entity, subIndex: number): void {\n\t\tconst lightData = <PointLightCP>entity.getComponent('Polar:PointLight');\n\t\tconst transformData = <TransformCP>entity.getComponent('Polar:Transform');\n\t\tLightRenderer.submitLight(lightData.color, lightData.intensity, transformData.transform);\n\t}\n\n\tpublic beginUpdate(dt: number): void {}\n\n\tpublic endUpdate(dt: number): void {}\n\n\tpublic onEvent(event: Event): void {}\n\n\tpublic getComponentTuples(): string[][] {\n\t\treturn [\n\t\t\t['Polar:Transform', 'Polar:PointLight']\n\t\t];\n\t}\n\n\tpublic getName(): string {\n\t\treturn 'Polar:LightRendererSystem';\n\t}\n}\n\n/** A component which stores information about a point light which illuminates a 2D scene. */\nexport class PointLightCP {\n\n\tpublic readonly type = 'Polar:PointLight';\n\n\t/** The color of the light. */\n\tpublic color: glm.vec3;\n\t/** The intensity of the light, from 0 to 1. If the value is raised above 1, the edges of the light will appear more bright and the center will not get brighter. */\n\tpublic intensity: number;\n\n\t/**\n\t * Copy a light from an existing one.\n\t * @param {glm.vec3} color The light's color.\n\t * @param {number} intensity How bright the light will appear, from 0 to 1. \n\t */\n\tpublic constructor(color: glm.vec3, intensity: number) {\n\t\tthis.color = color;\n\t\tthis.intensity = intensity;\n\t}\n}","import { ParticleEmitter } from '../../Renderer/ParticleEmitter';\nimport { System } from '../System';\nimport { Component} from '../Component';\nimport { Entity } from '../Entity';\nimport { ParticleRenderer } from '../../Renderer/ParticleRenderer';\nimport { CameraCP } from '../Components';\nimport { Event } from '../../Events/Event';\n\nexport class ParticleSystem extends System {\n\t\n\tpublic onAttach(): void {}\n\n\tpublic beginUpdate(dt: number): void {\n\t\tParticleRenderer.beginParticleScene((<CameraCP>this.getManager().getSingleton('Polar:Camera')).camera);\n\t}\n\t\n\tpublic onEntityUpdate(dt: number, entity: Entity, subIndex: number): void {\n\t\tParticleRenderer.renderParticleEmitter((<ParticleEmitterCP>entity.getComponent('Polar:ParticleEmitter')).emitter, dt);\n\t}\n\t\n\tpublic endUpdate(dt: number): void {\n\t\tParticleRenderer.endParticleScene();\n\t}\n\t\n\tpublic onEvent(event: Event): void {}\n\t\n\tpublic getComponentTuples(): string[][] {\n\t\treturn [['Polar:ParticleEmitter']];\n\t}\n\n\tpublic getName(): string { return 'Polar:ParticleSystem'; }\n}\n\nexport class ParticleEmitterCP extends Component {\n\t\n\tpublic readonly type = 'Polar:ParticleEmitter';\n\t/** The particle emitter. */\n\tpublic emitter: ParticleEmitter;\n\n\t/** Create a new particle emitter component.\n\t * @param {ParticleEmitter} emitter The emitter.\n\t */\n\tpublic constructor(emitter: ParticleEmitter) {\n\t\tsuper();\n\t\tthis.emitter = emitter;\n\t}\n\n}","import * as glm from 'gl-matrix';\nimport * as p2 from 'p2';\nimport { System } from '../System';\nimport { Component } from '../Component';\nimport { Entity } from '../Entity';\nimport { Renderer } from '../../Renderer/Renderer';\nimport { createTransform } from '../../Util/Math';\nimport { Input } from '../../Core/Input';\nimport { Event, EventDispatcher } from '../../Events/Event';\nimport { MouseDownEvent, MouseUpEvent, MouseMoveEvent } from '../../Events/MouseEvent';\nimport { CameraTransformEvent } from './CameraControllerSystem';\n\n/** A component which stores information about an entity's physics body. */\nexport class PhysicsBodyCP extends Component {\n\t\n\tpublic readonly type = 'Polar:PhysicsBody';\n\n\t/** The p2 body. */\n\tpublic body: p2.Body;\n\n\t/**\n\t * Create a p2 body component.\n\t * @param {p2.Body} body The p2 body.\n\t */\n\tpublic constructor(body: p2.Body) {\n\t\tsuper();\n\t\tthis.body = body;\n\t}\n}\n\n/** A singleton component which represents a p2 physics world. */\nexport class PhysicsWorldCP extends Component {\n\t\n\tpublic readonly type = 'Polar:PhysicsWorld';\n\n\tpublic world: p2.World;\n\n\t/**\n\t * Create a new physics world singleton component\n\t * @param {p2.WorldOptions} [settings] The world settings.\n\t */\n\tpublic constructor(settings?: p2.WorldOptions) {\n\t\tsuper();\n\t\tthis.world = new p2.World(settings);\n\t}\n}\n\n/** \n * A component which is required to attach a single texture to a p2 physics body. \n * \n * @component 'Polar:BodyTextureAttachment'\n*/\nexport class BodyTextureAttachmentCP {\n\n\tpublic readonly type = 'Polar:BodyTextureAttachment';\n\n\t/** How much the texture is translated in the x-axis compared to the body, in world units.*/\n\tpublic offsetX: number;\n\t/** How much the texture is translated in the y-axis compared to the body, in world units.*/\n\tpublic offsetY: number;\n\t/** The width of the texture in world units.*/\n\tpublic width: number;\n\t/** The height of the texture in world units.*/\n\tpublic height: number;\n\t/** How much the texture is rotated relative to the body in radians.*/\n\tpublic rotation: number;\n\n\t/**\n\t * Create a new body texture attachment component.\n\t * @param {number} offsetX How much the texture is translated in the x-axis compared to the body, in world units.\n\t * @param {number} offsetY How much the texture is translated in the y-axis compared to the body, in world units.\n\t * @param {number} width The width of the texture in world units.\n\t * @param {number} height The height of the texture in world units.\n\t * @param {number} rotation How much the texture is rotated relative to the body in radians.\n\t */\n\tpublic constructor(offsetX: number = 0, offsetY: number = 0, width: number = 1, height: number = 1, rotation: number = 0) {\n\t\tthis.offsetX = offsetX;\n\t\tthis.offsetY = offsetY;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.rotation = rotation;\n\t}\n}\n\n/** A system which manages a p2 physics world. */\nexport class PhysicsSystem extends System {\n\t\n\tpublic onAttach() {}\n\n\tpublic onDetach() {}\n\t\n\tpublic beginUpdate(dt: number) {\n\t\tconst systemData = <PhysicsWorldCP>this.getManager().getSingleton('Polar:PhysicsWorld');\n\t\tif (dt < 0.2) \n\t\t\tsystemData.world.step(dt, null, 3);\n\t}\n\t\n\tpublic onEntityUpdate(dt: number, entity: Entity, subIndex: number) {}\n\t\n\tpublic endUpdate(dt: number) {}\n\n\tpublic onEvent(event: Event): void {}\n\t\n\tpublic getComponentTuples(): string[][] { return []; }\n\n\tpublic getName(): string { return 'Polar:PhysicsSystem'; }\n}\n\n/** A system which renders debug outlines of physics bodies within the world. */\nexport class PhysicsDebugRenderSystem extends System {\n\tpublic onAttach(): void {}\n\t\n\tpublic onEntityUpdate(dt: number, entity: Entity, subIndex: number) {\n\t\tconst body = (<PhysicsBodyCP>entity.getComponent('Polar:PhysicsBody')).body;\n\t\t// Render shapes...\n\t\tfor (const shape of body.shapes) {\n\t\t\tif (shape.type == p2.Shape.BOX || shape.type == p2.Shape.CONVEX) {\n\t\t\t\tconst box = <p2.Box>shape;\n\t\t\t\tRenderer.submitColoredOutline(glm.vec4.fromValues(0.9, 0.1, 0.9, 1.0), \n\t\t\t\t\tcreateTransform(body.position[0] + box.position[0], body.position[1] + box.position[1], \n\t\t\t\t\t\tbody.angle + box.angle, box.width, box.height, 0));\n\t\t\t\t\n\t\t\t\tRenderer.submitLine(body.position[0] + box.position[0], body.position[1] + box.position[1],\n\t\t\t\t\tbody.position[0] + box.position[0] + box.width / 2 * Math.cos(body.angle + box.angle), \n\t\t\t\t\tbody.position[1] + box.position[1] + box.width / 2 * Math.sin(body.angle + box.angle), \n\t\t\t\t\tglm.vec4.fromValues(0.9, 0.1, 0.9, 1.0), 0.2);\n\t\t\t}\n\t\t\telse if (shape.type == p2.Shape.CIRCLE) {\n\t\t\t\tconst circle = <p2.Circle>shape;\n\t\t\t\tRenderer.submitCircle(body.position[0] + circle.position[0], body.position[1] + circle.position[1], circle.radius, glm.vec4.fromValues(0.9, 0.1, 0.9, 1.0));\n\t\t\t\tRenderer.submitLine(body.position[0] + circle.position[0], body.position[1] + circle.position[1], \n\t\t\t\t\tbody.position[0] + circle.position[0] + circle.radius * Math.cos(body.angle + circle.angle), \n\t\t\t\t\tbody.position[1] + circle.position[1] + circle.radius * Math.sin(body.angle + circle.angle),\n\t\t\t\t\tglm.vec4.fromValues(0.9, 0.1, 0.9, 1.0), 0.2);\n\t\t\t}\n\t\t\telse if (shape.type == p2.Shape.LINE) {\n\t\t\t\tconst line = <p2.Line>shape;\n\t\t\t\tRenderer.submitLine(line.position[0], line.position[1], \n\t\t\t\t\tline.position[0] + line.length * Math.cos(body.angle + line.angle), \n\t\t\t\t\tline.position[1] + line.length * Math.sin(body.angle + line.angle), \n\t\t\t\t\tglm.vec4.fromValues(0.9, 0.1, 0.9, 1.0), 0.2);\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\t\n\tpublic beginUpdate(dt: number) {}\n\t\n\tpublic endUpdate(dt: number) {}\n\n\tpublic onEvent(event: Event): void {}\n\t\n\tpublic getComponentTuples(): string[][] {\n\t\treturn [['Polar:PhysicsBody']];\n\t}\n\t\t\t\n\tpublic getName(): string {\n\t\treturn 'Polar:PhysicsDebugRendererSystem';\n\t}\n}\n\t\n/** A system which allows the user to click and drag physics bodies around the world. */\nexport class PhysicsDebugInteractionSystem extends System {\n\t\n\tpublic onAttach(): void {\n\t\t(<PhysicsDebugInteractionCP>this.getManager().getSingleton('Polar:PhysicsDebugInteraction')).nullBody = new p2.Body({mass: 0});\n\t\t(<PhysicsDebugInteractionCP>this.getManager().getSingleton('Polar:PhysicsDebugInteraction')).nullBody.collisionResponse = false;\n\t\t(<PhysicsWorldCP>this.getManager().getSingleton('Polar:PhysicsWorld')).world.islandSplit = false;\n\t}\n\t\n\tpublic onEntityUpdate(dt: number, entity: Entity, subIndex: number) {}\n\t\n\tpublic beginUpdate(dt: number) {}\n\n\tprivate checkQuadrant() {\n\t\tconst systemData = <PhysicsDebugInteractionCP>this.getManager().getSingleton('Polar:PhysicsDebugInteraction');\n\t\tlet quadrant: number;\n\t\tif ((systemData.nullBody.position[0]-systemData.currentBody.position[0])*Math.cos(systemData.currentBody.angle)+(systemData.nullBody.position[1]-systemData.currentBody.position[1])*Math.sin(systemData.currentBody.angle) >= 0) {\n\t\t\tif ((systemData.nullBody.position[1]-systemData.currentBody.position[1])*Math.cos(systemData.currentBody.angle)-(systemData.nullBody.position[0]-systemData.currentBody.position[0])*Math.sin(systemData.currentBody.angle) >= 0) {\n\t\t\t\tquadrant = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquadrant = 4;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((systemData.nullBody.position[1]-systemData.currentBody.position[1])*Math.cos(systemData.currentBody.angle)-(systemData.nullBody.position[0]-systemData.currentBody.position[0])*Math.sin(systemData.currentBody.angle) >= 0) {\n\t\t\t\tquadrant = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquadrant = 3;\n\t\t\t}\n\t\t}\n\t\treturn quadrant;\n\t}\n\t\n\tprivate calculateAngle(systemData: PhysicsDebugInteractionCP) {\n\t\tconst quadrant = this.checkQuadrant();\n\t\tlet angle: number;\n\t\t// check if mouse is up or down and left or right of the centre of the box at time of click\n\t\t// calculate angle of the click point relative to rotation of box\n\t\tif (systemData.nullBody.position[0] >= systemData.currentBody.position[0]) {\n\t\t\tif (systemData.nullBody.position[1] >= systemData.currentBody.position[1]) {\n\t\t\t\tif (quadrant == 1) {\n\t\t\t\t\tangle = Math.PI/2-systemData.currentBody.angle-Math.atan((systemData.nullBody.position[0]-systemData.currentBody.position[0])/(systemData.nullBody.position[1]-systemData.currentBody.position[1]));\n\t\t\t\t}\n\t\t\t\telse if (quadrant == 2) {\n\t\t\t\t\tangle = -systemData.currentBody.angle+Math.atan((systemData.nullBody.position[1]-systemData.currentBody.position[1])/(systemData.nullBody.position[0]-systemData.currentBody.position[0]));\n\t\t\t\t}\n\t\t\t\telse if (quadrant == 3) {\n\t\t\t\t\tangle = Math.PI/2-systemData.currentBody.angle-Math.atan((systemData.nullBody.position[0]-systemData.currentBody.position[0])/(systemData.nullBody.position[1]-systemData.currentBody.position[1]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tangle = -systemData.currentBody.angle+Math.atan((systemData.nullBody.position[1]-systemData.currentBody.position[1])/(systemData.nullBody.position[0]-systemData.currentBody.position[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (quadrant == 1) {\n\t\t\t\t\tangle = -Math.PI/2-systemData.currentBody.angle-Math.atan((systemData.nullBody.position[0]-systemData.currentBody.position[0])/(systemData.nullBody.position[1]-systemData.currentBody.position[1]));\n\t\t\t\t}\n\t\t\t\telse if (quadrant == 2) {\n\t\t\t\t\tangle = -systemData.currentBody.angle+Math.atan((systemData.nullBody.position[1]-systemData.currentBody.position[1])/(systemData.nullBody.position[0]-systemData.currentBody.position[0]));\n\t\t\t\t}\n\t\t\t\telse if (quadrant == 3) {\n\t\t\t\t\tangle = 3*Math.PI/2-systemData.currentBody.angle-Math.atan((systemData.nullBody.position[0]-systemData.currentBody.position[0])/(systemData.nullBody.position[1]-systemData.currentBody.position[1]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tangle = -systemData.currentBody.angle+Math.atan((systemData.nullBody.position[1]-systemData.currentBody.position[1])/(systemData.nullBody.position[0]-systemData.currentBody.position[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (systemData.nullBody.position[1] >= systemData.currentBody.position[1]) {\n\t\t\t\tif (quadrant == 1) {\n\t\t\t\t\tangle = Math.PI/2-systemData.currentBody.angle-Math.atan((systemData.nullBody.position[0]-systemData.currentBody.position[0])/(systemData.nullBody.position[1]-systemData.currentBody.position[1]));\n\t\t\t\t}\n\t\t\t\telse if (quadrant == 2) {\n\t\t\t\t\tangle = Math.PI-systemData.currentBody.angle+Math.atan((systemData.nullBody.position[1]-systemData.currentBody.position[1])/(systemData.nullBody.position[0]-systemData.currentBody.position[0]));\n\t\t\t\t}\n\t\t\t\telse if (quadrant == 3) {\n\t\t\t\t\tangle = Math.PI/2-systemData.currentBody.angle-Math.atan((systemData.nullBody.position[0]-systemData.currentBody.position[0])/(systemData.nullBody.position[1]-systemData.currentBody.position[1]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tangle = Math.PI-systemData.currentBody.angle+Math.atan((systemData.nullBody.position[1]-systemData.currentBody.position[1])/(systemData.nullBody.position[0]-systemData.currentBody.position[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (quadrant == 1) {\n\t\t\t\t\tangle = -Math.PI/2-systemData.currentBody.angle-Math.atan((systemData.nullBody.position[0]-systemData.currentBody.position[0])/(systemData.nullBody.position[1]-systemData.currentBody.position[1]));\n\t\t\t\t}\n\t\t\t\telse if (quadrant == 2) {\n\t\t\t\t\tangle = Math.PI-systemData.currentBody.angle+Math.atan((systemData.nullBody.position[1]-systemData.currentBody.position[1])/(systemData.nullBody.position[0]-systemData.currentBody.position[0]));\n\t\t\t\t}\n\t\t\t\telse if (quadrant == 3) {\n\t\t\t\t\tangle = 3*Math.PI/2-systemData.currentBody.angle-Math.atan((systemData.nullBody.position[0]-systemData.currentBody.position[0])/(systemData.nullBody.position[1]-systemData.currentBody.position[1]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tangle = Math.PI-systemData.currentBody.angle+Math.atan((systemData.nullBody.position[1]-systemData.currentBody.position[1])/(systemData.nullBody.position[0]-systemData.currentBody.position[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn angle;\n\t}\n\t\n\tpublic endUpdate(dt: number) {\n\t\tconst systemData = <PhysicsDebugInteractionCP>this.getManager().getSingleton('Polar:PhysicsDebugInteraction');\n\t\tif (systemData.doClick) \n\t\t\tthis.startClick();\n\n\t\t// RENDER DEBUG LINES //\n\t\tif (systemData.doDebugRendering && Input.isMouseButtonPressed(0) && systemData.nullBody && systemData.currentBody) {\n\t\t\tRenderer.submitLine(systemData.nullBody.position[0], \n\t\t\t\tsystemData.nullBody.position[1], \n\t\t\t\tsystemData.currentBody.position[0]+systemData.lineMagnitude*Math.cos(systemData.lineAngle+systemData.currentBody.angle), \n\t\t\t\tsystemData.currentBody.position[1]+systemData.lineMagnitude*Math.sin(systemData.lineAngle+systemData.currentBody.angle), \n\t\t\t\tglm.vec4.fromValues(0.9, 0.9, 0.9, 0.9), 0.2);\n\t\t}\n\t}\n\n\tpublic onEvent(event: Event): void {\n\t\tconst dispatcher = new EventDispatcher(event);\n\t\t// onMouseDown\n\t\tdispatcher.dispatch(MouseDownEvent, mouseEvent => {\n\t\t\tif (mouseEvent.button === 0) {\n\t\t\t\t(<PhysicsDebugInteractionCP>this.getManager().getSingleton('Polar:PhysicsDebugInteraction')).doClick = true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\n\t\t// onMouseUp\n\t\tdispatcher.dispatch(MouseUpEvent, mouseEvent => {\n\t\t\tif (mouseEvent.button === 0) {\n\t\t\t\tconst info = <PhysicsDebugInteractionCP>this.getManager().getSingleton('Polar:PhysicsDebugInteraction');\n\t\t\t\tconst world = (<PhysicsWorldCP>this.getManager().getSingleton('Polar:PhysicsWorld')).world;\n\t\t\t\tworld.removeConstraint(info.constraint);\n\t\t\t\tinfo.constraint = null;\n\t\t\t\tinfo.currentBody = null;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\n\t\t// onMouseMove\n\t\tdispatcher.dispatch(MouseMoveEvent, _ => {\n\t\t\tthis.updatePosition();\n\t\t\treturn false;\n\t\t});\n\n\t\t// onCameraTransform\n\t\tdispatcher.dispatch(CameraTransformEvent, _ => {\n\t\t\tthis.updatePosition();\n\t\t\treturn false;\n\t\t});\n\t}\n\t\n\tpublic getComponentTuples(): string[][] {\n\t\treturn [['Polar:PhysicsBody']];\n\t}\n\t\n\tpublic getName(): string {\n\t\treturn 'Polar:PhysicsDebugInteractionSystem';\n\t}\n\t\n\tprivate startClick() {\n\t\t(<PhysicsDebugInteractionCP>this.getManager().getSingleton('Polar:PhysicsDebugInteraction')).doClick = false;\n\n\t\tconst systemData = <PhysicsDebugInteractionCP>this.getManager().getSingleton('Polar:PhysicsDebugInteraction');\n\t\tconst world = (<PhysicsWorldCP>this.getManager().getSingleton('Polar:PhysicsWorld')).world;\n\t\tsystemData.constraint = null;\n\t\tsystemData.currentBody = null;\n\t\t\n\t\tconst position = Renderer.screenToWorldPosition(Input.getMousePosition());\n\t\tsystemData.nullBody.position = [position[0], position[1]];\n\n\t\tfor (const body of world.bodies) {\n\t\t\tif (body.aabb.containsPoint(systemData.nullBody.position) && body.mass < 1e308) {\n\t\t\t\tsystemData.currentBody = body;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (systemData.currentBody) {\n\t\t\tsystemData.constraint = new p2.RevoluteConstraint(systemData.nullBody, systemData.currentBody, { worldPivot: [position[0], position[1]], collideConnected: false });\n\t\t\tsystemData.constraint.setRelaxation(10);\n\t\t\tsystemData.constraint.setStiffness(50 * systemData.currentBody.mass);\n\n\t\t\tsystemData.lineAngle = this.calculateAngle(systemData);\n\t\t\tsystemData.lineMagnitude = Math.sqrt(Math.pow(systemData.nullBody.position[0]-systemData.currentBody.position[0], 2)+Math.pow(systemData.nullBody.position[1]-systemData.currentBody.position[1], 2));\n\t\t\t\n\t\t\tworld.addConstraint(systemData.constraint);\n\t\t}\n\t}\n\n\tprivate updatePosition() {\n\t\tif (Input.isMouseButtonPressed(0)) {\n\t\t\tconst position = Renderer.screenToWorldPosition(Input.getMousePosition());\n\t\t\tconst info = <PhysicsDebugInteractionCP>this.getManager().getSingleton('Polar:PhysicsDebugInteraction');\n\t\t\tinfo.nullBody.position = [position[0], position[1]];\n\t\t}\n\t}\n}\n\n/** A singleton component which stores information for a PhysicsDebugInteractionSystem class. */\nexport class PhysicsDebugInteractionCP extends Component {\n\n\tpublic readonly type = 'Polar:PhysicsDebugInteraction';\n\t\n\t/** The current selected body. */\n\tpublic currentBody: p2.Body;\n\t/** The empty body which the mouse constraint is attached to. */\n\tpublic nullBody: p2.Body;\n\t/** The constraint which pulls the selected object towards the mouse. */\n\tpublic constraint: p2.RevoluteConstraint;\n\t/** Whether a click has been started.  */\n\tpublic doClick: boolean;\n\t/** Whether the system will render a line representing the constraint. */\n\tpublic doDebugRendering: boolean;\n\t/** The line's current angle. */\n\tpublic lineAngle: number;\n\t/** The line's current magnitude. */\n\tpublic lineMagnitude: number;\n\n\t/**\n\t * Create a new Physics Debug Interaction Component.\n\t * @param {boolean} doDebugRender Whether the system will do debug rendering.\n\t */\n\tpublic constructor(doDebugRendering: boolean = false) {\n\t\tsuper();\n\t\tthis.doDebugRendering = doDebugRendering;\n\t}\n}","import * as glm from 'gl-matrix';\nimport { System } from '../System';\nimport { Entity } from '../Entity';\nimport { Component } from '../Component';\nimport { TextureRefCP, TextureLibraryCP } from '../Systems/TextureLoad';\nimport { Renderer } from '../../Renderer/Renderer';\nimport { Texture2DCP, TransformCP, CameraCP } from '../Components';\nimport { PhysicsBodyCP, BodyTextureAttachmentCP } from './Physics';\nimport { createTransform } from '../../Util/Math';\nimport { Event } from '../../Events/Event';\n\n/** System which renders entities.\n * \n * @system 'Polar:RenderSystem'\n * @tuples ['Polar:Transform', 'Polar:Texture2D'], ['Polar:PhysicsBody', 'Polar:Texture2D'], ['Polar:Transform', 'Polar:TextureRef'], ['Polar:PhysicsBody', 'Polar:TextureRef'], ['Polar:Transform', 'Polar:Outline']\n */\nexport class RenderSystem extends System {\n\t\n\tpublic onAttach(): void {}\n\t\n\tpublic getComponentTuples(): string[][] {\n\t\treturn [\n\t\t\t['Polar:Transform', 'Polar:Texture2D'],\n\t\t\t['Polar:PhysicsBody', 'Polar:BodyTextureAttachment', 'Polar:Texture2D'],\n\t\t\t['Polar:Transform', 'Polar:TextureRef'],\n\t\t\t['Polar:PhysicsBody', 'Polar:BodyTextureAttachment', 'Polar:TextureRef'],\n\t\t\t['Polar:Transform', 'Polar:Outline']\n\t\t];\n\t}\n\t\n\tpublic getName(): string {\n\t\treturn 'Polar:RenderSystem';\n\t}\n\t\n\tpublic onEntityUpdate(dt: number, entity: Entity, subIndex: number): void {\n\t\t// Render sprites with Texture2D component.\n\t\tif (subIndex == 0) {\n\t\t\tRenderer.submitTextured((<Texture2DCP>entity.getComponent('Polar:Texture2D')).texture, (<TransformCP>entity.getComponent('Polar:Transform')).transform);\n\t\t}\n\t\t// Render physics bodies with Texture2D component.\n\t\telse if (subIndex == 1) {\n\t\t\tconst body = (<PhysicsBodyCP>entity.getComponent('Polar:PhysicsBody')).body;\n\t\t\tconst texture = <Texture2DCP>entity.getComponent('Polar:Texture2D');\n\t\t\tconst textureAttachment = <BodyTextureAttachmentCP>entity.getComponent('Polar:BodyTextureAttachment');\n\t\t\tconst sin = Math.sin(body.angle);\n\t\t\tconst cos = Math.cos(body.angle);\n\t\t\tRenderer.submitTextured(texture.texture, createTransform(\n\t\t\t\tbody.position[0] + cos * textureAttachment.offsetX - sin * textureAttachment.offsetY, \n\t\t\t\tbody.position[1] + sin * textureAttachment.offsetX + cos * textureAttachment.offsetY, \n\t\t\t\tbody.angle + textureAttachment.rotation,\n\t\t\t\ttextureAttachment.width, \n\t\t\t\ttextureAttachment.height\n\t\t\t));\n\t\t}\n\t\t// Render sprites with TextureRef component.\n\t\telse if (subIndex == 2) {\n\t\t\tconst textureCP = <TextureRefCP>entity.getComponent('Polar:TextureRef');\n\t\t\tconst textureLibCP = <TextureLibraryCP>this.getManager().getSingleton('Polar:TextureLibrary');\n\t\t\tRenderer.submitTextured(textureLibCP.library.get(textureCP.alias), (<TransformCP>entity.getComponent('Polar:Transform')).transform);\n\t\t}\n\t\t// Render physics bodies with TextureRef component.\n\t\telse if (subIndex == 3) {\n\t\t\tconst body = (<PhysicsBodyCP>entity.getComponent('Polar:PhysicsBody')).body;\n\t\t\tconst textureCP = <TextureRefCP>entity.getComponent('Polar:TextureRef');\n\t\t\tconst textureLibCP = <TextureLibraryCP>this.getManager().getSingleton('Polar:TextureLibrary');\n\t\t\tconst textureAttachment = <BodyTextureAttachmentCP>entity.getComponent('Polar:BodyTextureAttachment');\n\t\t\tconst texture = textureLibCP.library.get(textureCP.alias);\n\t\t\tconst sin = Math.sin(body.angle);\n\t\t\tconst cos = Math.cos(body.angle);\n\t\t\tRenderer.submitTextured(texture, createTransform(\n\t\t\t\tbody.position[0] + cos * textureAttachment.offsetX - sin * textureAttachment.offsetY, \n\t\t\t\tbody.position[1] + sin * textureAttachment.offsetX + cos * textureAttachment.offsetY, \n\t\t\t\tbody.angle + textureAttachment.rotation,\n\t\t\t\ttextureAttachment.width, \n\t\t\t\ttextureAttachment.height\n\t\t\t));\n\t\t}\n\t\t// Render outline.\n\t\telse if (subIndex == 4) {\n\t\t\tconst transform = (<TransformCP>entity.getComponent('Polar:Transform')).transform;\n\t\t\tconst color = (<OutlineCP>entity.getComponent('Polar:Outline')).color;\n\t\t\tRenderer.submitColoredOutline(color, transform);\n\t\t}\n\t}\n\t\n\tpublic beginUpdate(dt: number): void {\n\t\tRenderer.beginScene((<CameraCP>this.getManager().getSingleton('Polar:Camera')).camera);\n\t}\n\t\n\tpublic endUpdate(dt: number): void {\n\t\tRenderer.endScene();\n\t}\n\t\n\tpublic onEvent(event: Event): void {}\n}\n\n/**\n * Stores data about an entities outline. Entities with this component and a transform component will have a square outline rendered around them.\n * @component\n */\nexport class OutlineCP extends Component {\n\tpublic readonly type = 'Polar:Outline';\n\t/** The outline color. */\n\tpublic color: glm.vec4;\n\n\t/**\n\t * Create a new outline component.\n\t * @param {glm.vec4} [color=glm.vec4.fromValues(1, 0, 0, 1)] The outline color.\n\t */\n\tpublic constructor(color: glm.vec4 = glm.vec4.fromValues(1, 0, 0, 1)) {\n\t\tsuper();\n\t\tthis.color = color;\n\t}\n}","import { System } from '../System';\nimport { Component } from '../Component';\nimport { Entity } from '../Entity';\nimport { TextureLibrary } from '../../Renderer/TextureLibrary';\nimport { Event } from '../../Events/Event';\n\n/** A system which loads and allows textures to be accessed using aliases within the entity component system. */\nexport class TextureLoadSystem extends System {\n\t\n\tpublic onAttach(): void {\n\t\tlet component = <TextureLibraryCP>this.getManager().getSingleton('Polar:TextureLibrary');\n\t\tcomponent.library = new TextureLibrary();\n\t\tcomponent.library.loadManyFromPath(component.texturePaths);\n\t}\n\t\n\tpublic onEntityUpdate(dt: number, entity: Entity, subIndex: number): void {}\n\t\n\tpublic beginUpdate(dt: number): void {}\n\t\n\tpublic endUpdate(dt: number): void {}\n\t\n\tpublic onEvent(event: Event): void {}\n\n\tpublic getComponentTuples(): string[][] {\n\t\treturn [];\n\t}\n\n\tpublic getName(): string {\n\t\treturn 'Polar:TextureLoadSystem';\n\t}\n}\n\n/** A singleton component used to store a number of textures for the TextureLoadSystem. */\nexport class TextureLibraryCP extends Component {\n\n\tpublic readonly type = 'Polar:TextureLibrary';\n\tpublic library: TextureLibrary;\n\t/** An array of alias/path pairs to be loaded on TextureLoadSystem.onAttach(). */\n\tpublic texturePaths: [string, string][] = [];\n\n\tpublic constructor(texturePaths: [string, string][]) {\n\t\tsuper();\n\t\tthis.texturePaths = texturePaths;\n\t}\n}\n\nexport class TextureRefCP extends Component {\n\tpublic readonly type = 'Polar:TextureRef';\n\t/** The alias of the texture within the texture library. */\n\tpublic alias: string;\n\n\t/**\n\t * Create a new texture reference component.\n\t * @param {string} alias The alias of the texture within the texture library.\n\t */\n\tpublic constructor(alias: string) {\n\t\tsuper();\n\t\tthis.alias = alias;\n\t}\n}","import { System } from '../System';\nimport { Entity } from '../Entity';\nimport { TransformCP } from '../Components';\nimport { createTransform } from '../../Util/Math';\nimport { Event } from '../../Events/Event';\n\nexport class TransformSystem extends System {\n\t\n\tpublic onAttach(): void {}\n\n\tpublic beginUpdate(deltaTime: number): void {}\n\t\n\tpublic onEntityUpdate(dt: number, entity: Entity, subIndex: number): void {\n\t\tlet transform = <TransformCP>entity.getComponent('Polar:Transform');\n\t\tif (transform.modified) {\n\t\t\ttransform.transform = createTransform(\n\t\t\t\ttransform.x, \n\t\t\t\ttransform.y, \n\t\t\t\ttransform.rotation,\n\t\t\t\ttransform.scaleX,\n\t\t\t\ttransform.scaleY, \n\t\t\t\t0.0\n\t\t\t);\n\t\t}\n\t}\n\t\n\tpublic endUpdate(dt: number): void {}\n\t\n\tpublic onEvent(event: Event): void {}\n\n\tpublic getComponentTuples(): string[][] {\n\t\treturn [['Polar:Transform']];\n\t}\n\n\tpublic getName(): string {\n\t\treturn 'Polar:TransformSystem';\n\t}\n}","import { System } from './System';\nimport { Entity } from './Entity';\nimport { Component } from './Component';\nimport { ECSState, ECSLoader, EntityTemplate } from './ECSState';\nimport { Event, EventHandler, EventCreator } from 'Polar/Events/Event';\n\n/** Controls and manages the entity component system of a world. */\nexport class WorldManager implements EventHandler, EventCreator {\n\tprivate systems: System[];\n\t\n\tprivate entities: Map<number, Entity>;\n\tprivate entityCount: number;\n\t\n\tprivate singletons: Entity;\n\t\n\teventCallbackFn: (event: Event) => void;\n\t\n\t/** Create a new world manager. */\n\tpublic constructor(eventCallbackFn: (event: Event) => void, state?: ECSState) {\n\t\t\n\t\tif (!eventCallbackFn)\n\t\t\tconsole.error('No event callback function specified. If this is being called from a layer, input this.eventCallbackFn.');\n\t\tthis.eventCallbackFn = eventCallbackFn;\n\n\t\tthis.entityCount = 0;\n\t\tthis.entities = new Map<number, Entity>();\n\t\tthis.systems = [];\n\t\tif(state) {\n\t\t\t// Load singletons.\n\t\t\tthis.singletons = new Entity(-1);\n\t\t\tfor (let component of state.singletons.components) {\n\t\t\t\tthis.singletons.addComponent(component);\n\t\t\t}\n\t\t\t\n\t\t\t// Load systems.\n\t\t\tfor (let system of ECSLoader.getSystems(state)) {\n\t\t\t\tthis.addSystem(system);\n\t\t\t}\n\t\t\t\n\t\t\t// Load entities.\n\t\t\tfor (let template of state.entities) {\n\t\t\t\tlet entity = this.createEntity();\n\t\t\t\tfor (let component of template.components) {\n\t\t\t\t\tentity.addComponent(component);\n\t\t\t\t}\n\t\t\t\tthis.registerComponents(entity);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.singletons = new Entity(-1);\n\t\t}\n\t}\n\n\t/**\n\t * To be called every frame.\n\t * @param {number} dt The time elapsed since the last frame in seconds.\n\t */\n\tpublic onUpdate(dt: number) {\n\t\tfor (const system of this.systems) {\n\t\t\tsystem.beginUpdate(dt);\n\t\t}\n\t\tfor (const system of this.systems) {\n\t\t\tfor (const [eid, subIndex] of system.subscribers) {\n\t\t\t\tsystem.onEntityUpdate(dt, this.entities.get(eid), subIndex);\n\t\t\t}\n\t\t}\n\t\tfor (const system of this.systems) {\n\t\t\tsystem.endUpdate(dt);\n\t\t}\n\t}\n\n\t/**\n\t * Propagates an event to all the world manager systems. To be called in Layer.onEvent(...).\n\t * @param {Event} event The event.\n\t */\n\tpublic onEvent(event: Event) {\n\t\tfor (const system of this.systems) {\n\t\t\tsystem.onEvent(event);\n\t\t}\n\t}\n\t\n\t/**\n\t * Add a system to the world.\n\t * @param {System} system The system to be added.\n\t */\n\tpublic addSystem(system: System) {\n\t\tsystem.getManager = () => { return this; };\n\t\tsystem.eventCallbackFn = this.eventCallbackFn;\n\t\tthis.systems.push(system);\n\t\tsystem.onAttach();\n\t}\n\n\t/**\n\t * Remove a system through its name.\n\t * @param {string} name The name of the system, the overridden return value of System.getName().\n\t */\n\tpublic removeSystemByName(name: string) {\n\t\tfor (let i = this.systems.length - 1; i >= 0; i--) {\n\t\t\tif (this.systems[i].getName() == name) {\n\t\t\t\tthis.systems[i].onDetach();\n\t\t\t\tthis.systems.splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get an entity from the manager using its ID.\n\t * @param {number} id The ID of the entity.\n\t * @returns {Entity} The entity.\n\t */\n\tpublic getEntityById(id: number): Entity {\n\t\treturn this.entities.get(id);\n\t}\n\t\n\t/**\n\t * Add an empty entity to the world.\n\t * @returns {Entity} The entity which was added.\n\t */\n\tpublic createEntity(): Entity {\n\t\tlet eid = this.entityCount++;\n\t\tlet entity = new Entity(eid);\n\t\tthis.entities.set(eid, entity);\n\t\treturn entity;\n\t}\n\n\t/**\n\t * Removes an entity by its ID.\n\t * @param {number} eid The entity's ID.\n\t * @returns {boolean} Whether the entity existed and was removed.\n\t */\n\tpublic removeEntityById(eid: number): boolean {\n\t\tthis.removeEntitySubscriptions(eid);\n\t\treturn this.entities.delete(eid);\n\t}\n\n\t/**\n\t * Recalculates the systems which are subscribed to this entity.\n\t * @param {Entity} entity The entity to be subscribed to the appropriate systems.\n\t */\n\tpublic registerComponents(entity: Entity) {\n\t\tfor (const system of this.systems) {\n\t\t\t// If the system already has the entity subscribed, continue.\n\t\t\tif (system.subscribers.has(entity.id)) {\n\t\t\t\tconsole.log(`eid ${entity.id} is already a subscriber of system ${system.getName()}`);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Check if the entity is subscribed to this system.\n\t\t\tlet systemAdded = false;\n\t\t\tconst tuples = system.getComponentTuples();\n\t\t\tfor (let i = 0; i < tuples.length; i++) {\n\t\t\t\tif( tuples[i].every(val => Array.from(entity.components.keys()).includes(val))) {\n\t\t\t\t\tif (!system.subscribers.has(entity.id)) {\n\t\t\t\t\t\tsystem.subscribers.set(entity.id, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (systemAdded)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes the entity from all system subscriptions.\n\t * Stops the entity from being updated.\n\t * @param {number} eid The entity's ID.\n\t */\n\tpublic removeEntitySubscriptions(eid: number) {\n\t\t// Remove the system subscribers.\n\t\tfor (const system of this.systems) {\n\t\t\tsystem.subscribers.delete(eid);\n\t\t}\n\t}\n\n\t/**\n\t * Recalculates all entity subscribers.\n\t * High performance cost - use sparingly.\n\t * To be used if a new system is added after the entities, or for debug.\n\t */\n\tpublic recalculateAllSubscribers() {\n\t\t// Clear all current subscribers.\n\t\tfor (const system of this.systems)\n\t\t\tsystem.subscribers.clear();\n\t\t\n\t\t// Add all current entity subscriptions.\n\t\tfor (const entity of this.entities.values())\n\t\t\tthis.registerComponents(entity);\n\t}\n\n\t/**\n\t * Get a singleton component from the manager.\n\t * @param {string} componentId The component's id, eg 'Polar:CameraController'.\n\t * @returns {Component} The singleton component.\n\t */\n\tpublic getSingleton(componentId: string): Component {\n\t\treturn this.singletons.getComponent(componentId);\n\t}\n\n\t/**\n\t * Add a singleton component to the ECS manager.\n\t * @param {Component} component The component to add.\n\t */\n\tpublic addSingleton(component: Component) {\n\t\tthis.singletons.addComponent(component);\n\t}\n\n\tpublic exportState(): ECSState {\n\t\tlet systemNames: string[] = [];\n\t\tfor (let system of this.systems.values()) {\n\t\t\tsystemNames.push(system.getName());\n\t\t}\n\n\t\tlet entityTemplates: EntityTemplate[] = [];\n\t\tfor (let entity of this.entities.values()) {\n\t\t\tentityTemplates.push(new EntityTemplate(entity.id, Array.from(entity.components.values())));\n\t\t}\n\n\t\tlet singletons = new EntityTemplate(this.singletons.id, Array.from(this.singletons.components.values()));\n\n\t\treturn new ECSState(systemNames, entityTemplates, singletons);\n\t}\n}","import { Event } from './Event';\n\nexport class CanvasResizeEvent extends Event {\n\n\tpublic readonly width: number;\n\tpublic readonly height: number;\n\n\tconstructor(width: number, height: number) {\n\t\tsuper();\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t}\n\n\tpublic getEventType(): string {\n\t\treturn 'Polar:CanvasResizeEvent';\n\t}\n\t\n\tpublic toString(): string {\n\t\treturn `Polar:CanvasResizeEvent - width: ${this.width}, height: ${this.height}`;\n\t}\n}\n\nexport class CanvasFocusEvent extends Event {\n\t\n\tpublic getEventType(): string {\n\t\treturn 'Polar:CanvasFocusEvent';\n\t}\n\t\n\tpublic toString(): string {\n\t\treturn 'Polar:CanvasFocusEvent';\n\t}\n}\n\nexport class CanvasUnfocusEvent extends Event {\n\t\n\tpublic getEventType(): string {\n\t\treturn 'Polar:CanvasUnfocusEvent';\n\t}\n\t\n\tpublic toString(): string {\n\t\treturn 'Polar:CanvasUnfocusEvent';\n\t}\n}","\nexport abstract class Event {\n\t/**\n\t * Whether the event has been handled by a layer. \n\t * \n\t * This value is set to the return value of Layer.onEvent(...).\n\t * \n\t * When this value is set to true, the below layers will not get the event.\n\t */\n\tpublic handled: boolean;\n\n\t/**\n\t * Returns the event's type.\n\t * \n\t * It is recommended that subclasses use the format '<Namespace>:<ClassName>' to avoid duplicates and confusion.\n\t * \n\t * @returns {string} The event type.\n\t */\n\tpublic abstract getEventType(): string;\n\n\t/**\n\t * Get event information as a string.\n\t * @returns {string} The event as a string.\n\t */\n\tpublic abstract toString(): string;\n}\n\nexport class EventDispatcher {\n\n\tprivate event: Event;\n\n\t/**\n\t * Create a new event dispatcher.\n\t * @param {Event} event The event to be dispatched. \n\t */\n\tpublic constructor(event: Event) {\n\t\tthis.event = event;\n\t}\n\n\t/**\n\t * Dispatch an event to a function which handles it.\n\t * @param {new (...args: any[]) => T} t The event class, eg Polar.MouseMoveEvent.\n\t * @param {(event: T) => boolean} func The event callback function. This will only be run for events with the specified type. Return false to allow this event to continue down the layer stack. Return true to block the event from travelling down the layer stack.\n\t * @returns {boolean} Whether the event was of the specified type.\n\t */\n\tpublic dispatch<T extends Event>(t: new (...args: any[]) => T, func: (event: T) => boolean): boolean {\n\t\tif (this.event.getEventType() === (new t()).getEventType()) {\n\t\t\tthis.event.handled = func(<T>this.event);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\n/** A class which is able to handle events with an onEvent function. */\nexport interface EventHandler {\n\t/**\n\t * Called on the occurrence of an event. \n\t * @param {Event} event The event.\n\t */\n \tonEvent(event: Event): void;\n}\n\nexport interface EventCreator {\n\t/**\n\t * Call this to send an event to the application.\n\t */\n\teventCallbackFn: (event: Event) => void;\n}","import { Event } from './Event';\n\nexport abstract class KeyEvent extends Event {\n\n\tpublic constructor() {\n\t\tsuper();\n\t}\n\n\tpublic getKeyCode(): string {\n\t\treturn this.key;\n\t}\n\n\tprotected key: string;\n}\n\nexport class KeyDownEvent extends KeyEvent {\n\n\tpublic constructor(keycode: string) {\n\t\tsuper();\n\t\tthis.key = keycode;\n\t}\n\t\n\tpublic getEventType(): string {\n\t\treturn 'Polar:KeyPressedEvent';\n\t}\n\t\n\tpublic toString(): string {\n\t\treturn `Polar:KeyPressedEvent - keycode: ${this.key}`;\n\t}\n}\n\nexport class KeyUpEvent extends KeyEvent {\n\n\tpublic constructor(keycode: string) {\n\t\tsuper();\n\t\tthis.key = keycode;\n\t}\n\n\tpublic getEventType(): string {\n\t\treturn 'Polar:KeyUpEvent';\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Polar:KeyUpEvent - keycode: ${this.key}`;\n\t}\n}","import { Event } from './Event';\n\nexport abstract class MouseEvent extends Event {\n\tpublic readonly mouseX: number;\n\tpublic readonly mouseY: number;\n\n\tpublic constructor(mouseX: number, mouseY: number) {\n\t\tsuper();\n\t\tthis.mouseX = mouseX;\n\t\tthis.mouseY = mouseY;\n\t}\n}\n\nexport class MouseMoveEvent extends MouseEvent {\n\n\tpublic constructor(mouseX: number, mouseY: number) {\n\t\tsuper(mouseX, mouseY);\n\t}\n\n\tpublic getEventType(): string {\n\t\treturn 'Polar:MouseMoveEvent';\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Polar:MouseMoveEvent - x: ${this.mouseX}, y: ${this.mouseY}`;\n\t}\n}\n\nexport class MouseWheelEvent extends MouseEvent {\n\tpublic readonly deltaX: number;\n\tpublic readonly deltaY: number;\n\n\tpublic constructor(mouseX: number, mouseY: number, deltaX: number, deltaY: number) {\n\t\tsuper(mouseX, mouseY);\n\t\tthis.deltaX = deltaX;\n\t\tthis.deltaY = deltaY;\n\t}\n\n\tpublic getEventType(): string {\n\t\treturn 'Polar:MouseWheelEvent';\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Polar:MouseWheelEvent - offset (${this.deltaX}, ${this.deltaY}), position: (${this.mouseX}, ${this.mouseY})`;\n\t}\n}\n\nexport class MouseDownEvent extends MouseEvent {\n\n\tpublic readonly button: number;\n\n\tpublic constructor(mouseX: number, mouseY: number, button: number) {\n\t\tsuper(mouseX, mouseY);\n\t\tthis.button = button;\n\t}\n\n\tpublic getEventType(): string {\n\t\treturn 'Polar:MouseDownEvent';\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Polar:MouseDownEvent - mouse button: ${this.button}, position: (${this.mouseX}, ${this.mouseY})`;\n\t}\n}\n\nexport class MouseUpEvent extends MouseEvent {\n\n\tpublic readonly button: number;\n\n\tpublic constructor(mouseX: number, mouseY: number, button: number) {\n\t\tsuper(mouseX, mouseY);\n\t\tthis.button = button;\n\t}\n\n\tpublic getEventType(): string {\n\t\treturn 'Polar:MouseUpEvent';\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Polar:MouseUpEvent - mouse button: ${this.button}, position: (${this.mouseX}, ${this.mouseY})`;\n\t}\n}","import { Surface } from './Surface';\n\n/** Enum which represents the possible shader data types. */\nexport enum ShaderDataType {\n\tNone = 0, Float, Float2, Float3, Float4, Mat3, Mat4, Int, Int2, Int3, Int4, Bool, FloatArray\n}\n\n/** Get the size of a shader data type.\n * @param {ShaderDataType} type The type.\n * @returns {number} The size.\n */\nexport function shaderDataTypeSizes(type: ShaderDataType): number {\n\tswitch (type) {\n\tcase ShaderDataType.Float:  return 4;\n\tcase ShaderDataType.Float2: return 4 * 2;\n\tcase ShaderDataType.Float3: return 4 * 3;\n\tcase ShaderDataType.Float4: return 4 * 4;\n\tcase ShaderDataType.Mat3:   return 4 * 3 * 3;\n\tcase ShaderDataType.Mat4:   return 4 * 4 * 4;\n\tcase ShaderDataType.Int:    return 4;\n\tcase ShaderDataType.Int2:   return 4 * 2;\n\tcase ShaderDataType.Int3:   return 4 * 3;\n\tcase ShaderDataType.Int4:   return 4 * 4;\n\tcase ShaderDataType.Bool:   return 1;\n\tcase ShaderDataType.FloatArray: throw new Error('FloatArray cannot be an attribute!');\n\t}\n}\n\n/** Represents a buffer element within a layout. */\nexport class BufferElement\n{\n\t/** The attribute name.*/\n\tpublic name: string;\n\t/** The attribute type.*/\n\tpublic type: ShaderDataType;\n\t/** The attribute size.*/\n\tpublic size: number;\n\t/** The attribute offset.*/\n\tpublic offset: number;\n\t/** Whether the attribute is normalized.*/\n\tpublic normalized: boolean;\n\t/** The attribute divisor.*/\n\tpublic divisor: number;\n\t/** The attribute location.*/\n\tpublic location: number;\n\n\t/** Create a new buffer element\n\t * @param {ShaderDataType} type The data type.\n\t * @param {string} name The attribute name.\n\t * @param {boolean} [normalized=false]\n\t */\n\tpublic constructor(type: ShaderDataType, name: string, normalized: boolean = false, divisor: number = -1, location: number = -1) {\n\t\tthis.type = type;\n\t\tthis.name = name;\n\t\tthis.size = shaderDataTypeSizes(type);\n\t\tthis.offset = 0;\n\t\tthis.normalized = normalized;\n\t\tthis.divisor = divisor;\n\t\tthis.location = location;\n\t}\n\n\t/** Get the element's component count.\n\t * @returns {number}\n\t */\n\tpublic getComponentCount(): number {\n\t\tswitch (this.type) {\n\t\tcase ShaderDataType.Float:  return 1;\n\t\tcase ShaderDataType.Float2: return 2;\n\t\tcase ShaderDataType.Float3: return 3;\n\t\tcase ShaderDataType.Float4: return 4;\n\t\tcase ShaderDataType.Mat3:   return 3 * 3;\n\t\tcase ShaderDataType.Mat4:   return 4 * 4;\n\t\tcase ShaderDataType.Int:    return 1;\n\t\tcase ShaderDataType.Int2:   return 2;\n\t\tcase ShaderDataType.Int3:   return 3;\n\t\tcase ShaderDataType.Int4:   return 4;\n\t\tcase ShaderDataType.Bool:   return 1;\n\t\t}\n\n\t\tconsole.error('Unknown ShaderDataType!');\n\t\treturn 0;\n\t}\n}\n\n/** Represents the layout of a buffer. */\nexport class BufferLayout {\n\tprivate elements: BufferElement[];\n\tprivate stride: number = 0;\n\n\t/** Create a new buffer element.\n\t * @param {BufferElement[]} elements The elements.\n\t */\n\tpublic constructor(elements: BufferElement[]) {\n\t\tthis.elements = elements;\n\t\tlet offset = 0;\n\t\tthis.stride = 0;\n\n\t\tfor (let element of elements) {\n\t\t\telement.offset = offset;\n\t\t\toffset += element.size;\n\t\t\tthis.stride += element.size;\n\t\t}\n\t}\n\n\t/** Get the stride.\n\t * @returns {number} The stride.\n\t */\n\tpublic getStride(): number {\n\t\treturn this.stride;\n\t}\n\n\t/** Get elements.\n\t * @returns {BufferElement[]}\n\t */\n\tpublic getElements(): BufferElement[] {\n\t\treturn this.elements;\n\t}\n\n\t/** Get the total number of components.\n\t * @returns {number} The components.\n\t */\n\tpublic getComponentCount(): number {\n\t\tlet count = 0;\n\t\tfor (let element of this.elements) {\n\t\t\tcount += element.getComponentCount();\n\t\t}\n\t\treturn count;\n\t}\n}\n\n/** Represents an OpenGL vertex buffer. */\nexport class VertexBuffer {\n\tprivate buffer: WebGLBuffer;\n\tprivate layout: BufferLayout;\n\n\t/** Create a new vertex buffer.\n\t * @param {Float32Array} vertices The vertices.\n\t * @param {number} [usage=Surface.gl.STATIC_DRAW] The usage.\n\t * @param {number} [length] The length of the buffer.\n\t */\n\tpublic constructor (vertices?: Float32Array, usage: number = Surface.gl.STATIC_DRAW, length?: number) {\n\t\tthis.buffer = Surface.gl.createBuffer();\n\t\tSurface.gl.bindBuffer(Surface.gl.ARRAY_BUFFER, this.buffer);\n\t\tif (length)\n\t\t\tSurface.gl.bufferData(Surface.gl.ARRAY_BUFFER, vertices, usage);\n\t\telse\n\t\t\tSurface.gl.bufferData(Surface.gl.ARRAY_BUFFER, vertices, usage, 0, length);\n\t}\n\n\t/** Bind the OpenGL buffer. */\n\tpublic bind() {\n\t\tSurface.gl.bindBuffer(Surface.gl.ARRAY_BUFFER, this.buffer);\n\t}\n\n\t/** Unbind the OpenGL buffer. */\n\tpublic unbind() {\n\t\tSurface.gl.bindBuffer(Surface.gl.ARRAY_BUFFER, null);\n\t}\n\n\t/** Get layout.\n\t * @return {BufferLayout} The layout.\n\t */\n\tpublic getLayout(): BufferLayout {\n\t\treturn this.layout;\n\t}\n\n\t/** Set layout.\n\t * @param {BufferLayout} layout The new layout.\n\t */\n\tpublic setLayout(layout: BufferLayout) {\n\t\tthis.layout = layout;\n\t}\n\n\t/** OpenGL bind buffer base.\n\t * @param {number} [target=TRANSFORM_FEEDBACK_BUFFER] The target.\n\t * @param {number} [index=0] The index.\n\t */\n\tpublic bindBufferBase(target: number = Surface.gl.TRANSFORM_FEEDBACK_BUFFER, index: number = 0) {\n\t\tSurface.gl.bindBufferBase(target, index, this.buffer);\n\t}\n\n\t/** OpenGL unbind buffer base.\n\t * @param {number} target The OpenGL target.\n\t * @param {number} index The index.\n\t */\n\tpublic unbindBufferBase(target: number = Surface.gl.TRANSFORM_FEEDBACK_BUFFER, index: number = 0) {\n\t\tSurface.gl.bindBufferBase(target , index, null);\n\t}\n\n\t/** Set the buffer data.\n\t * @param {Float32Array} data The data.\n\t * @param {number} [usage=STATIC_DRAW] The OpenGL usage.\n\t * @param {number} [target=ARRAY_BUFFER] The OpenGL target.\n\t */\n\tpublic setData(data: Float32Array, usage: number = Surface.gl.STATIC_DRAW, target: number = Surface.gl.ARRAY_BUFFER) {\n\t\tSurface.gl.bindBuffer(target, this.buffer);\n\t\tSurface.gl.bufferData(target, data, usage);\n\t}\n\n\t/** Set buffer sub data.\n\t * @param {Float32Array} data The data.\n\t * @param {number} offset The offset into the buffer.\n\t * @param {number} [target=ARRAY_BUFFER] The OpenGL target.\n\t */\n\tpublic setSubData(data: Float32Array, offset: number, target: number = Surface.gl.ARRAY_BUFFER) {\n\t\tSurface.gl.bindBuffer(Surface.gl.ARRAY_BUFFER, this.buffer);\n\t\tSurface.gl.bufferSubData(target, offset, data);\n\t}\n}\n\n/** Represents an OpenGL index buffer. */\nexport class IndexBuffer {\n\tprivate buffer: WebGLBuffer;\n\tprivate count: number;\n\n\t/** Create a new index buffer.\n\t * @param {Uint16Array} indices The indices.\n\t */\n\tpublic constructor (indices: Uint16Array) {\n\t\tthis.buffer = Surface.gl.createBuffer();\n\t\tthis.count = indices.length;\n\t\tSurface.gl.bindBuffer(Surface.gl.ELEMENT_ARRAY_BUFFER, this.buffer);\n\t\tSurface.gl.bufferData(Surface.gl.ELEMENT_ARRAY_BUFFER, indices, Surface.gl.STATIC_DRAW);\n\t}\n\n\t/** Bind the index buffer in OpenGL. */\n\tpublic bind() {\n\t\tSurface.gl.bindBuffer(Surface.gl.ELEMENT_ARRAY_BUFFER, this.buffer);\n\t}\n\n\t/** Unbind the index buffer in OpenGL. */\n\tpublic unbind() {\n\t\tSurface.gl.bindBuffer(Surface.gl.ELEMENT_ARRAY_BUFFER, null);\n\t}\n\n\t/** Get the number of indices.\n\t * @returns {number} The number of indices.\n\t */\n\tpublic getCount(): number {\n\t\treturn this.count;\n\t}\n}","import { Surface as s } from './Surface';\nimport { Texture2D } from './Texture';\nimport { RenderBuffer } from './RenderBuffer';\n\n/** Represents an OpenGL framebuffer. */\nexport class FrameBuffer {\n\n\tprivate framebuffer: WebGLFramebuffer;\n\tprivate texture: Texture2D;\n\tprivate renderbuffer: RenderBuffer;\n\n\tprivate textureAttachment: number;\n\tprivate fbTarget: number;\n\tprivate textureTarget: number;\n\n\tprivate rbAttachment: number;\n\tprivate rbTarget: number;\n\tprivate rbRenderBufferTarget: number;\n\n\t/** Create a new framebuffer. */\n\tpublic constructor() {\n\t\tthis.framebuffer = s.gl.createFramebuffer();\n\t}\n\n\t/** Bind the OpenGL framebuffer.\n\t * @param {number} [target=FRAMEBUFFER] The OpenGL target.\n\t */\n\tpublic bind(target: number = s.gl.FRAMEBUFFER) {\n\t\ts.gl.bindFramebuffer(target, this.framebuffer);\n\t}\n\n\t/** Unbind the OpenGL framebuffer.\n\t * @param {number} [target=FRAMEBUFFER] The OpenGL target.\n\t*/\n\tpublic unbind(target: number = s.gl.FRAMEBUFFER) {\n\t\ts.gl.bindFramebuffer(target, null);\n\t}\n\n\t/** Attach a texture to the framebuffer.\n\t * @param {Texture2D} texture The texture.\n\t * @param {number} attachment The OpenGL attachment.\n\t * @param {number} [fbTarget=FRAMEBUFFER] The OpenGL framebuffer target.\n\t * @param {number} [textureTarget=TEXTURE_2D] The OpenGL texture target.\n\t */\n\tpublic attachTexture(texture: Texture2D, attachment: number, fbTarget: number = s.gl.FRAMEBUFFER, textureTartget: number = s.gl.TEXTURE_2D) {\n\t\ts.gl.bindFramebuffer(fbTarget, this.framebuffer);\n\t\ts.gl.framebufferTexture2D(fbTarget, attachment, textureTartget, texture.getGLTexture(), 0);\n\t\tthis.texture = texture;\n\t\tthis.textureAttachment = attachment;\n\t\tthis.fbTarget = fbTarget;\n\t\tthis.textureTarget = textureTartget;\n\t}\n\n\t/** Attach a render buffer to the framebuffer.\n\t * @param {RenderBuffer} renderbuffer The renderbuffer.\n\t * @param {number} [attachment=DEPTH_STENCIL_ATTACHMENT] The OpenGL attachment.\n\t * @param {number} [target=FRAMEBUFFER] The OpenGL target.\n\t * @param {number} [renderbufferTarget=RENDERBUFFER] The OpenGL renderbuffer target.\n\t */\n\tpublic attachRenderbuffer(renderbuffer: RenderBuffer, attachment: number = s.gl.DEPTH_STENCIL_ATTACHMENT, target: number = s.gl.FRAMEBUFFER, renderbufferTarget: number = s.gl.RENDERBUFFER) {\n\t\ts.gl.framebufferRenderbuffer(target, attachment, renderbufferTarget, renderbuffer.getGLRenderbuffer());\n\t\tthis.renderbuffer = renderbuffer;\n\t\tthis.rbAttachment = attachment;\n\t\tthis.rbTarget = target;\n\t\tthis.rbRenderBufferTarget = renderbufferTarget;\n\t}\n\n\t/** Check if the framebuffer is complete.\n\t * @returns {boolean} Whether it is complete.\n\t */\n\tpublic isComplete(target: number = s.gl.FRAMEBUFFER): boolean {\n\t\treturn s.gl.checkFramebufferStatus(target) === s.gl.FRAMEBUFFER_COMPLETE;\n\t}\n\n\t/** Get the texture.\n\t * @returns {Texture2D} The texture.\n\t */\n\tpublic getTexture(): Texture2D {\n\t\treturn this.texture;\n\t}\n\n\t/** Get the renderbuffer\n\t * @returns {RenderBuffer} The renderbuffer.\n\t */\n\tpublic getRenderbuffer(): RenderBuffer {\n\t\treturn this.renderbuffer;\n\t}\n\n\tpublic resize(width: number, height: number) {\n\t\ts.gl.deleteFramebuffer(this.framebuffer);\n\t\tthis.framebuffer = s.gl.createFramebuffer();\n\t\tthis.bind();\n\n\t\tif (this.texture) {\n\t\t\tthis.texture.loadEmpty(width, height, s.gl.RGBA);\n\t\t\ts.gl.framebufferTexture2D(this.fbTarget, this.textureAttachment, this.textureTarget, this.texture.getGLTexture(), 0);\n\t\t}\n\t\t\n\t\tif (this.renderbuffer) {\n\t\t\tthis.renderbuffer.resize(width, height);\n\t\t\ts.gl.framebufferRenderbuffer(this.rbTarget, this.rbAttachment, this.rbRenderBufferTarget, this.renderbuffer.getGLRenderbuffer());\n\t\t}\n\n\t}\n}","\n/** Stores a number of images for your convenience. */\nexport class ImageLibrary {\n\tprivate images: Map<string, HTMLImageElement>;\n\n\t/** Create a new image library. */\n\tpublic constructor() {\n\t\tthis.images = new Map<string, HTMLImageElement>();\n\t}\n\n\t/** Load an image into the library from a path.\n\t * @param {string} alias The image's alias, used to access.\n\t * @param {string} path The image's path.\n\t * @returns {HTMLImageElement} The image.\n\t */\n\tpublic loadPath(alias: string, path: string): HTMLImageElement {\n\t\tif (this.images.has(alias)) {\n\t\t\tconsole.warn(`Image alias '${alias}' already exists in library.`);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tconst image = new Image();\n\t\timage.src = path;\n\t\tthis.images.set(alias, image);\n\t\treturn image;\n\t}\n\n\t/** Load an image using its HTML element ID. \n\t * @param {string} alias The image's alias, used to access.\n\t * @param {string} id The HTML element ID.\n\t * @returns {HTMLImageElement} The image.\n\t*/\n\tpublic loadById(alias: string, id: string): HTMLImageElement {\n\t\tif (this.images.has(alias)) {\n\t\t\tconsole.warn(`Image alias '${alias}' already exists in library.`);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tconst image = document.getElementById(id);\n\t\tif (image) {\n\t\t\tif (image.nodeName === 'IMAGE') {\n\t\t\t\tthis.images.set(alias, <HTMLImageElement>image);\n\t\t\t\treturn <HTMLImageElement>image;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.error(`Element with id '${id}' is not an image.`);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tconsole.error(`Could not find element with id '${id}'`);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Get an image from the library.\n\t * @param {string} alias The image's alias.\n\t * @returns {HTMLImageElement} The image.\n\t */\n\tpublic get(alias: string): HTMLImageElement {\n\t\treturn this.images.get(alias);\n\t}\n\n\t/** Check if an image is in the library.\n\t * @param {string} alias The image's alias.\n\t * @returns {boolean} Whether the image is in the library.\n\t */\n\tpublic has(alias: string): boolean {\n\t\treturn this.images.has(alias);\n\t}\n}","import * as glm from 'gl-matrix';\nimport { Surface } from './Surface';\nimport { VertexArray } from './VertexArray';\nimport { VertexBuffer, BufferElement, BufferLayout, ShaderDataType, IndexBuffer } from './Buffer';\nimport { Shader } from './Shader';\nimport { OrthographicCamera } from './OrthographicCamera';\nimport { TextureAtlas } from './TextureAtlas';\nimport { RenderCommand } from './RenderCommand';\n\nimport * as InstancedTextureShaderSource from './ShaderSource/InstancedTextureShaderSource';\n\n/**\n * The maximum number of instances which can be rendered.*/\nconst MAX_INSTANCES: number = 1e4;\n\n/** The instanced renderer. */\nexport class InstancedRenderer {\n\n\tprivate static viewProjectionMatrix: glm.mat4;\n\n\tprivate static instanceCount: number;\n\tprivate static instancedTextureShader: Shader;\n\tprivate static instanceVA: VertexArray;\n\tprivate static instanceBuffer: VertexBuffer;\n\tprivate static textureAtlas: TextureAtlas;\n\n\tprivate static instanceData: Float32Array;\n\n\t/** Initialize the instanced renderer\n\t * @remarks Only to be called by Renderer.\n\t * @internal\n\t */\n\tpublic static init() {\n\n\t\tthis.textureAtlas = new TextureAtlas();\n\t\t\n\t\tthis.instancedTextureShader = new Shader('InstancedTextureShader', InstancedTextureShaderSource.getVertexSource(), InstancedTextureShaderSource.getFragmentSource());\n\n\t\tthis.instanceVA = new VertexArray();\n\t\t\n\t\tconst quadVertices = [\n\t\t\t-0.5, -0.5, 0.0, 1.0,\n\t\t\t 0.5, -0.5, 1.0, 1.0,\n\t\t\t 0.5,  0.5, 1.0, 0.0,\n\t\t\t-0.5,  0.5, 0.0, 0.0\n\t\t];\n\t\tconst quadVB = new VertexBuffer(new Float32Array(quadVertices));\n\n\t\tconst quadIndices = [0, 1, 2, 0, 2, 3];\n\t\tconst quadIB = new IndexBuffer(new Uint16Array(quadIndices));\n\t\tthis.instanceVA.setIndexBuffer(quadIB);\n\n\t\tconst quadLayout = new BufferLayout([\n\t\t\tnew BufferElement(ShaderDataType.Float2, 'a_Position'),\n\t\t\tnew BufferElement(ShaderDataType.Float2, 'a_TexCoord'),\n\t\t]);\n\t\tquadVB.setLayout(quadLayout);\n\t\tthis.instanceVA.addVertexBuffer(quadVB, this.instancedTextureShader);\n\t\t\n\t\t// INVALID ENUM AFTER THIS //\n\t\tconst instanceLayout = new BufferLayout([\n\t\t\tnew BufferElement(ShaderDataType.Mat4, 'a_Transform', false, 1),\n\t\t\tnew BufferElement(ShaderDataType.Float4, 'a_AtlasBounds', false, 1)\n\t\t]);\n\t\tthis.instanceData = new Float32Array(MAX_INSTANCES * instanceLayout.getStride());\n\t\tthis.instanceBuffer = new VertexBuffer(this.instanceData, Surface.gl.DYNAMIC_DRAW, MAX_INSTANCES * instanceLayout.getStride());\n\t\tthis.instanceBuffer.setLayout(instanceLayout);\n\t\tthis.instanceVA.addVertexBuffer(this.instanceBuffer, this.instancedTextureShader);\n\t}\n\n\t/** Begin the instanced renderer scene\n\t * @remarks\n\t * Called only by Renderer\n\t * \n\t * @param {OrthographicCamera} camera The camera.\n\t * @internal\n\t */\n\tpublic static beginScene(camera: OrthographicCamera) {\n\t\tthis.viewProjectionMatrix = camera.getViewProjectionMatrix();\n\t\tthis.instanceCount = 0;\n\t}\n\n\t/** Submit a texture for rendering.\n\t * @param {string} textureAlias The texture's alias.\n\t * @param {glm.mat4} transform The transform to be applied to the texture.\n\t */\n\tpublic static submitTextured(textureAlias: string, transform: glm.mat4) {\n\t\tif (this.instanceCount < MAX_INSTANCES) {\n\t\t\tthis.instanceData.set(Float32Concat(transform, this.textureAtlas.getBounds(textureAlias)), \n\t\t\t\tthis.instanceCount * this.instanceBuffer.getLayout().getComponentCount());\n\t\t\tthis.instanceCount++;\n\t\t}\n\t}\n\n\t/** Begin the instanced renderer scene\n\t * @remarks Called only by Renderer\n\t * @internal\n\t */\n\tpublic static endScene() {\n\t\tif (this.instanceCount > 0) {\n\t\t\tthis.textureAtlas.getTexture().bind();\n\n\t\t\tthis.instanceBuffer.setData(this.instanceData, Surface.gl.DYNAMIC_DRAW);\n\t\n\t\t\tconst shader = this.instancedTextureShader;\n\t\t\tshader.bind();\n\t\t\tshader.uploadUniformInt('u_Texture', 0);\n\t\t\tshader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\n\t\t\tthis.instanceVA.bind();\n\t\t\tRenderCommand.drawElementsInstanced(this.instanceVA, this.instanceCount);\n\t\t}\n\t}\n\n\tpublic static useImages(images: [string, HTMLImageElement][]) {\n\t\tthis.textureAtlas.setImages(images);\n\t}\n}\n\n// source: https://stackoverflow.com/questions/4554252/typed-arrays-in-gecko-2-float32array-concatenation-and-expansion //\nfunction Float32Concat(first: Float32Array, second: Float32Array): Float32Array\n{\n\tlet firstLength = first.length;\n\tlet result = new Float32Array(firstLength + second.length);\n\n\tresult.set(first);\n\tresult.set(second, firstLength);\n\n\treturn result;\n}","import * as glm from 'gl-matrix';\nimport { Surface } from './Surface';\nimport { Shader } from './Shader';\nimport { OrthographicCamera } from './OrthographicCamera';\nimport { VertexArray } from './VertexArray';\nimport { VertexBuffer, BufferElement, BufferLayout, ShaderDataType, IndexBuffer } from './Buffer';\nimport { RenderCommand } from './RenderCommand';\nimport { FrameBuffer } from './FrameBuffer';\nimport { Texture2D } from './Texture';\nimport { RenderBuffer } from './RenderBuffer';\nimport { Event, EventDispatcher } from '../Events/Event';\nimport { CanvasResizeEvent } from 'Polar/Events/ApplicationEvent';\nimport * as LightShaderSource from './ShaderSource/LightShaderSource';\nimport * as MultiplyTextureShaderSource from './ShaderSource/MultiplyTextureShaderSource';\n\n/** The maximum number of lights able to be used in a scene. */\nconst MAX_LIGHTS = 1e4;\n\n/** A static class which contains functions to draw lights to the 2D scene. The maximum number of lights usable in a scene is 10000. */\nexport class LightRenderer {\n\n\tprivate static ambientLightColor: glm.vec3 = glm.vec3.fromValues(0, 0, 0);\n\n\tprivate static viewProjectionMatrix: glm.mat4;\n\n\tprivate static lightShader: Shader;\n\tprivate static multiplyShader: Shader;\n\n\tprivate static lightData: Float32Array;\n\tprivate static lightCount: number;\n\tprivate static instanceVA: VertexArray;\n\tprivate static multiplyVA: VertexArray;\n\tprivate static instanceBuffer: VertexBuffer;\n\tprivate static spriteFB: FrameBuffer;\n\tprivate static lightFB: FrameBuffer;\n\n\tprivate static kernel: Float32Array = new Float32Array([1, 0.939, 0.7777, 0.5681, 0.366, 0.2079, 0.1042, 0.0461, 0.0179, 0.0062, 0]);\n\n\t/**\n\t * Initialize the light renderer.\n\t * @internal\n\t */\n\tpublic static init() {\n\n\t\t// SETUP FRAME BUFFER //\n\t\tthis.lightFB = new FrameBuffer();\n\t\tthis.lightFB.bind();\n\n\t\t// ATTACH TEXTURE //\n\t\tconst lightTexture = new Texture2D();\n\t\tlightTexture.loadEmpty(Surface.getWidth(), Surface.getHeight(), Surface.gl.RGBA);\n\t\tlightTexture.bind();\n\t\tthis.lightFB.attachTexture(lightTexture, Surface.gl.COLOR_ATTACHMENT0);\n\n\t\t// ATTACH RENDER BUFFER //\n\t\tconst lightRB = new RenderBuffer();\n\t\tlightRB.storage(Surface.getWidth(), Surface.getHeight(), Surface.gl.DEPTH24_STENCIL8);\n\t\tthis.lightFB.attachRenderbuffer(lightRB);\n\n\t\tif (!this.lightFB.isComplete())\n\t\t\tconsole.error('Framebuffer not complete!');\n\n\t\t// SETUP SPRITE FRAME BUFFER //\n\t\tthis.spriteFB = new FrameBuffer();\n\t\tthis.spriteFB.bind();\n\n\t\t// ATTACH TEXTURE //\n\t\tconst spriteTexture = new Texture2D();\n\t\tspriteTexture.loadEmpty(Surface.getWidth(), Surface.getHeight(), Surface.gl.RGBA);\n\t\tspriteTexture.bind();\n\t\tthis.spriteFB.attachTexture(spriteTexture, Surface.gl.COLOR_ATTACHMENT0);\n\n\t\t// ATTACH RENDER BUFFER //\n\t\tconst spriteRB = new RenderBuffer();\n\t\tspriteRB.storage(Surface.getWidth(), Surface.getHeight(), Surface.gl.DEPTH24_STENCIL8);\n\n\t\tthis.spriteFB.attachRenderbuffer(spriteRB);\n\n\t\tif (!this.spriteFB.isComplete())\n\t\t\tconsole.error('Framebuffer not complete!');\n\t\t\n\t\t// SETUP SHADER //\n\t\tthis.lightShader = new Shader('LightShader', LightShaderSource.getVertexSource(), LightShaderSource.getFragmentSource());\n\t\tthis.multiplyShader = new Shader('MultiplyShader', MultiplyTextureShaderSource.getVertexSource(), MultiplyTextureShaderSource.getFragmentSource());\n\n\t\t// SETUP BUFFERS //\n\t\t{\n\t\t\tthis.instanceVA = new VertexArray();\n\t\t\n\t\t\tconst quadVertices = [\n\t\t\t\t-1, -1,\n\t\t\t\t 1, -1,\n\t\t\t\t 1,  1,\n\t\t\t\t-1,  1\n\t\t\t];\n\t\t\tconst quadVB = new VertexBuffer(new Float32Array(quadVertices));\n\n\t\t\tconst quadIndices = [0, 1, 2, 0, 2, 3];\n\t\t\tconst quadIB = new IndexBuffer(new Uint16Array(quadIndices));\n\t\t\tthis.instanceVA.setIndexBuffer(quadIB);\n\n\t\t\tconst quadLayout = new BufferLayout([\n\t\t\t\tnew BufferElement(ShaderDataType.Float2, 'a_Position'),\n\t\t\t]);\n\t\t\tquadVB.setLayout(quadLayout);\n\t\t\tthis.instanceVA.addVertexBuffer(quadVB, this.lightShader);\n\n\t\t\tconst instanceLayout = new BufferLayout([\n\t\t\t\tnew BufferElement(ShaderDataType.Mat4, 'a_Transform', false, 1),\n\t\t\t\tnew BufferElement(ShaderDataType.Float3, 'a_Color', false, 1),\n\t\t\t\tnew BufferElement(ShaderDataType.Float, 'a_Intensity', false, 1)\n\t\t\t]);\n\t\t\tthis.lightData = new Float32Array(MAX_LIGHTS * instanceLayout.getStride());\n\t\t\tthis.instanceBuffer = new VertexBuffer(this.lightData, Surface.gl.DYNAMIC_DRAW, MAX_LIGHTS * instanceLayout.getStride());\n\t\t\tthis.instanceBuffer.setLayout(instanceLayout);\n\t\t\tthis.instanceVA.addVertexBuffer(this.instanceBuffer, this.lightShader);\n\t\t}\n\n\t\t{\n\t\t\tthis.multiplyVA = new VertexArray();\n\t\t\t\n\t\t\tconst quadVertices = [\n\t\t\t\t-1.0, -1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 1.0, -1.0, 0.0, 1.0, 0.0,\n\t\t\t\t 1.0,  1.0, 0.0, 1.0, 1.0,\n\t\t\t\t-1.0,  1.0, 0.0, 0.0, 1.0\n\t\t\t];\n\t\t\tconst quadVB = new VertexBuffer(new Float32Array(quadVertices));\n\n\t\t\tconst quadIndices = [0, 1, 2, 0, 2, 3];\n\t\t\tconst quadIB = new IndexBuffer(new Uint16Array(quadIndices));\n\t\t\tthis.multiplyVA.setIndexBuffer(quadIB);\n\n\t\t\tconst quadLayout = new BufferLayout([\n\t\t\t\tnew BufferElement(ShaderDataType.Float3, 'a_Position'),\n\t\t\t\tnew BufferElement(ShaderDataType.Float2, 'a_TexCoord'),\n\t\t\t]);\n\t\t\tquadVB.setLayout(quadLayout);\n\t\t\tthis.multiplyVA.addVertexBuffer(quadVB, this.multiplyShader);\n\t\t}\n\n\t\tthis.instanceVA.unbind();\n\t\tthis.lightFB.unbind();\n\t\tthis.lightFB.getTexture().unbind();\n\t}\n\n\tpublic static onEvent(event: Event) {\n\t\tconst dispatcher = new EventDispatcher(event);\n\t\t// onCanvasResize\n\t\tdispatcher.dispatch(CanvasResizeEvent, canvasEvent => {\n\t\t\tthis.spriteFB.resize(canvasEvent.width, canvasEvent.height);\n\t\t\tthis.lightFB.resize(canvasEvent.width, canvasEvent.height);\n\t\t\treturn false;\n\t\t});\n\t}\n\n\t/**\n\t * Submit a light to be rendered.\n\t * @param {PointLight} light The light.\n\t */\n\tpublic static submitLight(color: glm.vec3, intensity: number, transform: glm.mat4) {\n\t\tif (this.lightCount < MAX_LIGHTS) {\n\t\t\tthis.lightData.set(Float32Concat(transform, Float32Concat(color, new Float32Array([intensity]))), \n\t\t\t\tthis.lightCount * this.instanceBuffer.getLayout().getComponentCount());\n\t\t\tthis.lightCount++;\n\t\t}\n\t}\n\n\t/** \n\t * Begin the light renderer scene. Only to be called by the Polar Renderer.\n\t * @internal\n\t */\n\tpublic static beginScene(camera: OrthographicCamera) {\n\t\tthis.viewProjectionMatrix = camera.getViewProjectionMatrix();\n\t\tthis.lightCount = 0;\n\t\tthis.spriteFB.bind();\n\t\tSurface.clear();\n\t}\n\n\t/** \n\t * End the light renderer scene. Only to be called by the Polar Renderer.\n\t * @internal\n\t */\n\tpublic static endScene() {\n\t\tthis.lightFB.bind();\n\t\tSurface.clear(glm.vec4.fromValues(this.ambientLightColor[0], this.ambientLightColor[1], this.ambientLightColor[2], 1));\n\t\tif (this.lightCount > 0) {\n\t\t\tthis.instanceBuffer.setData(this.lightData, Surface.gl.DYNAMIC_DRAW);\n\t\n\t\t\tthis.lightShader.bind();\n\t\t\tthis.lightShader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\t\tthis.lightShader.uploadUniformFloatArray('u_Kernel', this.kernel);\n\t\t\tthis.lightShader.uploadUniformInt('u_InstanceCount', this.lightCount);\n\t\n\t\t\tthis.instanceVA.bind();\n\t\t\tRenderCommand.drawElementsInstanced(this.instanceVA, this.lightCount);\n\n\t\t\t//console.log(`Rendering ${this.lightCount} lights!`);\n\t\t}\n\t\tthis.lightFB.unbind();\n\t}\n\n\t/** Multiply the two internal render buffers together and render to the currently bound FBO. Only to be called by the Polar Renderer.\n\t * @internal\n\t */\n\tpublic static render() {\n\t\tthis.multiplyShader.bind();\n\t\tthis.spriteFB.getTexture().bind(Surface.gl.TEXTURE0);\n\t\tthis.lightFB.getTexture().bind(Surface.gl.TEXTURE1);\n\n\t\tthis.multiplyShader.uploadUniformInt('u_SpriteTexture', 0);\n\t\tthis.multiplyShader.uploadUniformInt('u_LightTexture', 1);\n\n\t\tthis.multiplyVA.bind();\n\t\tRenderCommand.drawElements(this.multiplyVA);\n\t}\n\n\tpublic static setAmbientLightColor(color: glm.vec3)\n\t{\n\t\tthis.ambientLightColor = color;\n\t}\n}\n\n// source: https://stackoverflow.com/questions/4554252/typed-arrays-in-gecko-2-float32array-concatenation-and-expansion //\nfunction Float32Concat(first: Float32Array, second: Float32Array): Float32Array\n{\n\tlet firstLength = first.length;\n\tlet result = new Float32Array(firstLength + second.length);\n\n\tresult.set(first);\n\tresult.set(second, firstLength);\n\n\treturn result;\n}","import * as glm from 'gl-matrix';\nimport { Event } from '../Events/Event';\n\n/** Class representing an orthographic camera for use in a Polar scene. */\nexport class OrthographicCamera {\n\tprivate projectionMatrix: glm.mat4;\n\tprivate viewMatrix: glm.mat4;\n\tprivate viewProjectionMatrix: glm.mat4;\n\n\tprivate position: glm.vec3;\n\tprivate rotation: number;\n\n\tprivate eventCallbackFn: (event: Event) => void;\n\n\t/**\n\t * Create an orthographic camera.\n\t * @param {number} left The left bound of the camera.\n\t * @param {number} right The right bound of the camera.\n\t * @param {number} bottom The bottom bound of the camera.\n\t * @param {number} top The top bound of the camera.\n\t * @param {glm.vec3} [position] The initial position of the camera.\n\t * @param {number} [rotation] The initial rotation of the camera in radians.\n\t */\n\tpublic constructor(left: number, right: number, bottom: number, top: number, position: glm.vec3 = glm.vec3.create(), rotation: number = 0) {\n\t\tthis.viewMatrix = glm.mat4.create();\n\t\tthis.projectionMatrix = glm.mat4.create();\n\t\tthis.viewProjectionMatrix = glm.mat4.create();\n\t\tglm.mat4.ortho(this.projectionMatrix, left, right, bottom, top, -1.0, 1.0);\n\t\tthis.position = position;\n\t\tthis.rotation = rotation;\n\n\t\tthis.recalculateViewMatrix();\n\t}\n\n\t/** Recalculates the camera's view projection matrix. */\n\tprivate recalculateViewMatrix() {\n\t\tlet transform = glm.mat4.create();\n\t\tglm.mat4.translate(transform, transform, this.position);\n\t\tglm.mat4.rotate(transform, transform, this.rotation, [0, 0, 1]);\n\n\t\tglm.mat4.invert(this.viewMatrix, transform);\n\t\tglm.mat4.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);\n\t}\n\n\t/**\n\t * Get position of camera.\n\t * @returns {glm.vec3} The camera's position in world space.\n\t */\n\tpublic getPosition(): glm.vec3 {\n\t\treturn this.position;\n\t}\n\t\n\t/**\n\t * Set position of camera.\n\t * @param {glm.vec3} position The new world space position for the camera.\n\t */\n\tpublic setPosition(position: glm.vec3): void {\n\t\tthis.position = position;\n\t\tthis.recalculateViewMatrix();\n\t}\n\n\t/**\n\t * Get rotation of camera.\n\t * @returns {number} The camera's rotation in radians.\n\t */\n\tpublic getRotation(): number {\n\t\treturn this.rotation;\n\t}\n\n\t/**\n\t * Set rotation of camera.\n\t * @param {number} rotation The new rotation for the camera.\n\t */\n\tpublic setRotation(rotation: number): void {\n\t\tthis.rotation = rotation;\n\t\tthis.recalculateViewMatrix();\n\t}\n\n\t/**\n\t * Get camera's projection matrix.\n\t * @returns The camera's projection matrix.\n\t */\n\tpublic getProjectionMatrix(): glm.mat4 {\n\t\treturn this.projectionMatrix;\n\t}\n\n\t/**\n\t * Get camera's view matrix.\n\t * @returns {glm.mat4} The camera's view matrix.\n\t */\n\tpublic getViewMatrix(): glm.mat4 {\n\t\treturn this.viewMatrix;\n\t}\n\n\t/**\n\t * Get camera's view projection matrix.\n\t * @returns {glm.mat4} The camera's view projection matrix.\n\t */\n\tpublic getViewProjectionMatrix(): glm.mat4 {\n\t\treturn this.viewProjectionMatrix;\n\t}\n\n\t/**\n\t * Set camera's projection matrix.\n\t * @param {number} left The left bound of the camera.\n\t * @param {number} right The right bound of the camera.\n\t * @param {number} bottom The bottom bound of the camera.\n\t * @param {number} top The top bound of the camera.\n\t */\n\tpublic setProjection(left: number, right: number, bottom: number, top: number): void {\n\t\tthis.projectionMatrix = glm.mat4.create();\n\t\tthis.viewProjectionMatrix = glm.mat4.create();\n\t\tglm.mat4.ortho(this.projectionMatrix, left, right, bottom, top, -1.0, 1.0);\n\t\tglm.mat4.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);\n\t}\n}","import * as glm from 'gl-matrix';\nimport { VertexArray } from './VertexArray';\nimport { VertexBuffer, BufferLayout, BufferElement, ShaderDataType, IndexBuffer } from './Buffer';\nimport { Surface } from './Surface';\nimport { ParticleRenderer } from './ParticleRenderer';\nimport { Texture2D } from './Texture';\n\n/** Settings for a particle emitter. */\nexport class ParticleEmitterSettings {\n\t/** The mode of the particle emitter. Can be 'POINTS' or 'TEXTURE' */\n\tpublic mode: string = 'POINTS';\n\t/** The total number of particles which can be released by the emitter at one time. */\n\tpublic numParticles: number = 100;\n\t/** The rate at which the particles are released, in particles per second. */\n\tpublic spawnRate: number = 100;\n\t/** The acceleration applied to all particles. */\n\tpublic gravity: glm.vec2 = glm.vec2.create();\n\t/** The position in the world where the particles are released. */\n\tpublic origin: glm.vec2 = glm.vec2.create();\n\t/** The direction which the center of the spread releases particles in radians. Starts from the right going anticlockwise (like a unit circle). */\n\tpublic angle: number = 0;\n\t/** The spread angle of the released particles in radians. */\n\tpublic spread: number = Math.PI / 2;\n\t/** The minimum speed of the particles. */\n\tpublic minSpeed: number = 1;\n\t/** The maximum speed of the particles. */\n\tpublic maxSpeed: number = 2;\n\t/** The minimum life of the particles. */\n\tpublic minLife: number = 1;\n\t/** The maximum life of the particles. */\n\tpublic maxLife: number = 2;\n\t/** How long it takes the particles fade. \n\t * The particles will have 100% opacity until the particle reaches the end of its life, where the opacity will be lowered for the specified time until it dies. \n\t */\n\tpublic fadeTime: number = 0;\n\t/** The z-index of the rendering. Allows objects to be rendered on top of each other. The highest zIndex gets its pixels rendered on top. */\n\tpublic zIndex: number = 0;\n\t/** The texture to be rendered on the particle. Used in conjunction with mode 'TEXTURE'. */\n\tpublic texture: Texture2D;\n\t/** The scale applied to the textured quad. Used in conjunction with mode 'TEXTURE'. */\n\tpublic scale: number = 1.0;\n\t/** How long it takes the particles shrink to nothing. \n\t * The particles will have 100% size until the particle reaches the end of its life, where the size will be lowered for the specified time until it dies.\n\t * Used in conjunction with mode 'TEXTURE'.\n\t */\n\tpublic shrinkTime: number = 0.0;\n}\n\n/** A class representing an emitter of particles, rendered through ParticleRenderer. */\nexport class ParticleEmitter {\n\t/** The mode of the particle emitter. Can be 'POINTS' or 'TEXTURE' */\n\tpublic mode: string;\n\t/** The total number of particles which can be released by the emitter at one time. */\n\tpublic numParticles: number;\n\t/** The rate at which the particles are released, in particles per second. */\n\tpublic spawnRate: number;\n\t/** The number of particles which have been born. */\n\tpublic bornParticles: number = 0;\n\t/** The acceleration applied to all particles. */\n\tpublic gravity: glm.vec2;\n\t/** The position in the world where the particles are released. */\n\tpublic origin: glm.vec2;\n\t/** The direction which the center of the spread releases particles in radians. Starts from the right going anticlockwise (like a unit circle). */\n\tpublic angle: number;\n\t/** The spread angle of the released particles in radians. */\n\tpublic spread: number;\n\t/** The minimum speed of the particles. */\n\tpublic minSpeed: number;\n\t/** The maximum speed of the particles. */\n\tpublic maxSpeed: number;\n\t/** The minimum life of the particles. */\n\tpublic minLife: number;\n\t/** The maximum life of the particles. */\n\tpublic maxLife: number;\n\t/** How long it takes the particles fade. \n\t * The particles will have 100% opacity until the particle reaches the end of its life, where the opacity will be lowered for the specified time until it dies. \n\t */\n\tpublic fadeTime: number;\n\t/** The z-index of the rendering. Allows objects to be rendered on top of each other. The highest zIndex gets its pixels rendered on top. */\n\tpublic zIndex: number;\n\t/** The texture to be rendered on the particle. Used in conjunction with mode 'TEXTURE'. */\n\tpublic texture: Texture2D;\n\t/** The scale applied to the textured quad. Used in conjunction with mode 'TEXTURE'. */\n\tpublic scale: number;\n\t/** How long it takes the particles shrink to nothing. \n\t * The particles will have 100% size until the particle reaches the end of its life, where the size will be lowered for the specified time until it dies.\n\t * Used in conjunction with mode 'TEXTURE'.\n\t */\n\tpublic shrinkTime: number;\n\n\t/** The vertex buffers used by the ParticleRenderer.\n\t * @internal\n\t */\n\tpublic buffers: VertexBuffer[];\n\t/** The vertex arrays used by the ParticleRenderer.\n\t * @internal\n\t */\n\tpublic vertexArrays: VertexArray[];\n\t/** The index to the current read buffer.\n\t * @internal\n\t */\n\tpublic read = 0;\n\t/** The index to the current read buffer.\n\t * @internal\n\t */\n\tpublic write = 1;\n\n\t/**\n\t * Create a new particle emitter.\n\t * @param {ParticleEmitterSettings} settings The settings. \n\t */\n\tpublic constructor(settings: ParticleEmitterSettings) {\n\t\tif (settings.mode) this.mode = settings.mode.toUpperCase();\n\t\telse this.mode = 'POINTS';\n\t\t\n\t\tthis.numParticles = settings.numParticles;\n\t\tthis.spawnRate = settings.spawnRate;\n\t\tthis.gravity = settings.gravity;\n\t\tthis.origin = settings.origin;\n\t\tthis.angle = settings.angle;\n\t\tthis.spread = settings.spread;\n\t\tthis.minSpeed = settings.minSpeed;\n\t\tthis.maxSpeed = settings.maxSpeed;\n\t\tthis.minLife = settings.minLife;\n\t\tthis.maxLife = settings.maxLife;\n\t\tthis.fadeTime = settings.fadeTime;\n\t\tthis.zIndex = settings.zIndex;\n\t\tthis.texture = settings.texture;\n\t\tthis.scale = settings.scale || 1.0;\n\t\tthis.shrinkTime = settings.shrinkTime;\n\n\t\t// VALIDATE INPUT //\n\t\tif (this.maxLife < this.minLife) \n\t\t\tconsole.error('Maximum life cannot be less than minimum life.');\n\t\t\n\t\tif (this.maxSpeed < this.minSpeed)\n\t\t\tconsole.error('Maximum speed cannot be less than minimum speed');\n\t\t\n\t\t// SETUP BUFFERS //\n\t\tthis.buffers = [\n\t\t\tnew VertexBuffer(initialParticleData(this.numParticles, this.minLife, this.maxLife), Surface.gl.STREAM_DRAW),\n\t\t\tnew VertexBuffer(initialParticleData(this.numParticles, this.minLife, this.maxLife), Surface.gl.STREAM_DRAW)\n\t\t];\n\t\t\n\t\tthis.vertexArrays = [new VertexArray(), new VertexArray(), new VertexArray(), new VertexArray()];\n\t\tlet layout;\n\t\tlayout = new BufferLayout([\n\t\t\tnew BufferElement(ShaderDataType.Float2, 'i_Position', false, 0),\n\t\t\tnew BufferElement(ShaderDataType.Float, 'i_Age', false, 0),\n\t\t\tnew BufferElement(ShaderDataType.Float, 'i_Life', false, 0),\n\t\t\tnew BufferElement(ShaderDataType.Float2, 'i_Velocity', false, 0)\n\t\t]);\n\t\t\n\t\tthis.buffers[0].setLayout(layout);\n\t\tthis.buffers[1].setLayout(layout);\n\n\t\tthis.vertexArrays[0].addVertexBuffer(this.buffers[0], ParticleRenderer.getUpdateShader());\n\t\tthis.vertexArrays[1].addVertexBuffer(this.buffers[1], ParticleRenderer.getUpdateShader());\n\t\t\n\n\t\tif (this.mode === 'TEXTURE') {\n\t\t\tlayout = new BufferLayout([\n\t\t\t\tnew BufferElement(ShaderDataType.Float2, 'i_Position', false, 1),\n\t\t\t\tnew BufferElement(ShaderDataType.Float, 'i_Age', false, 1),\n\t\t\t\tnew BufferElement(ShaderDataType.Float, 'i_Life', false, 1),\n\t\t\t\tnew BufferElement(ShaderDataType.Float2, 'i_Velocity', false, 1)\n\t\t\t]);\n\t\t\tthis.buffers[0].setLayout(layout);\n\t\t\tthis.buffers[1].setLayout(layout);\n\t\t\tthis.vertexArrays[2].addVertexBuffer(this.buffers[0], ParticleRenderer.getRenderTextureShader());\n\t\t\tthis.vertexArrays[3].addVertexBuffer(this.buffers[1], ParticleRenderer.getRenderTextureShader());\n\t\t\t\n\t\t\t// SETUP TEXTURE RENDERING BUFFERS //\n\n\t\t\tconst quadVertices = [\n\t\t\t\t-0.5, -0.5, 0.0, 1.0,\n\t\t\t\t0.5, -0.5, 1.0, 1.0,\n\t\t\t\t0.5,  0.5, 1.0, 0.0,\n\t\t\t\t-0.5, 0.5, 0.0, 0.0,\n\t\t\t];\n\t\t\tconst quadVB = new VertexBuffer(new Float32Array(quadVertices));\n\n\t\t\tconst indices = [ 0, 1, 2, 0, 2, 3];\n\t\t\tconst quadIB = new IndexBuffer(new Uint16Array(indices));\n\n\t\t\tconst quadLayout = new BufferLayout([\n\t\t\t\tnew BufferElement(ShaderDataType.Float2, 'i_Coord', false, 0),\n\t\t\t\tnew BufferElement(ShaderDataType.Float2, 'i_TexCoord', false, 0)\n\t\t\t]);\n\n\t\t\tquadVB.setLayout(quadLayout);\n\t\t\tthis.vertexArrays[2].setIndexBuffer(quadIB);\n\t\t\tthis.vertexArrays[3].setIndexBuffer(quadIB);\n\t\t\t\n\t\t\tthis.vertexArrays[2].addVertexBuffer(quadVB, ParticleRenderer.getRenderTextureShader());\n\t\t\tthis.vertexArrays[3].addVertexBuffer(quadVB, ParticleRenderer.getRenderTextureShader());\n\n\t\t}\n\t\telse {\n\t\t\tthis.vertexArrays[2].addVertexBuffer(this.buffers[0], ParticleRenderer.getRenderPointShader());\n\t\t\tthis.vertexArrays[3].addVertexBuffer(this.buffers[1], ParticleRenderer.getRenderPointShader());\n\t\t}\n\t}\n}\n\nfunction initialParticleData(numParticles: number, minLife: number, maxLife: number): Float32Array {\n\tlet data: number[] = [];\n\tfor (let i = 0; i < numParticles; ++i) {\n\t\t// Add position.\n\t\tdata.push(0.0);\n\t\tdata.push(0.0);\n\t\n\t\t// Add age and life.\n\t\tlet life = minLife + Math.random() * (maxLife - minLife);\n\n\t\t// Add age and life.\n\t\tdata.push(life + 1);\n\t\tdata.push(life);\n\t\n\t\t// Add velocity.\n\t\tdata.push(0.0);\n\t\tdata.push(0.0);\n\t}\n\treturn new Float32Array(data);\n}","import * as glm from 'gl-matrix';\nimport { Shader } from './Shader';\nimport { Surface } from './Surface';\nimport { ParticleEmitter } from './ParticleEmitter';\nimport { Texture2D } from './Texture';\nimport { RenderCommand } from './RenderCommand';\nimport { OrthographicCamera } from './OrthographicCamera';\nimport * as ParticleUpdateShaderSource from './ShaderSource/ParticleUpdateShaderSource';\nimport * as ParticlePointShaderSource from './ShaderSource/ParticlePointShaderSource';\nimport * as ParticleTextureShaderSource from './ShaderSource/ParticleTextureShaderSource';\n\nexport class ParticleRenderer {\n\n\tprivate static readonly RAND_WIDTH = 512;\n\tprivate static readonly RAND_HEIGHT = 512;\n\n\tprivate static updateShader: Shader;\n\tprivate static renderPointShader: Shader;\n\tprivate static renderTextureShader: Shader;\n\tprivate static randTexture: Texture2D;\n\t\n\tprivate static viewProjectionMatrix: glm.mat4;\n\n\t/**\n\t * Initialize the particle renderer.\n\t * @internal\n\t */\n\tpublic static init() {\n\t\t// SETUP SHADERS //\n\t\tthis.updateShader = new Shader('ParticleUpdateShader', ParticleUpdateShaderSource.getVertexSource(), ParticleUpdateShaderSource.getFragmentSource(), ['v_Position', 'v_Age', 'v_Life', 'v_Velocity']);\n\t\tthis.renderPointShader = new Shader('ParticlePointShader', ParticlePointShaderSource.getVertexSource(), ParticlePointShaderSource.getFragmentSource());\n\t\tthis.renderTextureShader = new Shader('ParticleTextureShader', ParticleTextureShaderSource.getVertexSource(), ParticleTextureShaderSource.getFragmentSource());\n\n\t\t// SETUP RANDOM TEXTURE //\n\t\tthis.randTexture = new Texture2D();\n\t\tthis.randTexture.loadFromArray(this.randomRGData(this.RAND_WIDTH, this.RAND_HEIGHT), this.RAND_WIDTH, this.RAND_HEIGHT, Surface.gl.RG8, Surface.gl.RG);\n\t}\n\n\t/** \n\t * Get the update shader.\n\t * @returns {Shader} The shader.\n\t */\n\tpublic static getUpdateShader(): Shader {\n\t\treturn this.updateShader;\n\t}\n\n\t/**\n\t * Get the point rendering shader\n\t * @returns {Shader} The shader.\n\t */\n\tpublic static getRenderPointShader(): Shader {\n\t\treturn this.renderPointShader;\n\t}\n\n\t/**\n\t * Get the texture rendering shader.\n\t * @returns {Shader} The shader.\n\t */\n\tpublic static getRenderTextureShader(): Shader {\n\t\treturn this.renderTextureShader;\n\t}\n\n\t/** Begin the rendering of a scene. */\n\tpublic static beginParticleScene(camera: OrthographicCamera) {\n\t\tthis.viewProjectionMatrix = camera.getViewProjectionMatrix();\n\t}\n\n\t/** End the rendering of a scene. */\n\tpublic static endParticleScene() {}\n\n\t/** \n\t * Render a particle emitter.\n\t * \n\t * @param {ParticleEmitter} emitter The emitter.\n\t * @param {number} dt The delta time. Time elapsed since lase frame.\n\t */\n\tpublic static renderParticleEmitter(emitter: ParticleEmitter, dt: number) {\n\t\tif (emitter.bornParticles < emitter.numParticles) {\n\t\t\temitter.bornParticles = Math.min(emitter.numParticles, emitter.bornParticles + emitter.spawnRate * dt);\n\t\t}\n\n\t\t// UPDATE EMITTER //\n\t\tthis.updateShader.bind();\n\t\tthis.updateShader.uploadUniformFloat('u_DeltaTime', dt);\n\t\tthis.updateShader.uploadUniformFloat2('u_Gravity', emitter.gravity);\n\t\tthis.updateShader.uploadUniformFloat2('u_Origin', emitter.origin);\n\t\tthis.updateShader.uploadUniformFloat('u_Angle', emitter.angle);\n\t\tthis.updateShader.uploadUniformFloat('u_Spread', emitter.spread);\n\t\tthis.updateShader.uploadUniformFloat('u_MinSpeed', emitter.minSpeed);\n\t\tthis.updateShader.uploadUniformFloat('u_MaxSpeed', emitter.maxSpeed);\n\t\t\n\t\tthis.randTexture.bind();\n\t\tthis.updateShader.uploadUniformInt('u_RandNoise', 0);\n\n\t\tSurface.gl.bindBuffer(Surface.gl.ARRAY_BUFFER, null);\n\n\t\temitter.vertexArrays[emitter.read].bind();\n\t\temitter.buffers[emitter.write].bindBufferBase(Surface.gl.TRANSFORM_FEEDBACK_BUFFER, 0);\n\t\tSurface.gl.enable(Surface.gl.RASTERIZER_DISCARD);\n\n\t\tSurface.gl.beginTransformFeedback(Surface.gl.POINTS);\n\t\tRenderCommand.drawArrays(Math.floor(emitter.bornParticles), Surface.gl.POINTS);\n\t\tSurface.gl.endTransformFeedback();\n\n\t\tSurface.gl.disable(Surface.gl.RASTERIZER_DISCARD);\n\t\temitter.buffers[emitter.write].unbindBufferBase(Surface.gl.TRANSFORM_FEEDBACK_BUFFER, 0);\n\n\t\t// RENDER EMITTER //\n\t\temitter.vertexArrays[emitter.read + 2].bind();\n\t\tif (emitter.mode === 'TEXTURE') {\n\t\t\tthis.renderTextureShader.bind();\n\t\t\tthis.renderTextureShader.uploadUniformFloat('u_zIndex', emitter.zIndex);\n\t\t\tthis.renderTextureShader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\t\tthis.renderTextureShader.uploadUniformFloat('u_FadeTime', emitter.fadeTime);\n\t\t\tthis.renderTextureShader.uploadUniformFloat('u_Scale', emitter.scale);\n\t\t\tthis.renderTextureShader.uploadUniformFloat('u_ShrinkTime', emitter.shrinkTime);\n\t\t\tthis.renderTextureShader.uploadUniformInt('u_Texture', 0);\n\t\t\tthis.renderTextureShader.uploadUniformInt('u_InstanceCount', Math.floor(emitter.bornParticles));\n\t\t\temitter.texture.bind();\n\t\t\tRenderCommand.drawElementsInstanced(emitter.vertexArrays[emitter.read + 2], Math.floor(emitter.bornParticles));\n\t\t}\n\t\telse {\n\t\t\tthis.renderPointShader.bind();\n\t\t\tthis.renderPointShader.uploadUniformFloat('u_zIndex', emitter.zIndex);\n\t\t\tthis.renderPointShader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\t\tthis.renderPointShader.uploadUniformFloat('u_FadeTime', emitter.fadeTime);\n\t\t\tRenderCommand.drawArrays(Math.floor(emitter.bornParticles), Surface.gl.POINTS);\n\t\t}\n\n\t\t// SWAP BUFFERS //\n\t\tlet tmp = emitter.read;\n\t\temitter.read = emitter.write;\n\t\temitter.write = tmp;\n\t}\n\n\t/** \n\t * Generate an image with random red-green data.\n\t * \n\t * @param {number} width The width of the image.\n\t * @param {number} height The height of the image.\n\t * @returns {Uint8Array} The pixel array.\n\t */\n\tprivate static randomRGData(width: number, height: number): Uint8Array {\n\t\tlet d = [];\n\t\tfor (let i = 0; i < width * height; ++i) {\n\t\t\td.push(Math.random() * 255.0);\n\t\t\td.push(Math.random() * 255.0);\n\t\t}\n\t\treturn new Uint8Array(d);\n\t}\n}","import * as glm from 'gl-matrix';\nimport { Surface } from './Surface';\nimport { Shader } from './Shader';\nimport { FrameBuffer } from './FrameBuffer';\nimport { RenderBuffer } from './RenderBuffer';\nimport { VertexBuffer, IndexBuffer, BufferElement, BufferLayout, ShaderDataType } from './Buffer';\nimport { VertexArray } from './VertexArray';\nimport { Texture2D } from './Texture';\nimport { RenderCommand } from './RenderCommand';\nimport { Event, EventDispatcher, EventHandler } from '../Events/Event';\nimport { CanvasResizeEvent } from '../Events/ApplicationEvent';\n\nexport class PostprocessingStage implements EventHandler {\n\n\tprotected name: string;\n\tprotected shader: Shader;\n\tprotected fbo: FrameBuffer;\n\tprotected screenVA: VertexArray;\n\tprotected enabled: boolean;\n\n\tprotected uniforms: Map<string, [ShaderDataType, number | glm.vec2 | glm.vec3 | glm.vec4 | glm.mat3 | glm.mat4 | boolean | Float32Array]>;\n\n\t/**\n\t * Create a new postprocessing stage.\n\t * @param {string} name The name of the stage.\n\t * @param {Shader} shader The shader.\n\t * @param {boolean} enabled Whether the stage will be used when rendering.\n\t * @param {[string, ShaderDataType, number | glm.vec2 | glm.vec3 | glm.vec4 | glm.mat3 | glm.mat4 | boolean | Float32Array][]} uniforms Fixed value uniforms used in the shader. Format: [name, [ShaderDataType, value]]\n\t * \n\t * @example uniforms = [['u_Brightness', [Polar.ShaderDataType.Float, 2]]]\n\t */\n\tpublic constructor(name: string, shader: Shader, enabled = true, uniforms: Map<string, [ShaderDataType, number | glm.vec2 | glm.vec3 | glm.vec4 | glm.mat3 | glm.mat4 | boolean | Float32Array]> = new Map<string, [ShaderDataType, number | glm.vec2 | glm.vec3 | glm.vec4 | glm.mat3 | glm.mat4 | boolean | Float32Array]>()) {\n\t\tthis.name = name;\n\t\tthis.shader = shader;\n\t\tthis.enabled = enabled;\n\t\tthis.uniforms = uniforms;\n\t\t// SETUP FRAME BUFFER //\n\t\tthis.fbo = new FrameBuffer();\n\t\tthis.fbo.bind();\n\n\t\t// ATTACH TEXTURE //\n\t\tconst texture = new Texture2D();\n\t\ttexture.loadEmpty(Surface.getWidth(), Surface.getHeight(), Surface.gl.RGBA);\n\t\ttexture.bind();\n\t\tthis.fbo.attachTexture(texture, Surface.gl.COLOR_ATTACHMENT0);\n\t\t\n\t\t// ATTACH RENDER BUFFER //\n\t\tconst rbo = new RenderBuffer();\n\t\trbo.storage(Surface.getWidth(), Surface.getHeight(), Surface.gl.DEPTH24_STENCIL8);\n\t\tthis.fbo.attachRenderbuffer(rbo);\n\n\t\tif (!this.fbo.isComplete())\n\t\t\tconsole.error('Framebuffer not complete!');\n\t\t\n\t\tthis.screenVA = new VertexArray();\n\n\t\tconst quadVertices = [\n\t\t\t-1, -1, 0.0, 0.0, 0,\n\t\t\t1, -1, 0.0, 1.0, 0,\n\t\t\t1,  1, 0.0, 1.0, 1.0,\n\t\t\t-1,  1, 0.0, 0.0, 1.0\n\t\t];\n\n\t\tconst quadVB = new VertexBuffer(new Float32Array(quadVertices));\n\n\t\tconst quadIndices = [0, 1, 2, 0, 2, 3];\n\t\tconst quadIB = new IndexBuffer(new Uint16Array(quadIndices));\n\t\tthis.screenVA.setIndexBuffer(quadIB);\n\n\t\tconst quadLayout = new BufferLayout([\n\t\t\tnew BufferElement(ShaderDataType.Float3, 'a_Position'),\n\t\t\tnew BufferElement(ShaderDataType.Float2, 'a_TexCoord')\n\t\t]);\n\n\t\tquadVB.setLayout(quadLayout);\n\t\tthis.screenVA.addVertexBuffer(quadVB, this.shader);\n\n\t\tthis.screenVA.unbind();\n\t\tthis.fbo.unbind();\n\t\tthis.fbo.getTexture().unbind();\n\t}\n\n\t/** Bind the postprocessing stage\n\t * @internal\n\t */\n\tpublic bind() {\n\t\tthis.fbo.bind();\n\t}\n\n\t/** Unbinds the postprocessing stage\n\t * @internal\n\t */\n\tpublic unbind() {\n\t\tthis.fbo.unbind();\n\t}\n\n\t/** Renders the stage to the currently bound framebuffer.\n\t * @remarks Generally only used within the Polar Renderer.\n\t */\n\tpublic render() {\n\t\tthis.screenVA.bind();\n\t\tthis.fbo.getTexture().bind();\n\t\tthis.shader.bind();\n\t\tthis.shader.uploadUniformInt('u_Texture', 0);\n\t\tthis.uploadCustomUniforms();\n\t\tRenderCommand.drawElements(this.screenVA);\n\t}\n\n\t/** Get the name of the stage.\n\t * @returns {string} The name.\n\t */\n\tpublic getName(): string {\n\t\treturn this.name;\n\t}\n\n\t/** Check if the stage is enabled.\n\t * @returns {boolean} Whether the stage is enabled.\n\t */\n\tpublic isEnabled(): boolean {\n\t\treturn this.enabled;\n\t}\n\n\t/** Enables the stage. */\n\tpublic enable() {\n\t\tthis.enabled = true;\n\t}\n\n\t/** Disables the stage. */\n\tpublic disable() {\n\t\tthis.enabled = false;\n\t}\n\n\tprotected uploadCustomUniforms() {\n\t\tfor (const [name, [type, value]] of this.uniforms) {\n\t\t\tif (type === ShaderDataType.Int) {\n\t\t\t\tthis.shader.uploadUniformInt(name, <number>value);\n\t\t\t}\n\t\t\telse if (type === ShaderDataType.Float) {\n\t\t\t\tthis.shader.uploadUniformFloat(name, <number>value);\n\t\t\t}\n\t\t\telse if (type === ShaderDataType.Float2) {\n\t\t\t\tthis.shader.uploadUniformFloat2(name, <glm.vec2>value);\n\t\t\t}\n\t\t\telse if (type === ShaderDataType.Float3) {\n\t\t\t\tthis.shader.uploadUniformFloat3(name, <glm.vec3>value);\n\t\t\t}\n\t\t\telse if (type === ShaderDataType.Float4) {\n\t\t\t\tthis.shader.uploadUniformFloat4(name, <glm.vec4>value);\n\t\t\t}\n\t\t\telse if (type === ShaderDataType.Mat3) {\n\t\t\t\tthis.shader.uploadUniformMat3(name, <glm.mat3>value);\n\t\t\t}\n\t\t\telse if (type === ShaderDataType.Mat4) {\n\t\t\t\tthis.shader.uploadUniformMat4(name, <glm.mat4>value);\n\t\t\t}\n\t\t\telse if (type === ShaderDataType.Bool) {\n\t\t\t\tthis.shader.uploadUniformBool(name, <boolean>value);\n\t\t\t}\n\t\t\telse if (type === ShaderDataType.FloatArray) {\n\t\t\t\tthis.shader.uploadUniformFloatArray(name, <Float32Array>value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.error(`Unknown ShaderDataType: '${type}'`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set a postprocessing uniform.\n\t * @param {string} name The uniform's name within the shader.\n\t * @param {number | glm.vec2 | glm.vec3 | glm.vec4 | glm.mat3 | glm.mat4 | boolean | Float32Array} value The value to set the uniform to.\n\t */\n\tpublic setUniform(name: string, value: number | glm.vec2 | glm.vec3 | glm.vec4 | glm.mat3 | glm.mat4 | boolean | Float32Array) {\n\t\tthis.uniforms.set(name, [this.uniforms.get(name)[0], value]);\n\t}\n\n\tpublic onEvent(event: Event) {\n\t\tconst dispatcher = new EventDispatcher(event);\n\t\tdispatcher.dispatch(CanvasResizeEvent, this.onCanvasResize.bind(this));\n\t}\n\n\tprivate onCanvasResize(event: CanvasResizeEvent): boolean {\n\t\tthis.fbo.resize(event.width, event.height);\n\t\treturn false;\n\t}\n}","import { Surface } from './Surface';\n\n/** Represents an OpenGL renderbuffer. */\nexport class RenderBuffer {\n\n\tprivate renderbuffer: WebGLRenderbuffer;\n\n\tprivate width: number;\n\tprivate height: number;\n\tprivate internalFormat: number;\n\tprivate target: number;\n\n\t/** Create a new renderbuffer. */\n\tpublic constructor() {\n\t\tthis.renderbuffer = Surface.gl.createRenderbuffer();\n\t}\n\n\t/** Bind the OpenGL renderbuffer\n\t * @param {number} [target=RENDERBUFFER] The OpenGL target.\n\t */\n\tpublic bind(target: number = Surface.gl.RENDERBUFFER) {\n\t\tSurface.gl.bindRenderbuffer(target, this.renderbuffer);\n\t}\n\n\t/**\n\t * Unbind the OpenGL renderbuffer.\n\t * @param {number} [target=RENDERBUFFER] The OpenGL target.\n\t */\n\tpublic unbind(target: number = Surface.gl.RENDERBUFFER) {\n\t\tSurface.gl.bindRenderbuffer(target, null);\n\t}\n\n\t/**\n\t * Set the renderbuffer's storage.\n\t * @param {number} width The storage width.\n\t * @param {number} height The storage height.\n\t * @param {number} [internalFormat=DEPTH24_STENCIL8] The OpenGL internal format.\n\t * @param {number} [target=RENDERBUFFER] The OpenGL target.\n\t */\n\tpublic storage(width: number, height: number, internalFormat = Surface.gl.DEPTH24_STENCIL8, target: number = Surface.gl.RENDERBUFFER) {\n\t\tSurface.gl.bindRenderbuffer(target, this.renderbuffer);\n\t\tSurface.gl.renderbufferStorage(target, internalFormat, width, height);\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.target = target;\n\t}\n\n\t/** Get the OpenGL renderbuffer.\n\t * @returns {WebGLRenderbuffer} The renderbuffer.\n\t */\n\tpublic getGLRenderbuffer(): WebGLRenderbuffer {\n\t\treturn this.renderbuffer;\n\t}\n\n\tpublic resize(width: number, height: number) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tSurface.gl.deleteRenderbuffer(this.renderbuffer);\n\t\tthis.renderbuffer = Surface.gl.createRenderbuffer();\n\t\tSurface.gl.bindRenderbuffer(this.target, this.renderbuffer);\n\t\tSurface.gl.renderbufferStorage(this.target, this.internalFormat, this.width, this.height);\n\t}\n}","import * as glm from 'gl-matrix';\nimport { Surface } from './Surface';\nimport { VertexArray } from './VertexArray';\n\n/** Static class which acts as an abstraction layer from raw OpenGL function calls. */\nexport class RenderCommand {\n\n\t/** Initialize the renderer. \n\t * @internal\n\t*/\n\tpublic static init() {\n\t\tSurface.gl.enable(Surface.gl.BLEND);\n\t\tSurface.gl.enable(Surface.gl.DEPTH_TEST);\n\t\tSurface.gl.blendFunc(Surface.gl.SRC_ALPHA, Surface.gl.ONE_MINUS_SRC_ALPHA);\n\t}\n\n\t/** Set the OpenGL clear color. */\n\tpublic static setClearColor(color: glm.vec4) {\n\t\tSurface.gl.clearColor(color[0], color[1], color[2], color[3]);\n\t}\n\n\t/** Clear the OpenGL buffers. */\n\tpublic static clear() {\n\t\tSurface.gl.clear(Surface.gl.COLOR_BUFFER_BIT | Surface.gl.DEPTH_BUFFER_BIT);\n\t}\n\n\t/** \n\t * OpenGL draw elements\n\t * @param {VertexArray} vertexArray The vertex array.\n\t * @param {number} [mode=TRIANGLES] The mode.\n\t */\n\tpublic static drawElements(vertexArray: VertexArray, mode: number = Surface.gl.TRIANGLES) {\n\t\tSurface.gl.drawElements(mode, vertexArray.getIndexBuffer().getCount(), Surface.gl.UNSIGNED_SHORT, 0);\n\t}\n\n\t/**\n\t * OpenGL draw elements instanced\n\t * @param {VertexArray} vertexArray The vertex array.\n\t * @param {number} instanceCount The number of instances to render.\n\t * @param {number} mode The OpenGL mode.\n\t * @param {number} offset The offset.\n\t */\n\tpublic static drawElementsInstanced(vertexArray: VertexArray, instanceCount: number, mode: number = Surface.gl.TRIANGLES, offset: number = 0) {\n\t\tSurface.gl.drawElementsInstanced(mode, vertexArray.getIndexBuffer().getCount(), Surface.gl.UNSIGNED_SHORT, offset, instanceCount);\n\t}\n\n\t/**\n\t * OpenGL draw arrays.\n\t * @param {number} count The number of vertices.\n\t * @param {number} [mode=POINTS] The OpenGL mode.\n\t */\n\tpublic static drawArrays(count: number, mode: number = Surface.gl.POINTS) {\n\t\tSurface.gl.drawArrays(mode, 0, count);\n\t}\n\n\t/**\n\t * OpenGL draw arrays instanced.\n\t * @param {number} count The count.\n\t * @param {number} instanceCount The number of instances to draw.\n\t * @param {number} [mode=TRIANGLES] The OpenGL mode.\n\t */\n\tpublic static drawArraysInstanced(count: number, instanceCount: number, mode: number = Surface.gl.TRIANGLES) {\n\t\tSurface.gl.drawArraysInstanced(mode, 0, count, instanceCount);\n\t}\n}","import * as glm from 'gl-matrix';\nimport { VertexArray } from './VertexArray';\nimport { Shader } from './Shader';\nimport { RenderCommand } from './RenderCommand';\nimport { OrthographicCamera } from './OrthographicCamera';\nimport { ShaderLibrary } from './ShaderLibrary';\nimport { VertexBuffer, BufferElement, BufferLayout, ShaderDataType, IndexBuffer } from './Buffer';\nimport { Sprite } from './Sprite';\nimport { Texture2D } from './Texture';\nimport { Surface } from './Surface';\nimport { createTransform } from '../Util/Math';\nimport { ParticleRenderer } from './ParticleRenderer';\nimport { InstancedRenderer } from './InstancedRenderer';\nimport { LightRenderer } from './LightRenderer';\nimport { PostprocessingStage } from './PostprocessingStage';\nimport { Event } from '../Events/Event';\nimport * as TextureShaderSource from './ShaderSource/TextureShaderSource';\nimport * as ColorShaderSource from './ShaderSource/ColorShaderSource';\n\n/** Handles the rendering objects to the canvas, including post.\n * \n * @remarks For instanced rendering, see {@link Polar#InstancedRenderer | InstancedRenderer}\n */\nexport class Renderer {\n\tprivate static viewProjectionMatrix: glm.mat4;\n\tprivate static shaderLibrary: ShaderLibrary;\n\n\tprivate static textureQuadVA: VertexArray;\n\tprivate static colorQuadVA: VertexArray;\n\tprivate static outlineQuadVA: VertexArray;\n\tprivate static lineVA: VertexArray;\n\tprivate static circleVA: VertexArray;\n\t\n\t// POST PROCESSING //\n\tprivate static postprocessingStages: PostprocessingStage[];\n\n\tprivate static doLighting: boolean = false;\n\n\t/** Initialize the renderer. */\n\tpublic static init() {\n\t\tRenderCommand.init();\n\t\tParticleRenderer.init();\n\t\tInstancedRenderer.init();\n\t\tLightRenderer.init();\n\n\t\tthis.postprocessingStages = [];\n\n\t\tthis.initShaders();\n\t\tthis.initBuffers();\n\t}\n\n\t/** Initialize shaders */\n\tprivate static initShaders() {\n\t\tthis.shaderLibrary = new ShaderLibrary();\n\t\tconst textureShader = new Shader('TextureShader', TextureShaderSource.getVertexSource(), TextureShaderSource.getFragmentSource());\n\t\tthis.shaderLibrary.add(textureShader);\n\n\t\tconst colorShader = new Shader('ColorShader', ColorShaderSource.getVertexSource(), ColorShaderSource.getFragmentSource());\n\t\tthis.shaderLibrary.add(colorShader);\n\t}\n\n\t/** Initialize buffers */\n\tprivate static initBuffers() {\n\t\t\n\t\t// CREATE TEXTURE QUAD //\n\t\t{\n\t\t\tthis.textureQuadVA = new VertexArray();\n\n\t\t\tconst quadVertices = [\n\t\t\t\t-0.5, -0.5, 0.0, 0.0, 1.0,\n\t\t\t\t 0.5, -0.5, 0.0, 1.0, 1.0,\n\t\t\t\t 0.5,  0.5, 0.0, 1.0, 0.0,\n\t\t\t\t-0.5,  0.5, 0.0, 0.0, 0.0\n\t\t\t];\n\n\t\t\tconst quadVB = new VertexBuffer(new Float32Array(quadVertices));\n\n\t\t\tconst quadIndices = [0, 1, 2, 0, 2, 3];\n\t\t\tconst quadIB = new IndexBuffer(new Uint16Array(quadIndices));\n\t\t\tthis.textureQuadVA.setIndexBuffer(quadIB);\n\n\t\t\tconst quadLayout = new BufferLayout([\n\t\t\t\tnew BufferElement(ShaderDataType.Float3, 'a_Position'),\n\t\t\t\tnew BufferElement(ShaderDataType.Float2, 'a_TexCoord')\n\t\t\t]);\n\n\t\t\tquadVB.setLayout(quadLayout);\n\t\t\tthis.textureQuadVA.addVertexBuffer(quadVB, this.shaderLibrary.get('TextureShader'));\n\t\t}\n\t\t// CREATE COLORED QUAD //\n\t\t{\n\t\t\tthis.colorQuadVA = new VertexArray();\n\n\t\t\tconst quadVertices = [\n\t\t\t\t-0.5, -0.5, 0.0,\n\t\t\t\t 0.5, -0.5, 0.0,\n\t\t\t\t 0.5,  0.5, 0.0,\n\t\t\t\t-0.5,  0.5, 0.0,\n\t\t\t];\n\n\t\t\tconst quadVB = new VertexBuffer(new Float32Array(quadVertices));\n\n\t\t\tconst quadIndices = [0, 1, 2, 0, 2, 3];\n\t\t\tconst quadIB = new IndexBuffer(new Uint16Array(quadIndices));\n\t\t\tthis.colorQuadVA.setIndexBuffer(quadIB);\n\n\t\t\tconst quadLayout = new BufferLayout([\n\t\t\t\tnew BufferElement(ShaderDataType.Float3, 'a_Position')\n\t\t\t]);\n\n\t\t\tquadVB.setLayout(quadLayout);\n\t\t\tthis.colorQuadVA.addVertexBuffer(quadVB, this.shaderLibrary.get('ColorShader'));\n\t\t\tthis.colorQuadVA.unbind();\n\t\t}\n\t\t// CREATE COLORED OUTLINE QUAD //\n\t\t{\n\t\t\tthis.outlineQuadVA = new VertexArray();\n\n\t\t\tconst quadVertices = [\n\t\t\t\t-0.5, -0.5, 0.0,\n\t\t\t\t 0.5, -0.5, 0.0,\n\t\t\t\t 0.5,  0.5, 0.0,\n\t\t\t\t-0.5,  0.5, 0.0,\n\t\t\t];\n\n\t\t\tconst quadVB = new VertexBuffer(new Float32Array(quadVertices));\n\n\t\t\tconst quadIndices = [0, 1, 2, 3];\n\t\t\tconst quadIB = new IndexBuffer(new Uint16Array(quadIndices));\n\t\t\tthis.outlineQuadVA.setIndexBuffer(quadIB);\n\n\t\t\tconst quadLayout = new BufferLayout([\n\t\t\t\tnew BufferElement(ShaderDataType.Float3, 'a_Position')\n\t\t\t]);\n\n\t\t\tquadVB.setLayout(quadLayout);\n\t\t\tthis.outlineQuadVA.addVertexBuffer(quadVB, this.shaderLibrary.get('ColorShader'));\n\t\t\tthis.outlineQuadVA.unbind();\n\t\t}\n\t\t// CREATE LINE //\n\t\t{\n\t\t\tthis.lineVA = new VertexArray();\n\n\t\t\tconst vertices = [\n\t\t\t\t0.0, 0.0, 0.0,\n\t\t\t\t1.0, 0.0, 0.0,\n\t\t\t];\n\n\t\t\tconst vertexBuffer = new VertexBuffer(new Float32Array(vertices));\n\n\t\t\tconst indices = [0, 1];\n\t\t\tconst indexBuffer = new IndexBuffer(new Uint16Array(indices));\n\t\t\tthis.lineVA.setIndexBuffer(indexBuffer);\n\n\t\t\tconst layout = new BufferLayout([\n\t\t\t\tnew BufferElement(ShaderDataType.Float3, 'a_Position')\n\t\t\t]);\n\n\t\t\tvertexBuffer.setLayout(layout);\n\t\t\tthis.lineVA.addVertexBuffer(vertexBuffer, this.shaderLibrary.get('ColorShader'));\n\t\t\tthis.lineVA.unbind();\n\t\t}\n\t\t// CREATE CIRCLE //\n\t\t{\n\t\t\tthis.circleVA = new VertexArray();\n\n\t\t\tconst vertices: number[] = [];\n\t\t\tconst indices: number[] = [];\n\n\t\t\tconst resolution = 64;\n\t\t\tfor (let i = 0; i < resolution; i++) {\n\t\t\t\tconst angle = i / resolution * 2 * Math.PI;\n\t\t\t\tvertices.push(Math.cos(angle));\n\t\t\t\tvertices.push(Math.sin(angle));\n\t\t\t\tvertices.push(0.0);\n\t\t\t\tindices.push(i);\n\t\t\t}\n\n\t\t\tconst vertexBuffer = new VertexBuffer(new Float32Array(vertices));\n\n\t\t\tconst indexBuffer = new IndexBuffer(new Uint16Array(indices));\n\t\t\tthis.circleVA.setIndexBuffer(indexBuffer);\n\n\t\t\tconst layout = new BufferLayout([\n\t\t\t\tnew BufferElement(ShaderDataType.Float3, 'a_Position')\n\t\t\t]);\n\n\t\t\tvertexBuffer.setLayout(layout);\n\t\t\tthis.circleVA.addVertexBuffer(vertexBuffer, this.shaderLibrary.get('ColorShader'));\n\t\t\tthis.circleVA.unbind();\n\t\t}\n\t}\n\n\t/**\n\t * Called every event. Not to be called by users.\n\t * @internal\n\t * @param {Event} event The event.\n\t */\n\tpublic static onEvent(event: Event) {\n\t\tLightRenderer.onEvent(event);\n\t}\n\n\t/** Begin the rendering of a scene.\n\t * @remarks To be called every frame before using any rendering commands. Used in conjunction with Renderer.endScene().\n\t * @param {OrthographicCamera} camera The scene's camera.\n\t */\n\tpublic static beginScene(camera: OrthographicCamera) {\n\t\tif (Surface.isResizing()) return;\n\t\t\t\n\t\tthis.viewProjectionMatrix = camera.getViewProjectionMatrix();\n\t\t\n\t\tSurface.gl.bindFramebuffer(Surface.gl.FRAMEBUFFER, null);\n\t\tSurface.clear();\n\t\tfor (const stage of this.postprocessingStages) {\n\t\t\tstage.bind();\n\t\t\tSurface.clear();\n\t\t\tstage.unbind();\n\t\t}\n\n\t\tif (this.doLighting) {\n\t\t\tLightRenderer.beginScene(camera);\n\t\t}\n\t\telse if (this.postprocessingStages.length >= 1) {\n\t\t\tconst next = this.postprocessingStages.find((stage: PostprocessingStage) => {\n\t\t\t\treturn stage.isEnabled();\n\t\t\t});\n\t\t\tif (next)  {\n\t\t\t\tnext.bind();\n\t\t\t}\n\t\t}\n\t\t\n\t\tInstancedRenderer.beginScene(camera);\n\t}\n\n\t/** End the rendering of a scene.\n\t * @remarks To be called every frame when all the rendering has been completed. Displays the results of all rendering commands.\n\t */\n\tpublic static endScene() {\n\t\tif (Surface.isResizing()) return;\n\t\tInstancedRenderer.endScene();\n\t\t\n\t\tif (this.doLighting) {\n\t\t\tLightRenderer.endScene();\n\t\t\tif (this.postprocessingStages.length >= 1) {\n\t\t\t\tconst next = this.postprocessingStages.find((stage: PostprocessingStage) => {\n\t\t\t\t\treturn stage.isEnabled();\n\t\t\t\t});\n\t\t\t\tif (next)  {\n\t\t\t\t\tnext.bind();\n\t\t\t\t}\n\t\t\t}\n\t\t\tLightRenderer.render();\n\t\t}\n\n\t\tfor (let i = 0; i < this.postprocessingStages.length; i++) {\n\t\t\t// Get next enabled framebuffer.\n\t\t\tconst next = this.postprocessingStages.slice(i + 1).find((stage: PostprocessingStage) => {\n\t\t\t\treturn stage.isEnabled();\n\t\t\t});\n\n\t\t\t// Bind next frame buffer if it exists.\n\t\t\tif (next) next.bind();\n\t\t\t// Else target the screen's framebuffer (ie. none bound).\n\t\t\telse this.postprocessingStages[i].unbind();\n\t\t\t\n\t\t\t// Render the current stage to the next framebuffer.\n\t\t\tif (this.postprocessingStages[i].isEnabled())\n\t\t\t\tthis.postprocessingStages[i].render();\n\t\t}\n\t}\n\n\t/** Submit a sprite for rendering.\n\t * @param {Sprite} sprite The sprite to be rendered.\n\t */\n\tpublic static submitSprite(sprite: Sprite) {\n\t\tif (Surface.isResizing()) return;\n\t\tconst shader = this.shaderLibrary.get('TextureShader');\n\t\tsprite.getTexture().bind();\n\n\t\tshader.bind();\n\t\tshader.uploadUniformInt('u_Texture', 0);\n\t\tshader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\tshader.uploadUniformMat4('u_Transform', sprite.getTransform());\n\n\t\tthis.textureQuadVA.bind();\n\t\tRenderCommand.drawElements(this.textureQuadVA);\n\t}\n\n\t/** Submit a texture for rendering.\n\t * @param {Texture2D} texture The texture.\n\t * @param {glm.mat4} transform The transform to be applied to the texture.\n\t */\n\tpublic static submitTextured(texture: Texture2D, transform: glm.mat4) {\n\t\tif (Surface.isResizing()) return;\n\t\tconst shader = this.shaderLibrary.get('TextureShader');\n\t\ttexture.bind();\n\n\t\tshader.bind();\n\t\tshader.uploadUniformInt('u_Texture', 0);\n\t\tshader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\tshader.uploadUniformMat4('u_Transform', transform);\n\n\t\tthis.textureQuadVA.bind();\n\t\tRenderCommand.drawElements(this.textureQuadVA);\n\t}\n\n\t/** Draw lines from a vertex array. \n\t * @param {VertexArray} linesVA The vertex array.\n\t * @param {glm.vec4} color The color used to draw.\n\t * @param {glm.mat4} transform The transformation matrix.\n\t*/\n\tpublic static submitLines(linesVA: VertexArray, color: glm.vec4, transform: glm.mat4) {\n\t\tif (Surface.isResizing()) return;\n\t\tconst shader = this.shaderLibrary.get('ColorShader');\n\n\t\tshader.bind();\n\t\tshader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\tshader.uploadUniformMat4('u_Transform', transform);\n\t\tshader.uploadUniformFloat4('u_Color', color);\n\n\t\tlinesVA.bind();\n\t\tRenderCommand.drawElements(linesVA, Surface.gl.LINES);\n\t}\n\n\t/** Draw a line strip from a vertex array.\n\t * @param {VertexArray} stripVA The vertex array.\n\t * @param {glm.vec4} color The color used to draw.\n\t * @param {glm.mat4} transform The transformation matrix.\n\t */\n\tpublic static submitLineStrip(stripVA: VertexArray, color: glm.vec4, transform: glm.mat4) {\n\t\tif (Surface.isResizing()) return;\n\t\tconst shader = this.shaderLibrary.get('ColorShader');\n\n\t\tshader.bind();\n\t\tshader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\tshader.uploadUniformMat4('u_Transform', transform);\n\t\tshader.uploadUniformFloat4('u_Color', color);\n\n\t\tstripVA.bind();\n\t\tRenderCommand.drawElements(stripVA, Surface.gl.LINE_STRIP);\n\t}\n\n\t/**\n\t * Draw a colored outline of a shape.\n\t * @param {VertexArray} loopVA The loop's vertices.\n\t * @param {glm.vec4} color The color of the square.\n\t * @param {glm.mat4} transform The transformation matrix.\n\t */\n\tpublic static submitLoop(loopVA: VertexArray, color: glm.vec4, transform: glm.mat4) {\n\t\tif (Surface.isResizing()) return;\n\t\tconst shader = this.shaderLibrary.get('ColorShader');\n\n\t\tshader.bind();\n\t\tshader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\tshader.uploadUniformMat4('u_Transform', transform);\n\t\tshader.uploadUniformFloat4('u_Color', color);\n\n\t\tloopVA.bind();\n\t\tRenderCommand.drawElements(loopVA, Surface.gl.LINE_LOOP);\n\t}\n\n\t/**\n\t * Draw the outline of a quad.\n\t * @param {glm.vec4} color The color used to draw.\n\t * @param {glm.mat4} transform The transformation matrix. \n\t */\n\tpublic static submitColoredOutline(color: glm.vec4, transform: glm.mat4) {\n\t\tif (Surface.isResizing()) return;\n\t\tconst shader = this.shaderLibrary.get('ColorShader');\n\n\t\tshader.bind();\n\t\tshader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\tshader.uploadUniformMat4('u_Transform', transform);\n\t\tshader.uploadUniformFloat4('u_Color', color);\n\n\t\tthis.outlineQuadVA.bind();\n\t\tRenderCommand.drawElements(this.outlineQuadVA, Surface.gl.LINE_LOOP);\n\t}\n\n\t/**\n\t * Draw a single colored line.\n\t * @param {number} x0 The first x coordinate.\n\t * @param {number} y0 The first y coordinate.\n\t * @param {number} x1 The second x coordinate.\n\t * @param {number} y1 The second y coordinate.\n\t * @param {glm.vec4} color The color used to draw.\n\t * @param {number} [zIndex=0] How far / close the line is to the camera.\n\t */\n\tpublic static submitLine(x0: number, y0: number, x1: number, y1: number, color: glm.vec4, zIndex: number = 0) {\n\t\tif (Surface.isResizing()) return;\n\t\tconst shader = this.shaderLibrary.get('ColorShader');\n\t\tconst dx = x1 - x0;\n\t\tconst dy = y1 - y0;\n\t\tlet angle = 0;\n\t\tif (dx == 0) {\n\t\t\tangle = dy > 0 ? Math.PI / 2 : 3 * Math.PI / 2;\n\t\t}\n\t\telse {\n\t\t\tangle = dx > 0 ? Math.atan(dy / dx) : Math.PI + Math.atan(dy / dx);\n\t\t}\n\n\t\tshader.bind();\n\t\tshader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\tshader.uploadUniformMat4('u_Transform', createTransform(x0, y0, angle, Math.sqrt(dx*dx + dy*dy), 0, zIndex));\n\t\tshader.uploadUniformFloat4('u_Color', color);\n\n\t\tthis.lineVA.bind();\n\t\tRenderCommand.drawElements(this.lineVA, Surface.gl.LINE_LOOP);\n\t}\n\n\t/**\n\t * Draw a colored circle outline.\n\t * @param {number} x The x coordinate of the center of the circle.\n\t * @param {number} y The y coordinate of the center of the circle.\n\t * @param {number} radius The radius of the circle.\n\t * @param {glm.vec4} color The color used to draw.\n\t * @param {number} [zIndex=0] How far / close the line is to the camera.\n\t */\n\tpublic static submitCircle(x: number, y: number, radius: number, color: glm.vec4, zIndex: number = 0) {\n\t\tif (Surface.isResizing()) return;\n\t\tconst shader = this.shaderLibrary.get('ColorShader');\n\n\t\tshader.bind();\n\t\tshader.uploadUniformMat4('u_ViewProjection', this.viewProjectionMatrix);\n\t\tshader.uploadUniformMat4('u_Transform', createTransform(x, y, 0, radius, radius, zIndex));\n\t\tshader.uploadUniformFloat4('u_Color', color);\n\n\t\tthis.circleVA.bind();\n\t\tRenderCommand.drawElements(this.circleVA, Surface.gl.LINE_LOOP);;\n\t}\n\n\t/** Get the world position from a screen position.\n\t * @param {glm.vec2} position The screen position.\n\t * @returns {glm.vec2} The world position.\n\t */\n\tpublic static screenToWorldPosition(position: glm.vec2): glm.vec2 {\n\t\tconst nx = position[0] / Surface.getWidth() * 2 - 1;\n\t\tconst ny = -(position[1] / Surface.getHeight() * 2 - 1);\n\t\tlet inverse = glm.mat4.create();\n\t\tinverse = glm.mat4.invert(inverse, this.viewProjectionMatrix);\n\t\tlet out = glm.vec4.create();\n\t\tout = glm.vec4.transformMat4(out, glm.vec4.fromValues(nx, ny, 1, 1), inverse);\n\t\t\n\t\treturn glm.vec2.fromValues(out[0], out[1]);\n\t}\n\n\t/** \n\t * Adds a postprocessing stage to the end of the list.\n\t * The order of the list is the order they will be applied.\n\t * @param {PostprocessingStage} stage The stage.\n\t */\n\tpublic static addPostprocessingStage(stage: PostprocessingStage) {\n\t\tthis.postprocessingStages.push(stage);\n\t}\n\n\t/** \n\t * Adds a postprocessing stage to the end of the list.\n\t * The order of the list is the order they will be applied.\n\t * @param {string} name The name of the stage.\n\t */\n\tpublic static removePostprocessingStage(name: string) {\n\t\tthis.postprocessingStages.filter((value: PostprocessingStage, index: number, array: PostprocessingStage[]) => {\n\t\t\treturn value.getName() !== name;\n\t\t});\n\t}\n\n\t/**\n\t * Enable a postprocessing stage.\n\t * @param {string} name The name of the stage.\n\t */\n\tpublic static enablePostprocessingStage(name: string) {\n\t\tthis.postprocessingStages.find((value: PostprocessingStage, index: number, array: PostprocessingStage[]) => {\n\t\t\treturn value.getName() === name;\n\t\t}).enable();\n\t}\n\n\t/**\n\t * Disable a postprocessing stage.\n\t * @param {string} name The name of the stage.\n\t */\n\tpublic static disablePostprocessingStage(name: string) {\n\t\tthis.postprocessingStages.find((value: PostprocessingStage, index: number, array: PostprocessingStage[]) => {\n\t\t\treturn value.getName() === name;\n\t\t}).disable();\n\t}\n\n\t/** Enable lighting. */\n\tpublic static enableLighting() {\n\t\tthis.doLighting = true;\n\t}\n\n\t/** Disable lighting. */\n\tpublic static disableLighting() {\n\t\tthis.doLighting = false;\n\t}\n}","import { Surface } from './Surface';\nimport * as glm from 'gl-matrix';\n\n/** Get a shader data type from string 'vertex' or 'fragment'. */\nfunction shaderTypeFromString(type: string): number {\n\tif (type == 'vertex')\n\t\treturn Surface.gl.VERTEX_SHADER;\n\tif (type == 'fragment' || type == 'pixel')\n\t\treturn Surface.gl.FRAGMENT_SHADER;\n\t\n\treturn null;\n}\n\n/** Represents an OpenGL shader. */\nexport class Shader {\n\tprivate program: WebGLProgram;\n\tprivate name: string;\n\tprivate locations: { [id: string]: WebGLUniformLocation };\n\n\t/**\n\t * Create a new shader.\n\t * @param {string} name The shader's name.\n\t * @param {string} vertexSrc The GLSL vertex shader source code.\n\t * @param {string} fragmentSrc The GLSL fragment shader source code.\n\t * @param {string[]} [transformFeedbackVaryings] The shader's transform feedback varyings.\n\t */\n\tpublic constructor(name: string, vertexSrc: string, fragmentSrc: string, transformFeedbackVaryings?: string[]) {\n\t\tthis.name = name;\n\t\tthis.locations = {};\n\n\t\tthis.compile({[shaderTypeFromString('vertex')]: vertexSrc, [shaderTypeFromString('fragment')]: fragmentSrc}, transformFeedbackVaryings);\n\t}\n\n\t/**\n\t * Creates a shader from a file path.\n\t * @param {string} path The file path of the shader source code.\n\t * @param {string} [name] The name of the shader (Optional). If null, shader will use the filename as name.\n\t * @returns {Shader} The shader that was loaded from the path.\n\t */\n\tpublic static async loadFromFetch(path: string, name?: string): Promise<Shader> {\n\t\tif (!name) name = path.substr(path.lastIndexOf('/') + 1);\n\t\tconst response = await fetch(path);\n\t\tconst source = await response.text();\n\t\tconst shaderSources = this.preProcess(source);\n\t\treturn new Shader(name, shaderSources[shaderTypeFromString('vertex')], shaderSources[shaderTypeFromString('fragment')]);\n\t}\n\n\t/**\n\t * Creates a shader from source code stored in script tags.\n\t * @param {string} vertexID The HTML ID of the vertex shader <script>.\n\t * @param {string} fragmentID The HTML ID of the fragment shader <script>.\n\t * @param {string} name The name of the shader.\n\t */\n\tpublic static loadFromScript(vertexID: string, fragmentID: string, name: string): Shader {\n\t\tconsole.log(document.getElementById(vertexID).innerHTML + '\\n\\n' + document.getElementById(fragmentID).innerHTML);\n\t\treturn new Shader(name, document.getElementById(vertexID).innerHTML, document.getElementById(fragmentID).innerHTML);\n\t}\n\t\n\t/**\n\t * Processes the raw shader source file and returns the individual shaders.\n\t * @param {string} source The raw source code.\n\t * @returns {{[id: number]: string}} A dictionary of the individual shaders.\n\t */\n\tprivate static preProcess(source: string): {[id: number]: string} {\n\t\tlet sources: {[id: number]: string} = {};\n\n\t\tlet currentType = '';\n\t\tconst lines = source.split('\\n');\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst line = lines[i].trim();\n\t\t\tconst words = line.split(' ');\n\t\t\tif (words.length == 2) {\n\t\t\t\tif (words[0] == '#type') {\n\t\t\t\t\tcurrentType = words[1];\n\t\t\t\t\tsources[shaderTypeFromString(currentType)] = '';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (currentType == '')\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tsources[shaderTypeFromString(currentType)] += line + '\\n';\n\t\t}\n\n\t\treturn sources;\n\t}\n\n\t/**\n\t * Compiles the shader sources into an OpenGL program.\n\t * @param {{[id: number]: string}} shaderSources A dictionary containing each shader type and source code.\n\t * @private\n\t */\n\tprivate compile(shaderSources: {[id: number]: string}, transformFeedbackVaryings?: string[]) {\n\t\tlet program: WebGLProgram = Surface.gl.createProgram();\n\t\tlet shaders: WebGLShader[] = [];\n\t\tfor (let type in shaderSources) {\n\t\t\tconst source = shaderSources[type].trim();\n\n\t\t\tconst shader = Surface.gl.createShader(Number(type));\n\t\t\tSurface.gl.shaderSource(shader, source);\n\t\t\tSurface.gl.compileShader(shader);\n\n\t\t\tconst log = Surface.gl.getShaderInfoLog(shader);\n\t\t\tif (log != '' && log != null) {\n\t\t\t\tSurface.gl.deleteShader(shader);\n\t\t\t\tconsole.log(log);\n\t\t\t\tconsole.assert(false, 'Shader compilation error!');\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSurface.gl.attachShader(program, shader);\n\t\t\tshaders.push(shader);\n\t\t}\n\n\t\t// SUBMIT TRANSFORM FEEDBACK \n\t\tif (transformFeedbackVaryings) {\n\t\t\tSurface.gl.transformFeedbackVaryings(program, transformFeedbackVaryings, Surface.gl.INTERLEAVED_ATTRIBS);\n\t\t}\n\n\t\tSurface.gl.linkProgram(program);\n\n\t\t// LOG ERRORS //\n\t\tif (!Surface.gl.getProgramParameter(program, Surface.gl.LINK_STATUS)) {\n\t\t\tconst log = Surface.gl.getProgramInfoLog(program);\n\t\t\tif (log != '' && log != null) {\n\t\t\t\tSurface.gl.deleteProgram(program);\n\n\t\t\t\tfor (const shader of shaders) {\n\t\t\t\t\tSurface.gl.deleteShader(shader);\n\t\t\t\t}\n\n\t\t\t\tconsole.log(log);\n\t\t\t\tconsole.assert(false, 'Program link failure!');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// DETACH AND DELETE SHADERS //\n\t\tfor (const id of shaders) {\n\t\t\tSurface.gl.detachShader(program, id);\n\t\t\tSurface.gl.deleteShader(id);\n\t\t}\n\t\t\n\t\tthis.program = program;\n\t}\n\n\t/** Binds the shader. */\n\tpublic bind(): void {\n\t\tSurface.gl.useProgram(this.program);\n\t}\n\n\t/** Unbinds the shader. */\n\tpublic unbind(): void {\n\t\tSurface.gl.useProgram(null);\n\t}\n\n\t/**\n\t * Get the shader's name.\n\t * @returns {string} The shader's name.\n\t */\n\tpublic getName(): string {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * Get the location of an attribute within the shader.\n\t * @param {string} name The name of the attribute within the shader.\n\t * @returns {number} The location of the attribute.\n\t */\n\tpublic getAttribLocation(name: string): number {\n\t\treturn Surface.gl.getAttribLocation(this.program, name);\n\t}\n\n\t/**\n\t * Get the location of a uniform within the shader.\n\t * @param {string} name The name of the uniform within the shader.\n\t * @returns {WebGLUniformLocation} The location of the uniform.\n\t */\n\tpublic getUniformLocation(name: string): WebGLUniformLocation {\n\t\tif (name in this.locations) {\n\t\t\treturn this.locations[name];\n\t\t}\n\t\telse {\n\t\t\tconst location = Surface.gl.getUniformLocation(this.program, name);\n\t\t\tthis.locations[name] = location;\n\t\t\treturn location;\n\t\t}\n\t}\n\n\t/**\n\t * Set an integer uniform's value.\n\t * @param {string} name The name of the uniform variable.\n\t * @param {number} value The value which the uniform is set to.\n\t */\n\tpublic uploadUniformInt(name: string, value: number) {\n\t\tSurface.gl.uniform1i(this.getUniformLocation(name), value);\n\t}\n\n\t/**\n\t * Set a float uniform's value.\n\t * @param {string} name The name of the uniform variable.\n\t * @param {number} value The value which the uniform is set to.\n\t */\n\tpublic uploadUniformFloat(name: string, value: number) {\n\t\tSurface.gl.uniform1f(this.getUniformLocation(name), value);\n\t}\n\n\t/**\n\t * Set a vector 2 uniform's value.\n\t * @param {string} name The name of the uniform variable.\n\t * @param {glm.vec2} value The value which the uniform is set to.\n\t */\n\tpublic uploadUniformFloat2(name: string, value: glm.vec2) {\n\t\tSurface.gl.uniform2f(this.getUniformLocation(name), value[0], value[1]);\n\t}\n\n\t/**\n\t * Set a vector 3 uniform's value.\n\t * @param {string} name The name of the uniform variable.\n\t * @param {glm.vec3} value The value which the uniform is set to.\n\t */\n\tpublic uploadUniformFloat3(name: string, value: glm.vec3) {\n\t\tSurface.gl.uniform3f(this.getUniformLocation(name), value[0], value[1], value[2]);\n\t}\n\n\t/**\n\t * Set a vector 4 uniform's value.\n\t * @param {string} name The name of the uniform variable.\n\t * @param {glm.vec4} value The value which the uniform is set to.\n\t */\n\tpublic uploadUniformFloat4(name: string, value: glm.vec4) {\n\t\tSurface.gl.uniform4f(this.getUniformLocation(name), value[0], value[1], value[2], value[3]);\n\t}\n\n\t/**\n\t * Set a 3x3 matrix uniform's value.\n\t * @param {string} name The name of the uniform variable.\n\t * @param {glm.mat3} value The value which the uniform is set to.\n\t */\n\tpublic uploadUniformMat3(name: string, value: glm.mat3) {\n\t\tSurface.gl.uniformMatrix3fv(this.getUniformLocation(name), false, new Float32Array(value));\n\t}\n\n\t/**\n\t * Set a 4x4 matrix uniform's value.\n\t * @param {string} name The name of the uniform variable.\n\t * @param {glm.mat4} value The value which the uniform is set to.\n\t */\n\tpublic uploadUniformMat4(name: string, value: glm.mat4) {\n\t\tSurface.gl.uniformMatrix4fv(this.getUniformLocation(name), false, new Float32Array(value));\n\t}\n\n\t/**\n\t * Set a boolean uniform's value.\n\t * @param {string} name The name of the uniform variable.\n\t * @param {boolean} value The value which the uniform is set to.\n\t */\n\tpublic uploadUniformBool(name: string, value: boolean) {\n\t\tSurface.gl.uniform1i(this.getUniformLocation(name), value ? 1 : 0);\n\t}\n\n\t/**\n\t * \n\t * @param {string} name \n\t * @param {Float32Array} list \n\t * @param {number} offset \n\t * @param {number} length \n\t */\n\tpublic uploadUniformFloatArray(name: string, list: Float32Array, offset?: number, length?: number) {\n\t\tSurface.gl.uniform1fv(this.getUniformLocation(name), list, offset, length);\n\t}\n}","import { Shader } from './Shader';\n\n/** Stores a number of shaders. */\nexport class ShaderLibrary {\n\tprivate shaders: { [id: string]: Shader };\n\n\t/** Create a new shader library. */\n\tpublic constructor() {\n\t\tthis.shaders = {};\n\t}\n\n\t/**\n\t * Add a shader to be stored in the shader library.\n\t * @param {Shader} shader The shader to add.\n\t * @param {string} [name] The name used to access the shader (optional).\n\t */\n\tpublic add(shader: Shader, name?: string) {\n\t\tif (!name) {\n\t\t\tname = shader.getName();\n\t\t}\n\t\tconsole.assert(!(name in this.shaders), 'Shader already exists!');\n\n\t\tthis.shaders[name] = shader;\n\t}\n\n\tpublic set(shader: Shader, name?: string) {\n\t\tif (!name) {\n\t\t\tname = shader.getName();\n\t\t}\n\n\t\tthis.shaders[name] = shader;\n\t}\n\n\t/**\n\t * Load a shader into the ShaderLibrary.\n\t * @param {string} filepath The path of the shader to be loaded.\n\t * @param {string} [name] The name of the shader used to access it.\n\t * @returns {Promise<Shader>} The shader which was loaded.\n\t */\n\tpublic async load(filepath: string, name: string = null): Promise<Shader> {\n\t\tconst shader = await Shader.loadFromFetch(filepath, name);\n\t\tthis.add(shader, name);\n\t\treturn shader;\n\t}\n\n\t/**\n\t * Get a shader from the ShaderLibary.\n\t * @param {string} name The name of the shader.\n\t * @returns {Shader} The shader.\n\t */\n\tpublic get(name: string): Shader {\n\t\tconsole.assert(name in this.shaders, 'Shader not found!');\n\t\treturn this.shaders[name];\n\t}\n\n\t/**\n\t * Check if a shader is currently being stored in the ShaderLibrary.\n\t * @param {string} name The name of the shader.\n\t * @returns {boolean} Whether the shader exists or not.\n\t */\n\tpublic exists(name: string): boolean {\n\t\treturn name in this.shaders;\n\t}\n}","export function getVertexSource(): string { \n\treturn `#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tlayout(location = 0) in vec3 a_Position;\n\t\t\t\n\t\t\tuniform mat4 u_ViewProjection;\n\t\t\tuniform mat4 u_Transform;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0);\n\t\t\t}`;\n}\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\t\t\tprecision mediump float;\n\t\t\t\n\t\t\tout vec4 color;\n\t\t\t\n\t\t\tuniform vec4 u_Color;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tcolor = u_Color;\n\t\t\t}`;\n}\n","export function getVertexSource(): string { \n\treturn `#version 300 es\n\tprecision highp float;\n\n\tlayout(location = 0) in vec3 a_Position;\n\tlayout(location = 1) in vec2 a_TexCoord;\n\n\tout vec2 v_TexCoord;\n\n\tvoid main() {\n\t\tv_TexCoord = a_TexCoord;\n\t\tgl_Position = vec4(a_Position, 1.0);\n\t}`;\n}\n\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\tprecision mediump float;\n\tout vec4 color;\n\t\n\tin vec2 v_TexCoord;\n\n\tuniform sampler2D u_Texture;\n\tuniform int u_KernelSize;\n\tuniform bool u_Horizontal;\n\tuniform float u_Weights[5];\n\tuniform float u_Spread;\n\n\tvoid main() {\n\n\t\tvec2 tex_offset = 1.0 / vec2(textureSize(u_Texture, 0));\n    \tvec3 result = texture(u_Texture, v_TexCoord).rgb * u_Weights[0];\n\t\t\n\t\tif(u_Horizontal)\n\t\t{\n\t\t\tfor(float i = 1.0; i < ceil(float(u_KernelSize) / 2.0); i++)\n\t\t\t{\n\t\t\t\tresult += texture(u_Texture, v_TexCoord + vec2(tex_offset.x * i * u_Spread, 0.0)).rgb * u_Weights[int(i)];\n\t\t\t\tresult += texture(u_Texture, v_TexCoord - vec2(tex_offset.x * i * u_Spread, 0.0)).rgb * u_Weights[int(i)];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(float i = 1.0; i < ceil(float(u_KernelSize) / 2.0); i++)\n\t\t\t{\n\t\t\t\tresult += texture(u_Texture, v_TexCoord + vec2(0.0, tex_offset.y * i * u_Spread)).rgb * u_Weights[int(i)];\n\t\t\t\tresult += texture(u_Texture, v_TexCoord - vec2(0.0, tex_offset.y * i * u_Spread)).rgb * u_Weights[int(i)];\n\t\t\t}\n\t\t}\n\n\t\tcolor = vec4(result, 1.0);\n\t}`;\n}","export function getVertexSource(): string { \n\treturn `#version 300 es\n\tprecision highp float;\n\n\tlayout(location = 0) in vec3 a_Position;\n\tlayout(location = 1) in vec2 a_TexCoord;\n\n\tout vec2 v_TexCoord;\n\n\tvoid main() {\n\t\tv_TexCoord = a_TexCoord;\n\t\tgl_Position = vec4(a_Position, 1.0);\n\t}`;\n}\n\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\tprecision mediump float;\n\tout vec4 color;\n\t\n\tin vec2 v_TexCoord;\n\n\tuniform sampler2D u_Texture;\n\n\tvoid main() {\n\t\tcolor = texture(u_Texture, v_TexCoord);\n\t\tfloat average = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n\t\tcolor = vec4(average, average, average, 1.0);\n\t}`;\n}","export function getVertexSource(): string { \n\treturn `#version 300 es\n\tprecision highp float;\n\n\tlayout(location = 0) in mat4 a_Transform;\n\tlayout(location = 4) in vec4 a_AtlasBounds;\n\n\tlayout(location = 5) in vec2 a_Position;\n\tlayout(location = 6) in vec2 a_TexCoord;\n\n\tuniform mat4 u_ViewProjection;\n\n\tout vec4 v_AtlasBounds;\n\tout vec2 v_TexCoord;\n\n\tvoid main() {\n\t\tv_AtlasBounds = a_AtlasBounds;\n\t\tv_TexCoord = a_TexCoord;\n\t\tgl_Position = u_ViewProjection * a_Transform * vec4(a_Position, 0.0, 1.0);\n\t}`;\n}\n\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\tprecision mediump float;\n\tout vec4 color;\n\n\tin vec4 v_AtlasBounds;\n\tin vec2 v_TexCoord;\n\n\tuniform sampler2D u_Texture;\n\n\tvoid main() {\n\t\tcolor = texture(u_Texture, vec2(v_AtlasBounds.x + v_AtlasBounds.z * v_TexCoord.x, v_AtlasBounds.y + v_AtlasBounds.w * v_TexCoord.y));\n\t}`;\n}","export function getVertexSource(): string { \n\treturn `#version 300 es\n\tprecision highp float;\n\n\tlayout(location = 0) in vec3 a_Position;\n\tlayout(location = 1) in vec2 a_TexCoord;\n\n\tout vec2 v_TexCoord;\n\n\tvoid main() {\n\t\tv_TexCoord = a_TexCoord;\n\t\tgl_Position = vec4(a_Position, 1.0);\n\t}`;\n}\n\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\tprecision mediump float;\n\tout vec4 color;\n\t\n\tin vec2 v_TexCoord;\n\n\tuniform sampler2D u_Texture;\n\n\tvoid main() {\n\t\tcolor = vec4(vec3(1.0 - texture(u_Texture, v_TexCoord)), 1.0);\n\t}`;\n}","export function getVertexSource(): string { \n\treturn `#version 300 es\n\tprecision highp float;\n\n\tlayout(location = 0) in mat4 a_Transform;\n\tlayout(location = 4) in vec3 a_Color;\n\tlayout(location = 5) in float a_Intensity;\n\n\tlayout(location = 6) in vec2 a_Position;\n\n\tuniform mat4 u_ViewProjection;\n\tuniform int u_InstanceCount;\n\n\tout vec3 v_Color;\n\tout float v_Intensity;\n\n\tout vec2 v_Position;\n\n\tvoid main() {\n\t\tv_Color = a_Color;\n\t\tv_Intensity = a_Intensity;\n\t\tv_Position = a_Position;\n\n\t\tgl_Position = u_ViewProjection * a_Transform * vec4(a_Position, 0.1 * (float(gl_InstanceID) / float(u_InstanceCount)), 1.0);\n\t}`;\n}\n\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\tprecision mediump float;\n\tout vec4 color;\n\t\n\tin vec3 v_Color;\n\tin float v_Intensity;\n\t\n\tin vec2 v_Position;\n\n\tuniform float[11] u_Kernel;\n\n\tvoid main() {\n\n\t\tfloat step = 0.1;\n\t\tfloat dist = length(v_Position) * 2.0;\n\t\tint index = int(floor(dist / step));\n\t\t\n\t\tcolor = vec4(v_Color, mix(u_Kernel[index], u_Kernel[index + 1], mod(dist, step) / step) * v_Intensity);\n\t}`;\n}","export function getVertexSource(): string { \n\treturn `#version 300 es\n\tprecision highp float;\n\n\tlayout(location = 0) in vec3 a_Position;\n\tlayout(location = 1) in vec2 a_TexCoord;\n\n\tout vec2 v_TexCoord;\n\n\tvoid main() {\n\t\tv_TexCoord = a_TexCoord;\n\t\tgl_Position = vec4(a_Position, 1.0);\n\t}`;\n}\n\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\tprecision mediump float;\n\tout vec4 color;\n\t\n\tin vec2 v_TexCoord;\n\n\tuniform sampler2D u_SpriteTexture;\n\tuniform sampler2D u_LightTexture;\n\n\tvoid main() {\n\t\tvec4 spriteColor = texture(u_SpriteTexture, v_TexCoord);\n\t\tvec4 lightColor = texture(u_LightTexture, v_TexCoord);\n\n\t\tcolor = vec4(spriteColor.x * lightColor.x, spriteColor.y * lightColor.y, spriteColor.z * lightColor.z, 1.0);\n\t}`;\n}","export function getVertexSource(): string { \n\treturn `#version 300 es\n\t\t\tprecision mediump float;\n\n\t\t\tuniform float u_zIndex;\n\t\t\tuniform mat4 u_ViewProjection;\n\t\t\t\n\t\t\tlayout(location = 0) in vec2 i_Position;\n\t\t\tlayout(location = 1) in float i_Age;\n\t\t\tlayout(location = 2) in float i_Life;\n\t\t\tlayout(location = 3) in vec2 i_Velocity;\n\n\t\t\tout float v_TimeLeft;\n\n\t\t\tvoid main() {\n\t\t\t\tv_TimeLeft = i_Life - i_Age;\n\t\t\t\ti_Velocity;\n\n\t\t\t\tgl_PointSize = 2.0;\n\t\t\t\tgl_Position = u_ViewProjection * vec4(i_Position, u_zIndex, 1.0);\n\t\t\t}\n\t\t\t`;\n}\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\t\t\tprecision mediump float;\n\n\t\t\tuniform float u_FadeTime;\n\n\t\t\tin float v_TimeLeft;\n\n\t\t\tout vec4 o_FragColor;\n\n\t\t\tvoid main() {\n\t\t\t\tfloat opacity = 1.0;\n\t\t\t\tif (u_FadeTime > 0.0) {\n\t\t\t\t\topacity = min(v_TimeLeft / u_FadeTime, 1.0);\n\t\t\t\t}\n\n\t\t\t\t// TODO: different colors / textures etc.\n\t\t\t\to_FragColor = vec4(1.0, 1.0, 1.0, opacity);\n\t\t\t}\n\t`;\n}\n","export function getVertexSource(): string { \n\treturn `#version 300 es\n\t\t\tprecision mediump float;\n\n\t\t\tuniform float u_Scale;\n\t\t\tuniform float u_ShrinkTime;\n\t\t\tuniform float u_zIndex;\n\t\t\tuniform mat4 u_ViewProjection;\n\t\t\tuniform int u_InstanceCount;\n\t\t\t\n\t\t\tlayout(location = 0) in vec2 i_Position;\n\t\t\tlayout(location = 1) in float i_Age;\n\t\t\tlayout(location = 2) in float i_Life;\n\t\t\tlayout(location = 3) in vec2 i_Velocity;\n\n\t\t\tlayout(location = 4) in vec2 i_Coord;\n\t\t\tlayout(location = 5) in vec2 i_TexCoord;\n\n\t\t\tout float v_TimeLeft;\n\t\t\tout vec2 v_TexCoord;\n\t\t\tout vec2 v_Position;\n\n\t\t\tvoid main() {\n\t\t\t\tv_TimeLeft = i_Life - i_Age;\n\t\t\t\tv_TexCoord = i_TexCoord;\n\t\t\t\ti_Velocity;\n\t\t\t\tv_Position = i_Position;\n\n\t\t\t\tvec2 vert_coord;\n\t\t\t\tif (u_ShrinkTime > 0.0) {\n\t\t\t\t\tvert_coord = i_Position + min((v_TimeLeft / u_ShrinkTime) * u_Scale, u_Scale) * i_Coord;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvert_coord = i_Position + u_Scale * i_Coord;\n\t\t\t\t}\n\n\t\t\t\tgl_Position = u_ViewProjection * vec4(vert_coord, u_zIndex + 0.1 * (float(gl_InstanceID) / float(u_InstanceCount)), 1.0);\n\t\t\t}\n\t\t\t`;\n}\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\t\t\tprecision mediump float;\n\n\t\t\tuniform float u_FadeTime;\n\t\t\tuniform sampler2D u_Texture;\n\n\t\t\tin float v_TimeLeft;\n\t\t\tin vec2 v_TexCoord;\n\t\t\tin vec2 v_Position;\n\n\t\t\tout vec4 o_FragColor;\n\n\t\t\tvoid main() {\n\t\t\t\tfloat opacity = 1.0;\n\t\t\t\tif (u_FadeTime > 0.0) {\n\t\t\t\t\topacity = min(v_TimeLeft / u_FadeTime, 1.0);\n\t\t\t\t}\n\n\t\t\t\to_FragColor = texture(u_Texture, v_TexCoord) * vec4(1.0, 1.0, 1.0, opacity);\n\t\t\t}\n\t`;\n}\n","export function getVertexSource(): string { \n\treturn `#version 300 es\n\t\t\tprecision mediump float;\n\n\t\t\tuniform float u_DeltaTime;\n\t\t\tuniform sampler2D u_RandNoise;\n\t\t\tuniform vec2 u_Gravity;\n\t\t\tuniform vec2 u_Origin;\n\n\t\t\tuniform float u_Angle;\n\t\t\tuniform float u_Spread;\n\n\t\t\tuniform float u_MinSpeed;\n\t\t\tuniform float u_MaxSpeed;\n\n\t\t\tlayout(location = 0) in vec2 i_Position;\n\t\t\tlayout(location = 1) in float i_Age;\n\t\t\tlayout(location = 2) in float i_Life;\n\t\t\tlayout(location = 3) in vec2 i_Velocity;\n\n\t\t\tout vec2 v_Position;\n\t\t\tout float v_Age;\n\t\t\tout float v_Life;\n\t\t\tout vec2 v_Velocity;\n\n\t\t\tvoid main() {\n\t\t\t\tif (i_Age >= i_Life) {\n\n\t\t\t\t\t// Generate randomness.\n\t\t\t\t\tivec2 noise_coord = ivec2(gl_VertexID % 512, gl_VertexID / 512);\n\t\t\t\t\tvec2 rand = texelFetch(u_RandNoise, noise_coord, 0).rg;\n\n\t\t\t\t\tfloat angle = (rand.r - 0.5) * u_Spread + u_Angle;\n\n\t\t\t\t\tvec2 direction = vec2(cos(angle), sin(angle));\n\n\t\t\t\t\tv_Position = u_Origin;\n\t\t\t\t\tv_Age = 0.0;\n\t\t\t\t\tv_Life = i_Life;\n\t\t\t\t\tv_Velocity = direction * (u_MinSpeed + rand.g * (u_MaxSpeed - u_MinSpeed));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv_Position = i_Position + i_Velocity * u_DeltaTime;\n\t\t\t\t\tv_Age = i_Age + u_DeltaTime;\n\t\t\t\t\tv_Life = i_Life;\n\t\t\t\t\tv_Velocity = i_Velocity + u_Gravity * u_DeltaTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\t`;\n}\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\t\t\tprecision mediump float;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tdiscard;\n\t\t\t}`;\n}\n","export function getVertexSource(): string { \n\treturn `#version 300 es\n\tprecision highp float;\n\n\tlayout(location = 0) in vec3 a_Position;\n\tlayout(location = 1) in vec2 a_TexCoord;\n\n\tuniform mat4 u_ViewProjection;\n\tuniform mat4 u_Transform;\n\n\tout vec2 v_TexCoord;\n\n\tvoid main() {\n\t\tv_TexCoord = a_TexCoord;\n\t\tgl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0);\n\t}`;\n}\n\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\tprecision mediump float;\n\n\tout vec4 color;\n\tin vec2 v_TexCoord;\n\n\tuniform sampler2D u_Texture;\n\n\tvoid main() {\n\t\tcolor = texture(u_Texture, v_TexCoord);\n\t}`;\n}","export function getVertexSource(): string { \n\treturn `#version 300 es\n\tprecision highp float;\n\n\tlayout(location = 0) in vec3 a_Position;\n\tlayout(location = 1) in vec2 a_TexCoord;\n\n\tout vec2 v_TexCoord;\n\n\tvoid main() {\n\t\tv_TexCoord = a_TexCoord;\n\t\tgl_Position = vec4(a_Position, 1.0);\n\t}`;\n}\n\nexport function getFragmentSource(): string {\n\treturn `#version 300 es\n\tprecision mediump float;\n\tout vec4 color;\n\t\n\tin vec2 v_TexCoord;\n\n\tuniform sampler2D u_Texture;\n\tuniform float u_Brightness;\n\n\tvoid main() {\n\t\tcolor = vec4(vec3(texture(u_Texture, v_TexCoord)) * (1.0 - distance(vec2(0.5, 0.5), v_TexCoord) / u_Brightness), 1.0);\n\t}`;\n}","import * as glm from 'gl-matrix';\nimport { Texture2D } from './Texture';\n\n/** Represents a texture within world-space. */\nexport class Sprite {\n\t/** The sprite's opacity. Unimplemented. */\n\tpublic opacity: number;\n\n\tprivate position: glm.vec2;\n\tprivate rotation: number;\n\tprivate scale: number;\n\tprivate texture: Texture2D;\n\n\tprivate transform: glm.mat4;\n\n\t/**\n\t * Create a new sprite.\n\t * @param {Texture2D} [texture] The sprite's texture.\n\t * @param {glm.vec2} [position] The sprite's position.\n\t * @param {number} [rotation=0] The sprite's rotation in radians.\n\t * @param {number} [scale=1] The sprite's scale.\n\t * @param {number} [opacity=1] The sprite's opacity (0 - 1).\n\t */\n\tpublic constructor(texture: Texture2D = null, position: glm.vec2 = glm.vec2.create(), rotation: number = 0, scale: number = 1, opacity: number = 255) {\n\t\tthis.position = position;\n\t\tthis.rotation = rotation;\n\t\tthis.scale = scale;\n\t\tthis.opacity = opacity;\n\n\t\tif (texture) {\n\t\t\tthis.texture = texture;\n\t\t}\n\t\telse {\n\t\t\tthis.texture = new Texture2D();\n\t\t\tthis.texture.loadFromArray(new Uint8Array([100, 100, 100, 255]), 1, 1);\n\t\t}\n\n\t\tthis.recalculateTransform();\n\t}\n\n\t/**\n\t * Get the sprite's position in the world.\n\t * @returns {glm.vec2} The position.\n\t */\n\tpublic getPosition(): glm.vec2 {\n\t\treturn this.position;\n\t}\n\n\t/**\n\t * Set the sprite's position and recalculate transform.\n\t * @param {glm.vec2} position The new position. \n\t */\n\tpublic setPosition(position: glm.vec2) {\n\t\tthis.position = position;\n\t\tthis.recalculateTransform();\n\t}\n\n\t/**\n\t * Translate the sprite by a given vector.\n\t * @param {glm.vec2} deltaPosition The amount to translate by.\n\t */\n\tpublic translateBy(deltaPosition: glm.vec2) {\n\t\tglm.vec2.add(this.position, this.position, deltaPosition);\n\t\tthis.recalculateTransform();\n\t}\n\n\t/**\n\t * Get the sprite's rotation\n\t * @returns {number}\n\t */\n\tpublic getRotation(): number {\n\t\treturn this.rotation;\n\t}\n\n\t/**\n\t * Set the sprite's rotation and recalculate transform.\n\t * @param {number} rotation The new rotation.\n\t */\n\tpublic setRotation(rotation: number) {\n\t\tthis.rotation = rotation;\n\t\tthis.recalculateTransform();\n\t}\n\n\t/**\n\t * Rotate a sprite by a given amount in radians and recalculate transform.\n\t * @param deltaRotation The amount to rotate the sprite anticlockwise in radians.\n\t */\n\tpublic rotateBy(deltaRotation: number) {\n\t\tthis.rotation += deltaRotation;\n\t\tthis.recalculateTransform();\n\t}\n\n\t/**\n\t * Get the scale of the sprite.\n\t * @returns {number}\n\t */\n\tpublic getScale(): number {\n\t\treturn this.scale;\n\t}\n\n\t/**\n\t * Set the sprite's scale.\n\t * @param {number} scale The new scale.\n\t */\n\tpublic setScale(scale: number) {\n\t\tthis.scale = scale;\n\t\tthis.recalculateTransform();\n\t}\n\n\t/**\n\t * Scale the sprite by a certain amount.\n\t * @param {number} deltaScale The added scale.\n\t */\n\tpublic scaleBy(deltaScale: number) {\n\t\tthis.scale += deltaScale;\n\t\tthis.recalculateTransform();\n\t}\n\n\t/**\n\t * Get the sprite's texture.\n\t * @returns {Texture2D} The texture.\n\t */\n\tpublic getTexture(): Texture2D {\n\t\treturn this.texture;\n\t}\n\n\t/**\n\t * Set the sprite's texture.\n\t * @param {Texture2D} texture The new texture.\n\t */\n\tpublic setTexture(texture: Texture2D) {\n\t\tthis.texture = texture;\n\t}\n\n\t/**\n\t * Recalculate the sprite's transform.\n\t */\n\tpublic recalculateTransform() {\n\t\tthis.transform = glm.mat4.create();\n\t\tthis.transform = glm.mat4.translate(this.transform, this.transform, glm.vec3.fromValues(this.position[0], this.position[1], 0));\n\t\tthis.transform = glm.mat4.rotate(this.transform, this.transform, this.rotation, glm.vec3.fromValues(0, 0, 1));\n\t\tthis.transform = glm.mat4.scale(this.transform, this.transform, glm.vec3.fromValues(this.scale, this.scale, this.scale));\n\t}\n\n\t/**\n\t * Get the sprite's transform.\n\t * @returns {glm.mat4}\n\t */\n\tpublic getTransform(): glm.mat4 {\n\t\treturn this.transform;\n\t}\n}","import * as glm from 'gl-matrix';\nimport { ApplicationSettings } from '../Core/ApplicationSettings';\nimport { RenderCommand } from './RenderCommand';\nimport { Timer } from '../Util/Timer';\nimport { Event } from '../Events/Event';\nimport { CanvasResizeEvent } from '../Events/ApplicationEvent';\n\n// TODO: Make gl external to surface?\n//export var gl: WebGL2RenderingContext;\n\nexport class Surface {\n\t\n\tprivate static settings: ApplicationSettings;\n\t\n\t/** The engine's main rendering canvas. */\n\tpublic static canvas: HTMLCanvasElement;\n\tprivate static fontCanvas: HTMLCanvasElement;\n\t\n\t/**\n\t * The WebGL2 rendering context.\n\t * @static\n\t */\n\tpublic static gl: WebGL2RenderingContext;\n\t\n\t/**\n\t * The font rendering context.\n\t * @static\n\t */\n\tpublic static font: CanvasRenderingContext2D;\n\t\n\tprivate static resizing: boolean = false;\n\n\tprivate static eventCallbackFn: (event: Event) => void;\n\n\t//private static resizeCallbacks: Array<(canvas: HTMLCanvasElement) => void>;\n\tprivate static resizeTimer: Timer;\n\tprivate static canvasSize: glm.vec2;\n\t\n\t/** \n\t * Initialize the surface.\n\t * @param {settings} settings The engine settings.\n\t */\n\tpublic static init(settings: ApplicationSettings) {\n\t\tthis.settings = settings;\n\t\tthis.resizeTimer = new Timer(0.3, false, true);\n\t\t//this.resizeCallbacks = new Array<(canvas: HTMLCanvasElement) => void>();\n\n\t\tif (!this.settings.clearColor) this.settings.clearColor = glm.vec3.fromValues(0.1, 0.1, 0.1);\n\n\t\t// CREATE WEBGL CANVAS //\n\t\tif (this.settings.canvasID) {\n\t\t\tthis.canvas = <HTMLCanvasElement> document.getElementById(this.settings.canvasID);\n\t\t}\n\t\telse {\n\t\t\tthis.canvas = document.createElement('canvas');\n\t\t\tdocument.getElementsByTagName('body')[0].appendChild(this.canvas);\n\t\t}\n\n\t\tif (this.settings.displayMode == 'fill') {\n\t\t\tthis.canvas.style.width = '100%';\n\t\t\tthis.canvas.style.height = '100%';\n\t\t\tthis.canvas.width = this.canvas.clientWidth;\n\t\t\tthis.canvas.height = this.canvas.clientHeight;\n\t\t}\n\t\telse if (this.settings.displayMode == 'fixed' && this.settings.canvasID) {\n\t\t\tthis.canvas.width = this.settings.width || 780;\n\t\t\tthis.canvas.height = this.settings.height || 480;\n\t\t}\n\t\t\n\t\tthis.gl = this.canvas.getContext('webgl2');\n\n\t\t// CREATE FONT CANVAS //\n\t\tthis.fontCanvas = document.createElement('canvas');\n\t\tif (this.canvas.nextSibling) {\n\t\t\tthis.canvas.parentNode.insertBefore(this.fontCanvas, this.canvas.nextSibling);\n\t\t}\n\t\telse {\n\t\t\tthis.canvas.parentNode.appendChild(this.fontCanvas);\n\t\t}\n\t\tthis.fontCanvas.style.position = 'absolute';\n\t\tthis.fontCanvas.style.left =  this.canvas.offsetLeft.toString() + 'px';\n\t\tthis.fontCanvas.style.top = this.canvas.offsetTop.toString() + 'px';\n\t\tthis.fontCanvas.width = this.canvas.width;\n\t\tthis.fontCanvas.height = this.canvas.height;\n\t\tthis.fontCanvas.style.width = (this.canvas.width - 1) + 'px';\n\t\tthis.fontCanvas.style.height = (this.canvas.height - 1) + 'px';\n\n\t\tthis.font = this.fontCanvas.getContext('2d');\n\n\t\tthis.canvasSize = glm.vec2.fromValues(this.canvas.clientWidth, this.canvas.clientHeight);\n\n\t\tif (!this.settings.allowContextMenu) {\n\t\t\tthis.canvas.oncontextmenu = e => {\n\t\t\t\te.preventDefault();\n\t\t\t};\n\t\t\tthis.fontCanvas.oncontextmenu = e => {\n\t\t\t\te.preventDefault();\n\t\t\t};\n\t\t}\n\n\t\tRenderCommand.setClearColor(glm.vec4.fromValues(this.settings.clearColor[0], this.settings.clearColor[1], this.settings.clearColor[2], 1.0));\n\t}\n\n\t/** Get the font canvas element.\n\t * @returns {HTMLCanvasElement} The canvas.\n\t */\n\tpublic static getFontCanvas(): HTMLCanvasElement {\n\t\treturn this.fontCanvas;\n\t}\n\n\t/**\n\t * Resize the canvas.\n\t * @param {number} width The new width of the canvas.\n\t * @param {number} height The new height of the canvas. \n\t */\n\tpublic static resize(width: number, height: number) {\n\t\tthis.canvas.width = width;\n\t\tthis.canvas.height = height;\n\t\tthis.fontCanvas.width = width;\n\t\tthis.fontCanvas.height = height;\n\t}\n\n\tpublic static isResizing(): boolean {\n\t\treturn this.resizing;\n\t}\n\n\t/** Get the width of the rendering surface.\n\t * @returns {number} The width.\n\t */\n\tpublic static getWidth(): number {\n\t\treturn this.canvas.width;\n\t}\n\n\t/** Get the height of the rendering surface.\n\t * @returns {number} The height.\n\t*/\n\tpublic static getHeight(): number {\n\t\treturn this.canvas.height;\n\t}\n\n\t/**\n\t * Clear the current framebuffer with a specified color. If no framebuffers are bound, method will clear the canvas.\n\t * @param {glm.vec4} [color] The clear color all pixels will be set to. If null, will use the color specified in the ApplicationSettings.\n\t */\n\tpublic static clear(color?: glm.vec4) {\n\t\tRenderCommand.setClearColor(color ? color : glm.vec4.fromValues(this.settings.clearColor[0], this.settings.clearColor[1], this.settings.clearColor[2], 1.0));\n\t\tRenderCommand.clear();\n\t}\n\n\t/**\n\t * Sets the event callback function which the surface uses to push events. Set only in Polar.Application. Not to be used by users.\n\t * @internal\n\t * @param {(event: Event) => void} callback The callback function.\n\t */\n\tpublic static setEventCallback(callback: (event: Event) => void) {\n\t\tthis.eventCallbackFn = callback;\n\t}\n\n\t/**\n\t * Called every update. Not to be called by users. Called within Polar.Application.\n\t * @internal\n\t * @param {number} dt The time elapsed since the last frame in seconds.\n\t */\n\tpublic static onUpdate(dt: number) {\n\t\t// Check for resize every 300ms.\n\t\tif (this.resizeTimer.update(dt)) {\n\n\t\t\tif (this.canvasSize[0] !== this.canvas.clientWidth || this.canvasSize[1] !== this.canvas.clientHeight) {\n\t\t\t\tif (this.settings.displayMode == 'fill') {\n\t\t\t\t\tthis.canvas.width = this.canvas.clientWidth;\n\t\t\t\t\tthis.canvas.height = this.canvas.clientHeight;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.fontCanvas.style.left =  this.canvas.offsetLeft.toString() + 'px';\n\t\t\t\tthis.fontCanvas.style.top = this.canvas.offsetTop.toString() + 'px';\n\t\t\t\tthis.fontCanvas.width = this.canvas.width;\n\t\t\t\tthis.fontCanvas.height = this.canvas.height;\n\t\t\t\tthis.fontCanvas.style.width = (this.canvas.width - 1) + 'px';\n\t\t\t\tthis.fontCanvas.style.height = (this.canvas.height - 1) + 'px';\n\n\t\t\t\tthis.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\t\t\t\tthis.eventCallbackFn(new CanvasResizeEvent(this.canvas.width, this.canvas.height));\n\t\t\t}\n\n\t\t\tthis.canvasSize = glm.vec2.fromValues(this.canvas.width, this.canvas.height);\n\t\t}\n\t}\n}","import { Surface as s } from './Surface';\n\n/** Represents a 2D OpenGL Texture */\nexport class Texture2D {\n\tprivate path: string;\n\tprivate width: number;\n\tprivate height: number;\n\tprivate texture: WebGLTexture;\n\n\tprivate loaded: boolean;\n\n\t/**\n\t * Create a texture.\n\t * @param {string} [path] The path of the texture image file.\n\t */\n\tpublic constructor() {\n\t\tthis.loaded = false;\n\n\t\tthis.texture = s.gl.createTexture();\n\t\ts.gl.bindTexture(s.gl.TEXTURE_2D, this.texture);\n\t\t// Fill texture with a 1x1 sample pixel.\n\t\ts.gl.texImage2D(s.gl.TEXTURE_2D, 0, s.gl.RGBA, 1, 1, 0, s.gl.RGBA, s.gl.UNSIGNED_BYTE, new Uint8Array([25, 25, 25, 255]));\n\t\t// Set texture parameters.\n\t\ts.gl.texParameteri(s.gl.TEXTURE_2D, s.gl.TEXTURE_MIN_FILTER, s.gl.LINEAR);\n\t\ts.gl.texParameteri(s.gl.TEXTURE_2D, s.gl.TEXTURE_MAG_FILTER, s.gl.NEAREST);\n\n\t\ts.gl.texParameteri( s.gl.TEXTURE_2D, s.gl.TEXTURE_WRAP_S, s.gl.CLAMP_TO_EDGE );\n\t\ts.gl.texParameteri( s.gl.TEXTURE_2D, s.gl.TEXTURE_WRAP_T, s.gl.CLAMP_TO_EDGE );\n\t}\n\n\t/**\n\t * Load an image into the texture through a HTMLImageElement.\n\t * @param {HTMLImageElement} image The image to be loaded.\n\t */\n\tpublic loadFromImage(image: HTMLImageElement) {\n\t\tthis.path = image.src;\n\t\tif (image.complete) {\n\t\t\tthis.createTexture(image);\n\t\t}\n\t\telse {\n\t\t\timage.addEventListener('load', () => {\n\t\t\t\tthis.createTexture(image);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Load an image into the texture through a path.\n\t * @param {string} path The path of the image.\n\t */\n\tpublic loadFromPath(path: string) {\n\t\tthis.path = path;\n\t\t\n\t\tif(path) {\n\t\t\tconst image = new Image();\n\t\t\timage.src = this.path;\n\t\t\timage.addEventListener('load', () => {\n\t\t\t\tthis.createTexture(image);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Load an array of pixels into the texture.\n\t * @param {Uint8Array} pixels Array of pixel data to be inputted.\n\t * @param {number} width The width of the texture in pixels.\n\t * @param {number} height The height of the texture in pixels.\n\t * @param {number} [internalFormat=gl.RGBA] The OpenGL internal format.\n\t * @param {number} [format=gl.RGBA] The OpenGL format.\n\t */\n\tpublic loadFromArray(pixels: Uint8Array, width: number, height: number, internalFormat: number = s.gl.RGBA, format: number = s.gl.RGBA) {\n\t\ts.gl.bindTexture(s.gl.TEXTURE_2D, this.texture);\n\t\ts.gl.texImage2D(s.gl.TEXTURE_2D, 0, internalFormat , width, height, 0, format, s.gl.UNSIGNED_BYTE, pixels);\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.loaded = true;\n\t}\n\n\t/**\n\t * Load an empty texture of specified width and height.\n\t * @param {number} width The width of the texture in pixels.\n\t * @param {number} height The height of the texture in pixels.\n\t * @param {number} [internalFormat=gl.RGBA] The OpenGL internal format.\n\t * @param {number} [format=gl.RGBA] The OpenGL format.\n\t */\n\tpublic loadEmpty(width: number, height: number, internalFormat: number = s.gl.RGBA, format: number = s.gl.RGBA) {\n\t\ts.gl.bindTexture(s.gl.TEXTURE_2D, this.texture);\n\t\ts.gl.texImage2D(s.gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, s.gl.UNSIGNED_BYTE, null);\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t}\n\n\t/**\n\t * Get the texture's width.\n\t * @returns {number} The texture's width.\n\t */\n\tpublic getWidth(): number {\n\t\treturn this.width;\n\t}\n\n\t/**\n\t * Get the texture's height.\n\t * @returns {number} The texture's height.\n\t */\n\tpublic getHeight(): number {\n\t\treturn this.height;\n\t}\n\n\t/** Bind the texture \n\t * @param {number} [slot=gl.TEXTURE0] The texture number.\n\t*/\n\tpublic bind(slot: number = s.gl.TEXTURE0) {\n\t\ts.gl.activeTexture(slot);\n\t\ts.gl.bindTexture(s.gl.TEXTURE_2D, this.texture);\n\t}\n\n\tpublic unbind() {\n\t\ts.gl.bindTexture(s.gl.TEXTURE_2D, null);\n\t}\n\n\t/**\n\t * Test if the texture has been loaded.\n\t * @returns {boolean} Whether the texture has been loaded.\n\t */\n\tpublic isLoaded(): boolean {\n\t\treturn this.loaded;\n\t}\n\n\t/**\n\t * Get the OpenGL texture.\n\t * @returns {WebGLTexture}\n\t */\n\tpublic getGLTexture(): WebGLTexture {\n\t\treturn this.texture;\n\t}\n\n\t/**\n\t * Create a new texture from an image element.\n\t * @param {HTMLImageElement} image The image.\n\t */\n\tprivate createTexture(image: HTMLImageElement) {\n\t\ts.gl.bindTexture(s.gl.TEXTURE_2D, this.texture);\n\t\ts.gl.texImage2D(s.gl.TEXTURE_2D, 0, s.gl.RGBA, s.gl.RGBA, s.gl.UNSIGNED_BYTE, image);\n\t\ts.gl.generateMipmap(s.gl.TEXTURE_2D);\n\t\tthis.loaded = true;\n\t\tthis.width = image.width;\n\t\tthis.height = image.height;\n\t}\n}","import { MaxRectsPacker, Rectangle } from 'maxrects-packer';\nimport * as glm from 'gl-matrix';\nimport { Texture2D } from './Texture';\n\n/** Represents a single texture within a texture atlas. */\nexport class AtlasEntry extends Rectangle {\n\tpublic alias: string;\n\tpublic image: HTMLImageElement;\n\n\tpublic bounds: glm.vec4;\n\n\tconstructor(alias: string) {\n\t\tsuper();\n\t\tthis.alias = alias;\n\t}\n}\n\n/** A class which combines and indexes a number of images into a single image. */\nexport class TextureAtlas {\n\t\n\tprivate entries: Map<string, AtlasEntry>;\n\tprivate canvas: HTMLCanvasElement;\n\tprivate context: CanvasRenderingContext2D;\n\tprivate texture: Texture2D;\n\n\t/** Create a new texture atlas. */\n\tpublic constructor() {\n\t\tthis.entries = new Map<string, AtlasEntry>();\n\t\tthis.canvas = document.createElement('canvas');\n\t\tthis.context = this.canvas.getContext('2d');\n\t\tthis.texture = new Texture2D();\n\t}\n\n\t/** Set the images of the atlas and calculate.\n\t * @param {[string, HTMLImageElement][]} images A list of image tuples with format: [alias: string, image: HTMLImageElement].\n\t */\n\tpublic setImages(images: [string, HTMLImageElement][]) {\n\t\t\n\t\tconst rawEntries: AtlasEntry[] = [];\n\n\t\tfor (const [alias, image] of images) {\n\t\t\tif (!image.complete) {\n\t\t\t\tconsole.error(`Image '${alias}' not loaded.`);\n\t\t\t}\n\n\t\t\tconst entry = new AtlasEntry(alias);\n\t\t\trawEntries.push(entry);\n\n\t\t\tentry.image = image;\n\t\t\tentry.width = entry.image.width;\n\t\t\tentry.height = entry.image.height;\n\t\t}\n\n\t\tthis.pack(rawEntries);\n\n\t\tconst atlasImage = new Image();\n\t\tatlasImage.src = this.canvas.toDataURL();\n\t\t\n\t\tthis.texture.loadFromImage(atlasImage);\n\t}\n\n\t/** \n\t * Pack the images\n\t * @param {AtlasEntry[]} rawEntries\n\t */\n\tprivate pack(rawEntries: AtlasEntry[]) {\n\t\tlet packer = new MaxRectsPacker();\n\t\tpacker.addArray(rawEntries);\n\n\t\tif (packer.bins.length > 1) console.error('Too many textures in atlas.');\n\t\telse if (packer.bins.length == 0) console.error('Not enough textures in atlas.');\n\n\t\tconst bin = packer.bins[0];\n\t\tthis.canvas.width = bin.width;\n\t\tthis.canvas.height = bin.height;\n\t\tthis.context.clearRect(0, 0, bin.width, bin.height);\n\t\t\n\t\tthis.entries.clear();\n\t\tfor (const rect of bin.rects) {\n\t\t\tconst entry = rect as AtlasEntry;\n\t\t\tentry.bounds = glm.vec4.create();\n\t\t\tentry.bounds.set([entry.x / bin.width, entry.y / bin.height,\n\t\t\t\tentry.width / bin.width, entry.height / bin.height]);\n\n\t\t\tthis.entries.set(entry.alias, entry);\n\t\t\tthis.context.drawImage(entry.image, entry.x, entry.y);\n\t\t}\n\t}\n\n\t/**\n\t * Get the atlas texture\n\t * @returns {Texture2D}\n\t */\n\tpublic getTexture(): Texture2D {\n\t\treturn this.texture;\n\t}\n\n\t/**\n\t * Get the bounds of a texture within the atlas.\n\t * Format: x, y, width, height.\n\t * @param {string} alias The image's alias.\n\t * @returns {glm.vec4} The bounds. Format: x, y, width, height.\n\t */\n\tpublic getBounds(alias: string): glm.vec4 {\n\t\treturn this.entries.get(alias).bounds;\n\t}\n}","import { Texture2D } from './Texture';\nimport { Surface } from './Surface';\n\n/** Stores a number of textures accessible through aliases. */\nexport class TextureLibrary {\n\t\n\tprivate textures: Map<string, Texture2D>;\n\n\t/** Create a new TextureLibrary */\n\tpublic constructor() {\n\t\tthis.textures = new Map<string, Texture2D>();\n\t}\n\n\tpublic get(alias: string): Texture2D {\n\t\treturn this.textures.get(alias);\n\t}\n\n\tpublic set(alias: string, texture: Texture2D) {\n\t\tthis.textures.set(alias, texture);\n\t}\n\n\t/**\n\t * Load a single texture into the texture library through an image.\n\t * @param {string} alias The alias used to access texture.\n\t * @param {HTMLImageElement} image The image to be loaded into the texture.\n\t */\n\tpublic loadFromImage(alias: string, image: HTMLImageElement) {\n\t\tlet texture = new Texture2D();\n\t\ttexture.loadFromImage(image);\n\t\tthis.textures.set(alias, texture);\n\t}\n\n\t/**\n\t * Load many textures into the library through an image.\n\t * @param {[string, HTMLImageElement][]} data Array of alias/image pairs to be loaded into the library.\n\t */\n\tpublic loadManyFromImage(data: [string, HTMLImageElement][]) {\n\t\tfor (let [alias, image] of data) {\n\t\t\tthis.loadFromImage(alias, image);\n\t\t}\n\t}\n\n\t/**\n\t * Load a single texture into the texture library through a path.\n\t * @param alias The alias used to access texture.\n\t * @param path The path of an image to be loaded.\n\t */\n\tpublic loadFromPath(alias: string, path: string) {\n\t\tlet texture = new Texture2D();\n\t\ttexture.loadFromPath(path);\n\t\tthis.textures.set(alias, texture);\n\t}\n\n\t/**\n\t * Load many textures into the library through a path.\n\t * @param {[string, string][]} data Array of alias/path pairs to be loaded into the library.\n\t */\n\tpublic loadManyFromPath(data: [string, string][]) {\n\t\tfor (let [alias, path] of data) {\n\t\t\tthis.loadFromPath(alias, path);\n\t\t}\n\t}\n\n\t/**\n\t * Load a single texture into the texture library through an array of pixels.\n\t * @param {string} alias The alias used to access texture.\n\t * @param {Uint8Array} pixels Array of pixel data to be inputted.\n\t * @param {number} width The width of the texture in pixels.\n\t * @param {number} height The height of the texture in pixels.\n\t * @param {number} [internalFormat=gl.RGBA] The OpenGL internal format.\n\t * @param {number} [format=gl.RGBA] The OpenGL format.\n\t */\n\tpublic loadFromArray(alias: string, pixels: Uint8Array, width: number, height: number, internalFormat: number = Surface.gl.RGBA, format: number = Surface.gl.RGBA) {\n\t\tlet texture = new Texture2D();\n\t\ttexture.loadFromArray(pixels, width, height, internalFormat, format);\n\t\tthis.textures.set(alias, texture);\n\t}\n\n\t/**\n\t * Load a single empty texture into the texture library.\n\t * @param alias The alias used to access texture.\n\t * @param {number} width The width of the texture in pixels.\n\t * @param {number} height The height of the texture in pixels.\n\t * @param {number} [internalFormat=gl.RGBA] The OpenGL internal format.\n\t * @param {number} [format=gl.RGBA] The OpenGL format.\n\t */\n\tpublic loadEmpty(alias: string, width: number, height: number, internalFormat: number = Surface.gl.RGBA, format: number = Surface.gl.RGBA) {\n\t\tlet texture = new Texture2D();\n\t\ttexture.loadEmpty(width, height, internalFormat, format);\n\t\tthis.textures.set(alias, texture);\n\t}\n}","import { ShaderDataType, BufferLayout, VertexBuffer, IndexBuffer } from './Buffer';\nimport { Surface } from './Surface';\nimport { Shader }  from './Shader';\n\n/**\n * Get the OpenGL base type from a shader data type.\n * @param {ShaderDataType} type The shader data type.\n * @returns {number} The OpenGL enum.\n * @internal\n */\nfunction shaderDataTypeToOpenGLBaseType(type: ShaderDataType): number {\n\tswitch (type) {\n\tcase ShaderDataType.Float:  return Surface.gl.FLOAT;\n\tcase ShaderDataType.Float2: return Surface.gl.FLOAT;\n\tcase ShaderDataType.Float3: return Surface.gl.FLOAT;\n\tcase ShaderDataType.Float4: return Surface.gl.FLOAT;\n\tcase ShaderDataType.Mat3:   return Surface.gl.FLOAT;\n\tcase ShaderDataType.Mat4:   return Surface.gl.FLOAT;\n\tcase ShaderDataType.Int:    return Surface.gl.INT;\n\tcase ShaderDataType.Int2:   return Surface.gl.INT;\n\tcase ShaderDataType.Int3:   return Surface.gl.INT;\n\tcase ShaderDataType.Int4:   return Surface.gl.INT;\n\tcase ShaderDataType.Bool:   return Surface.gl.BOOL;\n\t}\n\tconsole.assert(false, 'Unknown ShaderDataType!');\n\treturn 0;\n}\n\n/** Represents an OpenGL vertex array. */\nexport class VertexArray {\n\tprivate vertexArray: WebGLVertexArrayObject;\n\tprivate vertexBuffers: VertexBuffer[];\n\tprivate indexBuffer: IndexBuffer;\n\n\t/** Create a new vertex array. */\n\tpublic constructor () {\n\t\tthis.vertexArray = Surface.gl.createVertexArray();\n\t\tthis.vertexBuffers = [];\n\t}\n\n\t/** Bind the vertex array in OpenGL. */\n\tpublic bind() {\n\t\tSurface.gl.bindVertexArray(this.vertexArray);\n\t}\n\n\t/** Unbind the vertex array in OpenGL. */\n\tpublic unbind() {\n\t\tSurface.gl.bindVertexArray(null);\n\t}\n\n\t/**\n\t * Add a vertex buffer to the array.\n\t * @param {VertexBuffer} vertexBuffer The vertex buffer.\n\t * @param {Shader} shader The shader.\n\t */\n\tpublic addVertexBuffer(vertexBuffer: VertexBuffer, shader: Shader) {\n\t\tconsole.assert(vertexBuffer.getLayout().getElements().length != 0, 'Vertex Buffer has no layout!');\n\n\t\tshader.bind();\n\t\tSurface.gl.bindVertexArray(this.vertexArray);\n\t\tvertexBuffer.bind();\n\n\t\tconst layout: BufferLayout = vertexBuffer.getLayout();\n\t\tfor (const element of layout.getElements()) {\n\t\t\tlet location;\n\t\t\tif (element.location < 0) {\n\t\t\t\tlocation = shader.getAttribLocation(element.name);\n\t\t\t\tif (location < 0){\n\t\t\t\t\tconsole.error(`Attribute '${element.name}' not found in shader '${shader.getName()}'.`);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlocation = element.location;\n\t\t\t}\n\t\t\t\n\t\t\tif (element.type === ShaderDataType.Mat4) {\n\t\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\t\tconst loc = location + i;\n\t\t\t\t\tconst size = element.getComponentCount() / 4;\n\t\t\t\t\tconst type = shaderDataTypeToOpenGLBaseType(element.type);\n\t\t\t\t\tconst stride = layout.getStride();\n\t\t\t\t\tconst offset = element.offset + 16 * i;\n\n\t\t\t\t\tSurface.gl.enableVertexAttribArray(loc);\n\t\t\t\t\tSurface.gl.vertexAttribPointer(loc, size, type, element.normalized, stride, offset);\n\t\n\t\t\t\t\tif (element.divisor >= 0) {\n\t\t\t\t\t\tSurface.gl.vertexAttribDivisor(location + i, element.divisor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSurface.gl.enableVertexAttribArray(location);\n\t\t\t\tSurface.gl.vertexAttribPointer(location, \n\t\t\t\t\telement.getComponentCount(), \n\t\t\t\t\tshaderDataTypeToOpenGLBaseType(element.type),\n\t\t\t\t\telement.normalized, \n\t\t\t\t\tlayout.getStride(),\n\t\t\t\t\telement.offset);\n\t\n\t\t\t\tif (element.divisor >= 0) {\n\t\t\t\t\tSurface.gl.vertexAttribDivisor(location, element.divisor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tshader.unbind();\n\t\tthis.vertexBuffers.push(vertexBuffer);\n\t}\n\n\t/**\n\t * Set the vertex array's index buffer.\n\t * @param {IndexBuffer} indexBuffer The index buffer.\n\t */\n\tpublic setIndexBuffer(indexBuffer: IndexBuffer) {\n\t\tSurface.gl.bindVertexArray(this.vertexArray);\n\t\tindexBuffer.bind();\n\n\t\tthis.indexBuffer = indexBuffer;\n\t}\n\n\t/**\n\t * Get the vertex buffers.\n\t * @returns {VertexBuffer[]} The vertex buffers.\n\t */\n\tpublic getVertexBuffers(): VertexBuffer[] {\n\t\treturn this.vertexBuffers;\n\t}\n\n\t/**\n\t * Get the index buffer\n\t * @returns {IndexBuffer} The index buffer.\n\t */\n\tpublic getIndexBuffer(): IndexBuffer {\n\t\treturn this.indexBuffer;\n\t}\n}","import * as glm from 'gl-matrix';\n\n/**\n * Generate a transformation matrix.\n * @param {number} x The x position.\n * @param {number} y The y position.\n * @param {number} rotation The rotation.\n * @param {number} width The width to scale by.\n * @param {number} height The height to scale by.\n * @param {number} zIndex The z index of the object.\n * @returns {glm.mat4} The transformation matrix.\n */\nexport function createTransform(x: number = 0, y: number = 0, rotation: number = 0, width: number = 1, height: number = 1, zIndex: number = 0): glm.mat4 {\n\tlet transform = glm.mat4.create();\n\ttransform = glm.mat4.translate(transform, transform, glm.vec3.fromValues(x, y, zIndex));\n\ttransform = glm.mat4.rotate(transform, transform, rotation, glm.vec3.fromValues(0, 0, 1));\n\ttransform = glm.mat4.scale(transform, transform, glm.vec3.fromValues(width, height, 1));\n\treturn transform;\n}\n\nexport function makeVec2(x: number = 0, y: number = 0): glm.vec2 {\n\treturn glm.vec2.fromValues(x, y);\n}\n\nexport function makeVec3(x: number = 0, y: number = 0, z: number = 0): glm.vec3 {\n\treturn glm.vec3.fromValues(x, y, z);\n}\n\nexport function makeVec4(x: number = 0, y: number = 0, z: number = 0, w: number = 0): glm.vec4 {\n\treturn glm.vec4.fromValues(x, y, z, w);\n}","import * as glm from 'gl-matrix';\nimport { OrthographicCamera } from '../Renderer/OrthographicCamera';\nimport { Input } from '../Core/Input';\nimport { Event, EventDispatcher, EventHandler } from '../Events/Event';\nimport { CanvasResizeEvent } from 'Polar/Events/ApplicationEvent';\nimport { MouseWheelEvent } from 'Polar/Events/MouseEvent';\n\n/** Class which controls the input and control of an orthographic camera. */\nexport class OrthographicCameraController implements EventHandler {\n\tprivate aspectRatio: number;\n\tprivate zoomLevel: number;\n\tprivate camera: OrthographicCamera;\n\n\tprivate doRotation: boolean;\n\n\t// The camera's position in world space.\n\tprivate cameraPosition: glm.vec3 = glm.vec3.create();\n\t// The camera's current rotation.\n\tprivate cameraRotation = 0.0;\n\t// How fast the camera rotates in radians per second.\n\tprivate cameraRotationSpeed = Math.PI / 2;\n\n\t/**\n\t * Create an orthographic camera controller.\n\t * @param {number} aspectRatio The aspect ratio of the camera's view port. width / height.\n\t * @param {number} [initialZoomLevel=1.0] The initial zoom of the camera.\n\t * @param {boolean} [doRotation=false] Turn on / off camera rotation controls.\n\t */\n\tpublic constructor(aspectRatio: number, initialZoomLevel: number = 1.0, doRotation: boolean = false) {\n\t\tthis.aspectRatio = aspectRatio;\n\t\tthis.zoomLevel = initialZoomLevel;\n\t\tthis.doRotation = doRotation;\n\t\tthis.camera = new OrthographicCamera(-this.aspectRatio * this.zoomLevel, this.aspectRatio * this.zoomLevel, -this.zoomLevel, this.zoomLevel);\n\t}\n\n\t/**\n\t * Update function to be called every frame to update the camera controller.\n\t * @param {number} deltaTime The elapsed time between the previous and current frame in seconds.\n\t */\n\tpublic onUpdate(deltaTime: number) {\n\t\tlet doPosition = false;\n\t\tif (Input.isKeyPressed('a')) {\n\t\t\tthis.cameraPosition[0] -=  this.cameraTranslationSpeed(this.zoomLevel) * deltaTime;\n\t\t\tdoPosition = true;\n\t\t}\n\t\tif (Input.isKeyPressed('d')) {\n\t\t\tthis.cameraPosition[0] += this.cameraTranslationSpeed(this.zoomLevel) * deltaTime;\n\t\t\tdoPosition = true;\n\t\t}\n\t\tif (Input.isKeyPressed('s')) {\n\t\t\tthis.cameraPosition[1] -= this.cameraTranslationSpeed(this.zoomLevel) * deltaTime;\n\t\t\tdoPosition = true;\n\t\t}\n\t\tif (Input.isKeyPressed('w')) {\n\t\t\tthis.cameraPosition[1] += this.cameraTranslationSpeed(this.zoomLevel) * deltaTime;\n\t\t\tdoPosition = true;\n\t\t}\n\n\t\tif (this.doRotation) {\n\t\t\tlet doRotation = false;\n\t\t\tif (Input.isKeyPressed('q')) {\n\t\t\t\tthis.cameraRotation += this.cameraRotationSpeed * deltaTime;\n\t\t\t\tdoRotation = true;\n\t\t\t}\n\t\t\tif (Input.isKeyPressed('e')) {\n\t\t\t\tthis.cameraRotation -= this.cameraRotationSpeed * deltaTime;\n\t\t\t\tdoRotation = true;\n\t\t\t}\n\t\t\tif (doRotation) {\n\t\t\t\tthis.camera.setRotation(this.cameraRotation);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Only recalculate if the position has changed.\n\t\tif (doPosition)\n\t\t\tthis.camera.setPosition(this.cameraPosition);\n\t}\n\n\tpublic onEvent(event: Event) {\n\t\tconst dispatcher = new EventDispatcher(event);\n\t\tdispatcher.dispatch(CanvasResizeEvent, this.onCanvasResize.bind(this));\n\t\tdispatcher.dispatch(MouseWheelEvent, this.onMouseWheel.bind(this));\n\t}\n\n\tprivate onCanvasResize(event: CanvasResizeEvent): boolean {\n\t\tthis.aspectRatio = event.width / event.height;\n\t\tthis.camera.setProjection(-this.aspectRatio * this.zoomLevel, this.aspectRatio * this.zoomLevel, -this.zoomLevel, this.zoomLevel);\n\t\treturn false;\n\t}\n\n\tprivate onMouseWheel(event: MouseWheelEvent): boolean {\n\t\tthis.zoomLevel += event.deltaY / 1000 * this.zoomLevel;\n\t\tthis.zoomLevel = this.zoomLevel > 0.1 ? this.zoomLevel : 0.1;\n\t\tthis.camera.setProjection(-this.aspectRatio * this.zoomLevel, this.aspectRatio * this.zoomLevel, -this.zoomLevel, this.zoomLevel);\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get the internal camera controlled by the OrthographicCameraController.\n\t * @returns {Camera} The internal camera  object.\n\t */\n\tpublic getCamera(): OrthographicCamera {\n\t\treturn this.camera;\n\t}\n\n\t/**\n\t * A sigmoid function to calculate The speed of the camera at the specified zoom.\n\t * @param {number} zoom The current zoom of the camera.\n\t * @returns {Camera} The speed of the camera in world units / second.\n\t */\n\tprivate cameraTranslationSpeed(zoom: number): number {\n\t\treturn 20 / (1 + 30 * Math.pow(Math.E, -0.4 * zoom));\n\t}\n}","\n/** A utility used to check when a certain time has elapsed. */\nexport class Timer {\n\n\t// Delay the timer will wait before returning true.\n\tprivate delay: number;\n\t// Boolean to hold if the timer repeats/loops or not.\n\tprivate repeat: boolean;\n\t// Current elapsed time in seconds, reset on every completion.\n\tprivate elapsed: number = 0;\n\t// Boolean to hold if the timer has completed its cycle, for non-repeat timers.\n\tprivate completed: boolean = false;\n\t// Boolean to hold the value that will be returned when a non-repeat timer has completed.\n\tprivate completionValue: boolean;\n\n\t/**\n\t * Create a new timer.\n\t * @param {number} delay How long the timer takes to complete in seconds.\n\t * @param {boolean} completionValue The value the timer update will return once the timer is completed.\n\t * @param {boolean} repeat Whether the timer will reset and repeat on completion.\n\t */\n\tpublic constructor(delay: number = 1, completionValue: boolean = false, repeat: boolean = false) {\n\t\tthis.delay = delay;\n\t\tthis.completionValue = completionValue;\n\t\tthis.repeat = repeat;\n\t}\n\n\t/**\n\t * Update the timer and check to see if it is completed.\n\t * @param {number} deltaTime The time elapsed since the previous frame.\n\t * @returns {boolean} Whether the timer is activated.\n\t */\n\tpublic update(deltaTime: number): boolean {\n\t\tif (this.completed)\n\t\t\treturn this.completionValue;\n\t\t\n\t\tthis.elapsed += deltaTime;\n\n\t\tif (this.elapsed >= this.delay) {\n\t\t\tif (!this.repeat)\n\t\t\t\tthis.completed = true;\n\t\t\t\n\t\t\tthis.elapsed = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get the delay of the camera in seconds.\n\t * @returns {number} The delay of the camera in seconds.\n\t */\n\tpublic getDelay(): number {\n\t\treturn this.delay;\n\t}\n\n\t/**\n\t * Get the elapsed time in seconds.\n\t * @returns {number} The elapsed time in seconds.\n\t */\n\tpublic getElapsed(): number {\n\t\treturn this.elapsed;\n\t}\n\n\t/**\n\t * Get the completion percentage of the timer between 0 and 1.\n\t * @returns {number} Completion percentage.\n\t */\n\tpublic getPercentage(): number {\n\t\treturn this.elapsed / this.delay;\n\t}\n\n\t/**\n\t * Set the time it will take until the timer finishes / resets.\n\t * @param delay The delay time in seconds.\n\t */\n\tpublic setDelay(delay: number) {\n\t\tthis.delay = delay;\n\t}\n}"],"sourceRoot":""}